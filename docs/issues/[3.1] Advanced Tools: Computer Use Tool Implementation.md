# [3.1] Advanced Tools: Computer Use Tool Implementation

## Overview

### Current State
- Basic file system tools (read, write, list directory)
- No desktop interaction capabilities
- Limited to file-based operations
- No screen capture or automation features

### Target State
- Full integration with Anthropic's computer_20250124 tool
- Screen capture and visual analysis capabilities
- Mouse and keyboard automation with coordinate system management
- Desktop interaction APIs with security sandboxing
- Window management and application control
- Multi-monitor support with resolution awareness

### Why This Matters
- **Desktop Automation**: Enable Claude to interact with any application on the desktop
- **Visual Understanding**: Screen capture allows Claude to see and analyze UI elements
- **User Productivity**: Automate complex multi-application workflows
- **Accessibility**: Provide assistance for users with disabilities
- **Strategic Value**: Transform from file-focused tool to comprehensive desktop assistant

## Technical Requirements

### 1. Anthropic Computer Use Tool Integration

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use serde::{Deserialize, Serialize};
use image::{ImageBuffer, RgbaImage};
use uuid::Uuid;

/// Computer use tool implementing Anthropic's computer_20250124 specification
#[derive(Debug)]
pub struct ComputerUseTool {
    /// Screen capture service
    screen_capture: Arc<ScreenCaptureService>,
    
    /// Input automation service  
    input_automation: Arc<InputAutomationService>,
    
    /// Window management service
    window_manager: Arc<WindowManager>,
    
    /// Security policy enforcer
    security_enforcer: Arc<ComputerUseSecurityEnforcer>,
    
    /// Session manager for tracking operations
    session_manager: Arc<ComputerUseSessionManager>,
    
    /// Performance monitor
    performance_monitor: Arc<ComputerUsePerformanceMonitor>,
}

/// Computer use action types as defined by Anthropic
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "action")]
pub enum ComputerAction {
    /// Take a screenshot of the entire screen or specific area
    Screenshot {
        /// Optional display number (for multi-monitor)
        display_num: Option<u32>,
        /// Optional rectangle to capture (x, y, width, height)
        rectangle: Option<ScreenRectangle>,
    },
    
    /// Click at specific coordinates
    Click {
        /// X coordinate in pixels
        coordinate: [i32; 2],
        /// Mouse button (left, right, middle)
        button: MouseButton,
        /// Number of clicks (1 for single, 2 for double)
        click_count: Option<u32>,
    },
    
    /// Right-click at specific coordinates
    RightClick {
        /// X coordinate in pixels  
        coordinate: [i32; 2],
    },
    
    /// Middle-click at specific coordinates
    MiddleClick {
        /// X coordinate in pixels
        coordinate: [i32; 2],
    },
    
    /// Double-click at specific coordinates
    DoubleClick {
        /// X coordinate in pixels
        coordinate: [i32; 2],
    },
    
    /// Drag from one point to another
    Drag {
        /// Starting coordinates
        coordinate: [i32; 2],
        /// Ending coordinates  
        end_coordinate: [i32; 2],
    },
    
    /// Type text at current cursor position
    Type {
        /// Text to type
        text: String,
    },
    
    /// Press specific keys
    Key {
        /// Key combination to press
        key: String,
    },
    
    /// Scroll in a direction
    Scroll {
        /// Coordinates to scroll at
        coordinate: [i32; 2],
        /// Scroll direction and amount
        scroll_direction: ScrollDirection,
        /// Number of scroll steps
        clicks: i32,
    },
    
    /// Move cursor to specific coordinates
    Cursor {
        /// Target coordinates
        coordinate: [i32; 2],
    },
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum MouseButton {
    Left,
    Right,
    Middle,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ScrollDirection {
    Up,
    Down,
    Left,
    Right,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScreenRectangle {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
}

/// Computer use tool result containing screenshot and metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComputerUseResult {
    /// Action that was performed
    pub action_performed: ComputerAction,
    
    /// Screenshot data (base64 encoded PNG)
    pub screenshot: Option<String>,
    
    /// Screen dimensions at time of action
    pub screen_size: ScreenSize,
    
    /// Cursor position after action
    pub cursor_position: [i32; 2],
    
    /// Success status
    pub success: bool,
    
    /// Error message if action failed
    pub error: Option<String>,
    
    /// Performance metrics
    pub performance: ActionPerformanceMetrics,
    
    /// Security validation results
    pub security_validation: SecurityValidationResult,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScreenSize {
    pub width: u32,
    pub height: u32,
    pub scale_factor: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActionPerformanceMetrics {
    /// Time taken to execute action
    pub execution_time_ms: u64,
    
    /// Screenshot capture time
    pub screenshot_time_ms: Option<u64>,
    
    /// Image compression time
    pub compression_time_ms: Option<u64>,
    
    /// Memory usage in bytes
    pub memory_used: u64,
}

#[async_trait]
impl AgentTool for ComputerUseTool {
    fn name(&self) -> &str {
        "computer"
    }
    
    fn description(&self) -> &str {
        "Control the computer by taking screenshots, clicking, typing, and scrolling. This tool enables interaction with desktop applications and UI elements."
    }
    
    async fn execute(&self, arguments: serde_json::Value) -> Result<ToolResult, ToolError> {
        let action: ComputerAction = serde_json::from_value(arguments)
            .map_err(|e| ToolError::InvalidArguments(e.to_string()))?;
        
        // Security validation
        self.security_enforcer.validate_action(&action).await?;
        
        // Start performance monitoring
        let perf_start = std::time::Instant::now();
        let session_id = self.session_manager.start_action(&action).await;
        
        // Execute the action
        let result = match action.clone() {
            ComputerAction::Screenshot { display_num, rectangle } => {
                self.take_screenshot(display_num, rectangle).await
            }
            ComputerAction::Click { coordinate, button, click_count } => {
                self.perform_click(coordinate, button, click_count.unwrap_or(1)).await
            }
            ComputerAction::RightClick { coordinate } => {
                self.perform_click(coordinate, MouseButton::Right, 1).await
            }
            ComputerAction::MiddleClick { coordinate } => {
                self.perform_click(coordinate, MouseButton::Middle, 1).await
            }
            ComputerAction::DoubleClick { coordinate } => {
                self.perform_click(coordinate, MouseButton::Left, 2).await
            }
            ComputerAction::Drag { coordinate, end_coordinate } => {
                self.perform_drag(coordinate, end_coordinate).await
            }
            ComputerAction::Type { text } => {
                self.perform_type(&text).await
            }
            ComputerAction::Key { key } => {
                self.perform_key(&key).await
            }
            ComputerAction::Scroll { coordinate, scroll_direction, clicks } => {
                self.perform_scroll(coordinate, scroll_direction, clicks).await
            }
            ComputerAction::Cursor { coordinate } => {
                self.move_cursor(coordinate).await
            }
        };
        
        // Record performance metrics
        let execution_time = perf_start.elapsed();
        self.performance_monitor.record_action_performance(&action, execution_time).await;
        
        // End session tracking
        self.session_manager.end_action(session_id, &result).await;
        
        match result {
            Ok(computer_result) => {
                Ok(ToolResult::ComputerUse(computer_result))
            }
            Err(e) => Err(e),
        }
    }
    
    fn resource_requirements(&self) -> ResourceRequirements {
        ResourceRequirements {
            cpu_weight: 0.3,
            memory_mb: 200,
            io_intensity: IOIntensity::High,
            network_required: false,
            exclusive_resources: HashSet::from([
                "screen_capture".to_string(),
                "input_system".to_string(),
            ]),
        }
    }
}
```

### 2. Screen Capture Service

```rust
use image::{ImageFormat, DynamicImage};
use tokio::sync::Semaphore;
use std::sync::atomic::{AtomicU64, Ordering};

/// High-performance screen capture service
pub struct ScreenCaptureService {
    /// Platform-specific screen capture implementation
    capture_backend: Box<dyn ScreenCaptureBackend + Send + Sync>,
    
    /// Image processing pipeline
    image_processor: Arc<ImageProcessor>,
    
    /// Capture rate limiter
    rate_limiter: Arc<Semaphore>,
    
    /// Performance metrics
    capture_count: Arc<AtomicU64>,
    total_capture_time: Arc<AtomicU64>,
    
    /// Monitor configuration cache
    monitor_cache: Arc<RwLock<Vec<MonitorInfo>>>,
}

/// Platform-agnostic screen capture trait
#[async_trait]
pub trait ScreenCaptureBackend {
    /// Capture the entire screen or specific display
    async fn capture_display(&self, display_id: Option<u32>) -> Result<RgbaImage, CaptureError>;
    
    /// Capture a specific rectangle of the screen
    async fn capture_rectangle(&self, rect: ScreenRectangle) -> Result<RgbaImage, CaptureError>;
    
    /// Get information about available displays
    async fn get_display_info(&self) -> Result<Vec<DisplayInfo>, CaptureError>;
    
    /// Get current cursor position and appearance
    async fn get_cursor_info(&self) -> Result<CursorInfo, CaptureError>;
}

#[derive(Debug, Clone)]
pub struct DisplayInfo {
    pub id: u32,
    pub name: String,
    pub width: u32,
    pub height: u32,
    pub scale_factor: f64,
    pub position: (i32, i32),
    pub is_primary: bool,
}

#[derive(Debug, Clone)]
pub struct MonitorInfo {
    pub display: DisplayInfo,
    pub work_area: ScreenRectangle,
    pub last_updated: std::time::Instant,
}

#[derive(Debug, Clone)]
pub struct CursorInfo {
    pub position: [i32; 2],
    pub visible: bool,
    pub cursor_type: CursorType,
}

#[derive(Debug, Clone)]
pub enum CursorType {
    Arrow,
    IBeam,
    Hand,
    Wait,
    Cross,
    SizeNS,
    SizeWE,
    SizeNWSE,
    SizeNESW,
    Custom(String),
}

impl ScreenCaptureService {
    pub fn new(backend: Box<dyn ScreenCaptureBackend + Send + Sync>) -> Self {
        Self {
            capture_backend: backend,
            image_processor: Arc::new(ImageProcessor::new()),
            rate_limiter: Arc::new(Semaphore::new(10)), // Max 10 concurrent captures
            capture_count: Arc::new(AtomicU64::new(0)),
            total_capture_time: Arc::new(AtomicU64::new(0)),
            monitor_cache: Arc::new(RwLock::new(Vec::new())),
        }
    }
    
    /// Take a screenshot and return base64 encoded PNG
    pub async fn take_screenshot(
        &self,
        display_num: Option<u32>,
        rectangle: Option<ScreenRectangle>,
    ) -> Result<(String, ScreenSize), CaptureError> {
        // Acquire rate limiting permit
        let _permit = self.rate_limiter.acquire().await
            .map_err(|_| CaptureError::RateLimited)?;
        
        let start_time = std::time::Instant::now();
        
        // Capture image
        let image = match rectangle {
            Some(rect) => self.capture_backend.capture_rectangle(rect).await?,
            None => self.capture_backend.capture_display(display_num).await?,
        };
        
        // Get screen size information
        let screen_size = ScreenSize {
            width: image.width(),
            height: image.height(),
            scale_factor: self.get_scale_factor(display_num).await?,
        };
        
        // Process and compress image
        let processed_image = self.image_processor.process_screenshot(image).await?;
        let base64_png = self.image_processor.encode_to_base64_png(processed_image).await?;
        
        // Update metrics
        let capture_time = start_time.elapsed();
        self.capture_count.fetch_add(1, Ordering::Relaxed);
        self.total_capture_time.fetch_add(capture_time.as_millis() as u64, Ordering::Relaxed);
        
        Ok((base64_png, screen_size))
    }
    
    /// Update monitor configuration cache
    pub async fn refresh_monitor_cache(&self) -> Result<(), CaptureError> {
        let displays = self.capture_backend.get_display_info().await?;
        let mut cache = self.monitor_cache.write().await;
        
        cache.clear();
        for display in displays {
            cache.push(MonitorInfo {
                work_area: ScreenRectangle {
                    x: display.position.0,
                    y: display.position.1,
                    width: display.width,
                    height: display.height,
                },
                display,
                last_updated: std::time::Instant::now(),
            });
        }
        
        Ok(())
    }
    
    async fn get_scale_factor(&self, display_id: Option<u32>) -> Result<f64, CaptureError> {
        let cache = self.monitor_cache.read().await;
        
        if let Some(id) = display_id {
            cache.iter()
                .find(|m| m.display.id == id)
                .map(|m| m.display.scale_factor)
                .ok_or(CaptureError::DisplayNotFound(id))
        } else {
            // Get primary display scale factor
            cache.iter()
                .find(|m| m.display.is_primary)
                .map(|m| m.display.scale_factor)
                .unwrap_or(1.0)
                .into()
        }
    }
    
    /// Get performance statistics
    pub fn get_performance_stats(&self) -> CapturePerformanceStats {
        let capture_count = self.capture_count.load(Ordering::Relaxed);
        let total_time = self.total_capture_time.load(Ordering::Relaxed);
        
        CapturePerformanceStats {
            total_captures: capture_count,
            average_capture_time_ms: if capture_count > 0 {
                total_time / capture_count
            } else {
                0
            },
            current_rate_limit: self.rate_limiter.available_permits(),
        }
    }
}

#[derive(Debug)]
pub struct CapturePerformanceStats {
    pub total_captures: u64,
    pub average_capture_time_ms: u64,
    pub current_rate_limit: usize,
}
```

### 3. Input Automation Service

```rust
use std::collections::VecDeque;
use tokio::time::{Duration, Instant};

/// Cross-platform input automation service
pub struct InputAutomationService {
    /// Platform-specific input backend
    input_backend: Box<dyn InputBackend + Send + Sync>,
    
    /// Action queue for batched operations
    action_queue: Arc<Mutex<VecDeque<QueuedAction>>>,
    
    /// Input timing configuration
    timing_config: Arc<RwLock<InputTimingConfig>>,
    
    /// Safety constraints
    safety_constraints: Arc<InputSafetyConstraints>,
    
    /// Action history for debugging
    action_history: Arc<RwLock<ActionHistory>>,
}

/// Platform-agnostic input control trait
#[async_trait]
pub trait InputBackend {
    /// Move cursor to specific coordinates
    async fn move_cursor(&self, x: i32, y: i32) -> Result<(), InputError>;
    
    /// Perform mouse click
    async fn mouse_click(&self, button: MouseButton, click_count: u32) -> Result<(), InputError>;
    
    /// Perform mouse press (without release)
    async fn mouse_press(&self, button: MouseButton) -> Result<(), InputError>;
    
    /// Perform mouse release
    async fn mouse_release(&self, button: MouseButton) -> Result<(), InputError>;
    
    /// Scroll mouse wheel
    async fn mouse_scroll(&self, direction: ScrollDirection, clicks: i32) -> Result<(), InputError>;
    
    /// Type text (handles unicode and special characters)
    async fn type_text(&self, text: &str) -> Result<(), InputError>;
    
    /// Press key combination
    async fn press_keys(&self, keys: &str) -> Result<(), InputError>;
    
    /// Press key down (without release)
    async fn key_down(&self, key: &str) -> Result<(), InputError>;
    
    /// Release key
    async fn key_up(&self, key: &str) -> Result<(), InputError>;
    
    /// Get current cursor position
    async fn get_cursor_position(&self) -> Result<[i32; 2], InputError>;
}

#[derive(Debug, Clone)]
pub struct InputTimingConfig {
    /// Delay between individual keystrokes when typing
    pub keystroke_delay: Duration,
    
    /// Delay between mouse press and release
    pub click_duration: Duration,
    
    /// Delay between mouse movements for smooth motion
    pub mouse_move_delay: Duration,
    
    /// Maximum mouse movement speed (pixels per second)
    pub max_mouse_speed: f64,
    
    /// Human-like timing variations
    pub human_timing: bool,
    
    /// Random variation range for timing
    pub timing_variation_ms: u64,
}

#[derive(Debug)]
pub struct InputSafetyConstraints {
    /// Minimum time between actions to prevent DOS
    pub min_action_interval: Duration,
    
    /// Maximum actions per second
    pub max_actions_per_second: u32,
    
    /// Restricted screen areas (e.g., system UI)
    pub restricted_areas: Vec<ScreenRectangle>,
    
    /// Disallowed key combinations
    pub disallowed_keys: HashSet<String>,
    
    /// Maximum text length for type operations
    pub max_text_length: usize,
}

#[derive(Debug, Clone)]
pub struct QueuedAction {
    pub action: ComputerAction,
    pub queued_at: Instant,
    pub priority: ActionPriority,
    pub session_id: Uuid,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum ActionPriority {
    High = 0,
    Normal = 1,
    Low = 2,
}

impl InputAutomationService {
    /// Perform mouse click with safety checks and timing
    pub async fn perform_click(
        &self,
        coordinate: [i32; 2],
        button: MouseButton,
        click_count: u32,
    ) -> Result<ComputerUseResult, ToolError> {
        // Validate coordinate safety
        self.safety_constraints.validate_coordinate(coordinate)?;
        
        // Apply rate limiting
        self.apply_rate_limiting().await?;
        
        let start_time = Instant::now();
        
        // Move cursor to target position
        let smooth_move = self.timing_config.read().await.human_timing;
        if smooth_move {
            self.smooth_move_cursor(coordinate).await?;
        } else {
            self.input_backend.move_cursor(coordinate[0], coordinate[1]).await
                .map_err(|e| ToolError::ExecutionError(e.to_string()))?;
        }
        
        // Perform the click(s)
        for _ in 0..click_count {
            self.input_backend.mouse_click(button, 1).await
                .map_err(|e| ToolError::ExecutionError(e.to_string()))?;
            
            if click_count > 1 {
                // Add delay between multiple clicks
                let delay = self.timing_config.read().await.click_duration;
                tokio::time::sleep(delay).await;
            }
        }
        
        // Take screenshot after action
        let (screenshot, screen_size) = self.take_post_action_screenshot().await?;
        
        // Get current cursor position
        let cursor_position = self.input_backend.get_cursor_position().await
            .map_err(|e| ToolError::ExecutionError(e.to_string()))?;
        
        let execution_time = start_time.elapsed();
        
        // Record action in history
        self.record_action(&ComputerAction::Click { 
            coordinate, 
            button, 
            click_count: Some(click_count) 
        }, execution_time).await;
        
        Ok(ComputerUseResult {
            action_performed: ComputerAction::Click { coordinate, button, click_count: Some(click_count) },
            screenshot: Some(screenshot),
            screen_size,
            cursor_position,
            success: true,
            error: None,
            performance: ActionPerformanceMetrics {
                execution_time_ms: execution_time.as_millis() as u64,
                screenshot_time_ms: None, // Would be filled by screenshot service
                compression_time_ms: None,
                memory_used: 0, // Would be measured
            },
            security_validation: SecurityValidationResult::Passed,
        })
    }
    
    /// Perform drag operation with smooth motion
    pub async fn perform_drag(
        &self,
        start_coordinate: [i32; 2],
        end_coordinate: [i32; 2],
    ) -> Result<ComputerUseResult, ToolError> {
        // Validate both coordinates
        self.safety_constraints.validate_coordinate(start_coordinate)?;
        self.safety_constraints.validate_coordinate(end_coordinate)?;
        
        self.apply_rate_limiting().await?;
        
        let start_time = Instant::now();
        
        // Move to start position
        self.input_backend.move_cursor(start_coordinate[0], start_coordinate[1]).await
            .map_err(|e| ToolError::ExecutionError(e.to_string()))?;
        
        // Press mouse button
        self.input_backend.mouse_press(MouseButton::Left).await
            .map_err(|e| ToolError::ExecutionError(e.to_string()))?;
        
        // Smooth drag motion
        self.smooth_drag_motion(start_coordinate, end_coordinate).await?;
        
        // Release mouse button
        self.input_backend.mouse_release(MouseButton::Left).await
            .map_err(|e| ToolError::ExecutionError(e.to_string()))?;
        
        let (screenshot, screen_size) = self.take_post_action_screenshot().await?;
        let cursor_position = self.input_backend.get_cursor_position().await
            .map_err(|e| ToolError::ExecutionError(e.to_string()))?;
        
        let execution_time = start_time.elapsed();
        
        self.record_action(&ComputerAction::Drag { 
            coordinate: start_coordinate, 
            end_coordinate 
        }, execution_time).await;
        
        Ok(ComputerUseResult {
            action_performed: ComputerAction::Drag { coordinate: start_coordinate, end_coordinate },
            screenshot: Some(screenshot),
            screen_size,
            cursor_position,
            success: true,
            error: None,
            performance: ActionPerformanceMetrics {
                execution_time_ms: execution_time.as_millis() as u64,
                screenshot_time_ms: None,
                compression_time_ms: None,
                memory_used: 0,
            },
            security_validation: SecurityValidationResult::Passed,
        })
    }
    
    /// Type text with natural timing
    pub async fn perform_type(&self, text: &str) -> Result<ComputerUseResult, ToolError> {
        // Validate text length and content
        if text.len() > self.safety_constraints.max_text_length {
            return Err(ToolError::InvalidArguments(
                format!("Text too long: {} > {}", text.len(), self.safety_constraints.max_text_length)
            ));
        }
        
        self.apply_rate_limiting().await?;
        
        let start_time = Instant::now();
        
        // Type with natural timing
        if self.timing_config.read().await.human_timing {
            self.type_with_human_timing(text).await?;
        } else {
            self.input_backend.type_text(text).await
                .map_err(|e| ToolError::ExecutionError(e.to_string()))?;
        }
        
        let (screenshot, screen_size) = self.take_post_action_screenshot().await?;
        let cursor_position = self.input_backend.get_cursor_position().await
            .map_err(|e| ToolError::ExecutionError(e.to_string()))?;
        
        let execution_time = start_time.elapsed();
        
        self.record_action(&ComputerAction::Type { 
            text: text.to_string() 
        }, execution_time).await;
        
        Ok(ComputerUseResult {
            action_performed: ComputerAction::Type { text: text.to_string() },
            screenshot: Some(screenshot),
            screen_size,
            cursor_position,
            success: true,
            error: None,
            performance: ActionPerformanceMetrics {
                execution_time_ms: execution_time.as_millis() as u64,
                screenshot_time_ms: None,
                compression_time_ms: None,
                memory_used: 0,
            },
            security_validation: SecurityValidationResult::Passed,
        })
    }
    
    /// Smooth cursor movement with human-like motion
    async fn smooth_move_cursor(&self, target: [i32; 2]) -> Result<(), InputError> {
        let current_pos = self.input_backend.get_cursor_position().await?;
        let config = self.timing_config.read().await;
        
        let distance = ((target[0] - current_pos[0]).pow(2) + (target[1] - current_pos[1]).pow(2)) as f64;
        let distance = distance.sqrt();
        
        if distance < 5.0 {
            // Small distance, move directly
            return self.input_backend.move_cursor(target[0], target[1]).await;
        }
        
        // Calculate number of steps based on speed
        let steps = (distance / config.max_mouse_speed * 1000.0 / config.mouse_move_delay.as_millis() as f64) as u32;
        let steps = steps.max(10).min(100); // Reasonable bounds
        
        for i in 1..=steps {
            let progress = i as f64 / steps as f64;
            
            // Use easing for more natural movement
            let eased_progress = self.ease_in_out_cubic(progress);
            
            let x = current_pos[0] + ((target[0] - current_pos[0]) as f64 * eased_progress) as i32;
            let y = current_pos[1] + ((target[1] - current_pos[1]) as f64 * eased_progress) as i32;
            
            self.input_backend.move_cursor(x, y).await?;
            
            if i < steps {
                tokio::time::sleep(config.mouse_move_delay).await;
            }
        }
        
        Ok(())
    }
    
    fn ease_in_out_cubic(&self, t: f64) -> f64 {
        if t < 0.5 {
            4.0 * t * t * t
        } else {
            1.0 - (-2.0 * t + 2.0).powf(3.0) / 2.0
        }
    }
}
```

### 4. Security and Permission System

```rust
/// Security enforcer for computer use operations
pub struct ComputerUseSecurityEnforcer {
    /// Permission manager
    permission_manager: Arc<ComputerUsePermissionManager>,
    
    /// Active security policies
    security_policies: Arc<RwLock<Vec<Box<dyn SecurityPolicy + Send + Sync>>>>,
    
    /// Session authentication
    session_auth: Arc<SessionAuthenticationManager>,
    
    /// Action audit logger
    audit_logger: Arc<ComputerUseAuditLogger>,
    
    /// Risk assessment engine
    risk_assessor: Arc<ActionRiskAssessor>,
}

/// Permission levels for computer use operations
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum ComputerUsePermissionLevel {
    /// No computer use permissions
    None = 0,
    
    /// Read-only (screenshots only)
    ReadOnly = 1,
    
    /// Basic interaction (click, type in designated areas)
    BasicInteraction = 2,
    
    /// Advanced interaction (drag, keyboard shortcuts)
    AdvancedInteraction = 3,
    
    /// System control (system shortcuts, window management)
    SystemControl = 4,
    
    /// Full access (all operations)
    FullAccess = 5,
}

/// Security policy trait for validating computer use actions
#[async_trait]
pub trait SecurityPolicy: Send + Sync {
    /// Validate if an action is allowed
    async fn validate_action(&self, action: &ComputerAction, context: &SecurityContext) -> Result<PolicyDecision, SecurityError>;
    
    /// Get policy priority (higher = checked first)
    fn priority(&self) -> u32;
    
    /// Policy name for logging
    fn name(&self) -> &str;
}

#[derive(Debug, Clone)]
pub enum PolicyDecision {
    Allow,
    Deny(String),
    RequireConfirmation(String),
    ModifyAction(ComputerAction),
}

#[derive(Debug, Clone)]
pub struct SecurityContext {
    pub user_id: String,
    pub session_id: Uuid,
    pub permission_level: ComputerUsePermissionLevel,
    pub current_application: Option<String>,
    pub screen_state: ScreenState,
    pub recent_actions: Vec<ComputerAction>,
}

/// Restricted area policy
pub struct RestrictedAreaPolicy {
    restricted_areas: Vec<ScreenRectangle>,
    allow_override: bool,
}

#[async_trait]
impl SecurityPolicy for RestrictedAreaPolicy {
    async fn validate_action(&self, action: &ComputerAction, _context: &SecurityContext) -> Result<PolicyDecision, SecurityError> {
        let coordinates = match action {
            ComputerAction::Click { coordinate, .. } => Some(*coordinate),
            ComputerAction::RightClick { coordinate } => Some(*coordinate),
            ComputerAction::MiddleClick { coordinate } => Some(*coordinate),
            ComputerAction::DoubleClick { coordinate } => Some(*coordinate),
            ComputerAction::Drag { coordinate, .. } => Some(*coordinate),
            ComputerAction::Scroll { coordinate, .. } => Some(*coordinate),
            ComputerAction::Cursor { coordinate } => Some(*coordinate),
            _ => None,
        };
        
        if let Some(coord) = coordinates {
            for area in &self.restricted_areas {
                if self.point_in_rectangle(coord, area) {
                    if self.allow_override {
                        return Ok(PolicyDecision::RequireConfirmation(
                            format!("Action targets restricted area at ({}, {})", coord[0], coord[1])
                        ));
                    } else {
                        return Ok(PolicyDecision::Deny(
                            format!("Action not allowed in restricted area at ({}, {})", coord[0], coord[1])
                        ));
                    }
                }
            }
        }
        
        Ok(PolicyDecision::Allow)
    }
    
    fn priority(&self) -> u32 {
        1000 // High priority
    }
    
    fn name(&self) -> &str {
        "restricted_area"
    }
}

impl RestrictedAreaPolicy {
    fn point_in_rectangle(&self, point: [i32; 2], rect: &ScreenRectangle) -> bool {
        point[0] >= rect.x 
            && point[0] < rect.x + rect.width as i32
            && point[1] >= rect.y
            && point[1] < rect.y + rect.height as i32
    }
}

/// Rate limiting policy
pub struct RateLimitingPolicy {
    max_actions_per_minute: u32,
    action_window: Duration,
    action_counts: Arc<Mutex<HashMap<Uuid, VecDeque<Instant>>>>,
}

#[async_trait]
impl SecurityPolicy for RateLimitingPolicy {
    async fn validate_action(&self, _action: &ComputerAction, context: &SecurityContext) -> Result<PolicyDecision, SecurityError> {
        let mut counts = self.action_counts.lock().await;
        let session_actions = counts.entry(context.session_id).or_insert_with(VecDeque::new);
        
        let now = Instant::now();
        let window_start = now - self.action_window;
        
        // Remove old actions outside the window
        while let Some(&front_time) = session_actions.front() {
            if front_time >= window_start {
                break;
            }
            session_actions.pop_front();
        }
        
        // Check if we're at the rate limit
        if session_actions.len() >= self.max_actions_per_minute as usize {
            return Ok(PolicyDecision::Deny(
                format!("Rate limit exceeded: {} actions per minute", self.max_actions_per_minute)
            ));
        }
        
        // Add current action
        session_actions.push_back(now);
        
        Ok(PolicyDecision::Allow)
    }
    
    fn priority(&self) -> u32 {
        900 // High priority
    }
    
    fn name(&self) -> &str {
        "rate_limiting"
    }
}

/// Permission level policy
pub struct PermissionLevelPolicy;

#[async_trait]
impl SecurityPolicy for PermissionLevelPolicy {
    async fn validate_action(&self, action: &ComputerAction, context: &SecurityContext) -> Result<PolicyDecision, SecurityError> {
        let required_level = match action {
            ComputerAction::Screenshot { .. } => ComputerUsePermissionLevel::ReadOnly,
            ComputerAction::Click { .. } | ComputerAction::RightClick { .. } | 
            ComputerAction::MiddleClick { .. } | ComputerAction::DoubleClick { .. } => {
                ComputerUsePermissionLevel::BasicInteraction
            }
            ComputerAction::Type { .. } => ComputerUsePermissionLevel::BasicInteraction,
            ComputerAction::Drag { .. } => ComputerUsePermissionLevel::AdvancedInteraction,
            ComputerAction::Key { key } => {
                if self.is_system_key(key) {
                    ComputerUsePermissionLevel::SystemControl
                } else {
                    ComputerUsePermissionLevel::BasicInteraction
                }
            }
            ComputerAction::Scroll { .. } => ComputerUsePermissionLevel::BasicInteraction,
            ComputerAction::Cursor { .. } => ComputerUsePermissionLevel::BasicInteraction,
        };
        
        if context.permission_level >= required_level {
            Ok(PolicyDecision::Allow)
        } else {
            Ok(PolicyDecision::Deny(format!(
                "Insufficient permissions: requires {:?}, has {:?}",
                required_level, context.permission_level
            )))
        }
    }
    
    fn priority(&self) -> u32 {
        800 // High priority
    }
    
    fn name(&self) -> &str {
        "permission_level"
    }
}

impl PermissionLevelPolicy {
    fn is_system_key(&self, key: &str) -> bool {
        // System-level keys that require higher permissions
        matches!(key.to_lowercase().as_str(),
            "alt+f4" | "ctrl+alt+del" | "cmd+q" | "alt+tab" | "cmd+tab" |
            "win" | "cmd" | "ctrl+shift+esc" | "f1" | "f2" | "f3" | "f4" |
            "f5" | "f6" | "f7" | "f8" | "f9" | "f10" | "f11" | "f12"
        )
    }
}
```

### 5. Session Management and Performance Monitoring

```rust
/// Session manager for tracking computer use operations
pub struct ComputerUseSessionManager {
    /// Active sessions
    active_sessions: Arc<RwLock<HashMap<Uuid, ComputerUseSession>>>,
    
    /// Action history storage
    action_storage: Arc<dyn ActionStorage + Send + Sync>,
    
    /// Session configuration
    session_config: Arc<RwLock<SessionConfiguration>>,
    
    /// Performance metrics collector
    metrics_collector: Arc<SessionMetricsCollector>,
}

#[derive(Debug, Clone)]
pub struct ComputerUseSession {
    pub id: Uuid,
    pub user_id: String,
    pub started_at: DateTime<Utc>,
    pub last_activity: DateTime<Utc>,
    pub permission_level: ComputerUsePermissionLevel,
    pub actions_performed: u32,
    pub screenshots_taken: u32,
    pub total_execution_time: Duration,
    pub current_screen_state: Option<ScreenState>,
    pub security_incidents: Vec<SecurityIncident>,
}

#[derive(Debug, Clone)]
pub struct ScreenState {
    pub active_window: Option<WindowInfo>,
    pub screen_resolution: ScreenSize,
    pub cursor_position: [i32; 2],
    pub keyboard_layout: String,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone)]
pub struct WindowInfo {
    pub title: String,
    pub process_name: String,
    pub bounds: ScreenRectangle,
    pub is_focused: bool,
    pub window_id: u64,
}

#[async_trait]
pub trait ActionStorage: Send + Sync {
    async fn store_action(&self, session_id: Uuid, action: &StoredAction) -> Result<(), StorageError>;
    async fn get_session_actions(&self, session_id: Uuid) -> Result<Vec<StoredAction>, StorageError>;
    async fn get_actions_in_timeframe(&self, start: DateTime<Utc>, end: DateTime<Utc>) -> Result<Vec<StoredAction>, StorageError>;
    async fn cleanup_old_actions(&self, older_than: DateTime<Utc>) -> Result<u64, StorageError>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StoredAction {
    pub id: Uuid,
    pub session_id: Uuid,
    pub action: ComputerAction,
    pub result: ActionResult,
    pub timestamp: DateTime<Utc>,
    pub execution_time: Duration,
    pub screen_state_before: Option<ScreenState>,
    pub screen_state_after: Option<ScreenState>,
    pub security_validation: SecurityValidationResult,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ActionResult {
    Success(ComputerUseResult),
    Failure(String),
    SecurityDenied(String),
    UserCancelled,
}

impl ComputerUseSessionManager {
    /// Start tracking an action
    pub async fn start_action(&self, action: &ComputerAction) -> Uuid {
        let action_id = Uuid::new_v4();
        
        // Update session activity
        if let Some(session_id) = self.get_current_session_id().await {
            let mut sessions = self.active_sessions.write().await;
            if let Some(session) = sessions.get_mut(&session_id) {
                session.last_activity = Utc::now();
                session.actions_performed += 1;
                
                if matches!(action, ComputerAction::Screenshot { .. }) {
                    session.screenshots_taken += 1;
                }
            }
        }
        
        action_id
    }
    
    /// End action tracking and store results
    pub async fn end_action(&self, action_id: Uuid, result: &Result<ComputerUseResult, ToolError>) {
        let session_id = self.get_current_session_id().await.unwrap_or(Uuid::new_v4());
        
        let stored_action = StoredAction {
            id: action_id,
            session_id,
            action: ComputerAction::Screenshot { display_num: None, rectangle: None }, // Would be actual action
            result: match result {
                Ok(computer_result) => ActionResult::Success(computer_result.clone()),
                Err(e) => ActionResult::Failure(e.to_string()),
            },
            timestamp: Utc::now(),
            execution_time: Duration::from_millis(0), // Would be actual time
            screen_state_before: None,
            screen_state_after: None,
            security_validation: SecurityValidationResult::Passed,
        };
        
        if let Err(e) = self.action_storage.store_action(session_id, &stored_action).await {
            eprintln!("Failed to store action: {}", e);
        }
    }
    
    /// Get session performance metrics
    pub async fn get_session_metrics(&self, session_id: Uuid) -> Option<SessionPerformanceMetrics> {
        let sessions = self.active_sessions.read().await;
        let session = sessions.get(&session_id)?;
        
        Some(SessionPerformanceMetrics {
            session_duration: Utc::now().signed_duration_since(session.started_at).to_std().ok()?,
            actions_performed: session.actions_performed,
            screenshots_taken: session.screenshots_taken,
            average_action_time: if session.actions_performed > 0 {
                session.total_execution_time / session.actions_performed
            } else {
                Duration::from_millis(0)
            },
            security_incidents: session.security_incidents.len() as u32,
        })
    }
    
    async fn get_current_session_id(&self) -> Option<Uuid> {
        // Implementation would track current session
        None
    }
}

#[derive(Debug)]
pub struct SessionPerformanceMetrics {
    pub session_duration: Duration,
    pub actions_performed: u32,
    pub screenshots_taken: u32,
    pub average_action_time: Duration,
    pub security_incidents: u32,
}

/// Performance monitor for computer use operations
pub struct ComputerUsePerformanceMonitor {
    /// Performance metrics storage
    metrics_storage: Arc<RwLock<PerformanceMetricsStorage>>,
    
    /// Real-time performance tracking
    real_time_tracker: Arc<RealTimePerformanceTracker>,
    
    /// Performance alerting system
    alerting_system: Arc<PerformanceAlertingSystem>,
}

#[derive(Debug, Default)]
pub struct PerformanceMetricsStorage {
    pub action_metrics: HashMap<String, ActionTypeMetrics>,
    pub session_metrics: HashMap<Uuid, SessionMetrics>,
    pub system_metrics: SystemPerformanceMetrics,
}

#[derive(Debug, Default)]
pub struct ActionTypeMetrics {
    pub total_executions: u64,
    pub successful_executions: u64,
    pub failed_executions: u64,
    pub total_execution_time: Duration,
    pub min_execution_time: Duration,
    pub max_execution_time: Duration,
    pub average_execution_time: Duration,
}

#[derive(Debug, Default)]
pub struct SystemPerformanceMetrics {
    pub cpu_usage_during_actions: Vec<f64>,
    pub memory_usage_during_actions: Vec<u64>,
    pub screenshot_compression_ratios: Vec<f64>,
    pub network_usage: u64,
}

impl ComputerUsePerformanceMonitor {
    /// Record performance metrics for an action
    pub async fn record_action_performance(&self, action: &ComputerAction, execution_time: Duration) {
        let action_type = self.get_action_type_name(action);
        let mut storage = self.metrics_storage.write().await;
        
        let metrics = storage.action_metrics.entry(action_type).or_default();
        metrics.total_executions += 1;
        metrics.successful_executions += 1; // Assuming success for this call
        metrics.total_execution_time += execution_time;
        
        if metrics.min_execution_time == Duration::from_millis(0) || execution_time < metrics.min_execution_time {
            metrics.min_execution_time = execution_time;
        }
        if execution_time > metrics.max_execution_time {
            metrics.max_execution_time = execution_time;
        }
        
        metrics.average_execution_time = metrics.total_execution_time / metrics.total_executions as u32;
        
        // Check for performance alerts
        self.alerting_system.check_performance_thresholds(&metrics).await;
    }
    
    fn get_action_type_name(&self, action: &ComputerAction) -> String {
        match action {
            ComputerAction::Screenshot { .. } => "screenshot".to_string(),
            ComputerAction::Click { .. } => "click".to_string(),
            ComputerAction::RightClick { .. } => "right_click".to_string(),
            ComputerAction::MiddleClick { .. } => "middle_click".to_string(),
            ComputerAction::DoubleClick { .. } => "double_click".to_string(),
            ComputerAction::Drag { .. } => "drag".to_string(),
            ComputerAction::Type { .. } => "type".to_string(),
            ComputerAction::Key { .. } => "key".to_string(),
            ComputerAction::Scroll { .. } => "scroll".to_string(),
            ComputerAction::Cursor { .. } => "cursor".to_string(),
        }
    }
}

#[derive(Debug, Clone)]
pub enum SecurityValidationResult {
    Passed,
    Failed(String),
    Warning(String),
}

#[derive(Debug, Clone)]
pub struct SecurityIncident {
    pub id: Uuid,
    pub incident_type: SecurityIncidentType,
    pub description: String,
    pub timestamp: DateTime<Utc>,
    pub action_attempted: ComputerAction,
    pub severity: SecuritySeverity,
}

#[derive(Debug, Clone)]
pub enum SecurityIncidentType {
    UnauthorizedAccess,
    PolicyViolation,
    RateLimitExceeded,
    RestrictedAreaAccess,
    SuspiciousActivity,
}

#[derive(Debug, Clone, Copy)]
pub enum SecuritySeverity {
    Low,
    Medium,
    High,
    Critical,
}
```

## Architecture Changes

### Current Architecture
```
┌─────────────────┐
│   File Tools    │
├─────────────────┤
│ Read/Write/List │
│ Whitelist Only  │
│ No UI Access    │
└─────────────────┘
```

### Target Architecture
```
┌─────────────────────────────────────────────────────────────┐
│                Computer Use Tool System                      │
├─────────────────────────────────────────────────────────────┤
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────┐│
│ │   Screen    │ │    Input    │ │   Window    │ │Security ││
│ │  Capture    │ │ Automation  │ │ Management  │ │ System  ││
│ └─────────────┘ └─────────────┘ └─────────────┘ └─────────┘│
├─────────────────────────────────────────────────────────────┤
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────┐│
│ │  Session    │ │Performance  │ │    Audit    │ │Permission││
│ │ Management  │ │ Monitoring  │ │   Logging   │ │ Manager ││
│ └─────────────┘ └─────────────┘ └─────────────┘ └─────────┘│
├─────────────────────────────────────────────────────────────┤
│           Cross-Platform Backend Implementations             │
│  Windows (Win32) │ macOS (Quartz) │ Linux (X11/Wayland)     │
└─────────────────────────────────────────────────────────────┘
```

## Implementation Plan

### Phase 1: Core Infrastructure (Week 1-2)
1. Implement `ComputerUseTool` structure and Anthropic API compliance
2. Create platform-agnostic trait definitions for screen capture and input
3. Build basic security framework with permission levels
4. Set up session management and basic performance monitoring

### Phase 2: Screen Capture System (Week 2-3)
1. Implement cross-platform screen capture backends
2. Create image processing pipeline with compression
3. Add multi-monitor support and coordinate system management
4. Build performance optimization for high-frequency captures

### Phase 3: Input Automation System (Week 3-4)
1. Implement cross-platform input automation backends
2. Create smooth motion algorithms for natural interaction
3. Add keyboard input with support for complex key combinations
4. Build timing systems for human-like interaction patterns

### Phase 4: Security and Safety Systems (Week 4-5)
1. Implement comprehensive security policy framework
2. Create restricted area detection and validation
3. Build rate limiting and abuse prevention systems
4. Add user consent and confirmation mechanisms

### Phase 5: Advanced Features (Week 5-6)
1. Implement window management and application detection
2. Create performance monitoring and optimization
3. Build audit logging and compliance features
4. Add configuration management for different security levels

### Phase 6: Integration and Testing (Week 6-7)
1. Integrate with existing parallel execution system
2. Create comprehensive test suites for all platforms
3. Build security validation and penetration testing
4. Optimize performance and resource usage

## Testing Strategy

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_screenshot_capture() {
        let mock_backend = MockScreenCaptureBackend::new();
        let service = ScreenCaptureService::new(Box::new(mock_backend));
        
        let (screenshot, screen_size) = service.take_screenshot(None, None).await.unwrap();
        
        assert!(!screenshot.is_empty());
        assert!(screen_size.width > 0);
        assert!(screen_size.height > 0);
    }
    
    #[tokio::test]
    async fn test_security_policy_validation() {
        let policy = RestrictedAreaPolicy {
            restricted_areas: vec![
                ScreenRectangle { x: 0, y: 0, width: 100, height: 50 }
            ],
            allow_override: false,
        };
        
        let context = SecurityContext {
            user_id: "test_user".to_string(),
            session_id: Uuid::new_v4(),
            permission_level: ComputerUsePermissionLevel::BasicInteraction,
            current_application: None,
            screen_state: ScreenState {
                active_window: None,
                screen_resolution: ScreenSize { width: 1920, height: 1080, scale_factor: 1.0 },
                cursor_position: [50, 25],
                keyboard_layout: "US".to_string(),
                timestamp: Utc::now(),
            },
            recent_actions: vec![],
        };
        
        let action = ComputerAction::Click {
            coordinate: [50, 25], // In restricted area
            button: MouseButton::Left,
            click_count: Some(1),
        };
        
        let result = policy.validate_action(&action, &context).await.unwrap();
        assert!(matches!(result, PolicyDecision::Deny(_)));
    }
    
    #[tokio::test]
    async fn test_input_automation_smooth_movement() {
        let mock_backend = MockInputBackend::new();
        let service = InputAutomationService::new(Box::new(mock_backend));
        
        let result = service.perform_click([500, 300], MouseButton::Left, 1).await.unwrap();
        
        assert!(result.success);
        assert_eq!(result.cursor_position, [500, 300]);
    }
    
    #[tokio::test]
    async fn test_rate_limiting() {
        let policy = RateLimitingPolicy {
            max_actions_per_minute: 2,
            action_window: Duration::from_secs(60),
            action_counts: Arc::new(Mutex::new(HashMap::new())),
        };
        
        let context = create_test_security_context();
        let action = ComputerAction::Click {
            coordinate: [100, 100],
            button: MouseButton::Left,
            click_count: Some(1),
        };
        
        // First action should be allowed
        let result1 = policy.validate_action(&action, &context).await.unwrap();
        assert!(matches!(result1, PolicyDecision::Allow));
        
        // Second action should be allowed
        let result2 = policy.validate_action(&action, &context).await.unwrap();
        assert!(matches!(result2, PolicyDecision::Allow));
        
        // Third action should be denied (rate limit exceeded)
        let result3 = policy.validate_action(&action, &context).await.unwrap();
        assert!(matches!(result3, PolicyDecision::Deny(_)));
    }
}
```

### Integration Tests

```rust
#[tokio::test]
async fn test_full_computer_use_workflow() {
    let computer_tool = create_test_computer_tool().await;
    
    // Take screenshot
    let screenshot_action = serde_json::json!({
        "action": "screenshot"
    });
    
    let screenshot_result = computer_tool.execute(screenshot_action).await.unwrap();
    assert!(matches!(screenshot_result, ToolResult::ComputerUse(_)));
    
    // Perform click
    let click_action = serde_json::json!({
        "action": "click",
        "coordinate": [100, 100]
    });
    
    let click_result = computer_tool.execute(click_action).await.unwrap();
    if let ToolResult::ComputerUse(result) = click_result {
        assert!(result.success);
        assert!(result.screenshot.is_some());
    }
}

#[tokio::test]
async fn test_security_integration() {
    let computer_tool = create_restricted_computer_tool().await;
    
    // Try to click in restricted area
    let restricted_click = serde_json::json!({
        "action": "click",
        "coordinate": [50, 25] // Restricted area
    });
    
    let result = computer_tool.execute(restricted_click).await;
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("restricted"));
}

#[tokio::test]
async fn test_performance_monitoring() {
    let computer_tool = create_test_computer_tool().await;
    let start_time = Instant::now();
    
    // Perform multiple actions
    for i in 0..10 {
        let action = serde_json::json!({
            "action": "click",
            "coordinate": [100 + i * 10, 100]
        });
        
        computer_tool.execute(action).await.unwrap();
    }
    
    let total_time = start_time.elapsed();
    
    // Should complete within reasonable time
    assert!(total_time < Duration::from_secs(5));
    
    // Check performance metrics
    let metrics = computer_tool.get_performance_stats().await;
    assert_eq!(metrics.total_actions, 10);
}
```

### Security Tests

```rust
#[tokio::test]
async fn test_privilege_escalation_prevention() {
    let computer_tool = create_limited_permission_tool().await;
    
    // Try to execute system-level key combination
    let system_key = serde_json::json!({
        "action": "key",
        "key": "ctrl+alt+del"
    });
    
    let result = computer_tool.execute(system_key).await;
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("permission"));
}

#[tokio::test]
async fn test_session_isolation() {
    let session1_tool = create_computer_tool_for_session("session1").await;
    let session2_tool = create_computer_tool_for_session("session2").await;
    
    // Actions in session1 should not affect session2's rate limits
    for _ in 0..10 {
        let action = serde_json::json!({"action": "screenshot"});
        session1_tool.execute(action).await.unwrap();
    }
    
    // Session2 should still be able to perform actions
    let action = serde_json::json!({"action": "screenshot"});
    let result = session2_tool.execute(action).await;
    assert!(result.is_ok());
}
```

## Dependencies & Integration

### Phase 2 Dependencies
- **Issue 2.1**: Parallel Tool Execution System
  - Required for concurrent computer use operations
  - Provides resource management for screen capture and input
  
- **Issue 2.2**: Tool Chaining and Orchestration
  - Required for complex computer use workflows
  - Enables sequencing of screen capture → analysis → action
  
- **Issue 2.5**: Comprehensive Configuration System
  - Required for security policy configuration
  - Provides environment-specific computer use settings

### Integration Points
- **Parallel Execution**: Computer use tools integrate with parallel execution engine
- **Security System**: Extends existing whitelist system with computer use permissions
- **Configuration**: Uses TOML configuration for security policies and performance settings
- **Audit Logging**: Integrates with application-wide audit system

### API Extensions
- New `ComputerUseTool` implementing `ParallelAgentTool` trait
- Additional security policies in the security framework
- Extended configuration schema for computer use settings
- New audit logging categories for computer use operations

## Security Considerations

### Desktop Access Control
- Multi-level permission system with explicit user consent
- Restricted area detection to prevent system UI interaction
- Session-based access with automatic timeout
- Real-time monitoring of computer use operations

### Input Validation and Sanitization
- Coordinate validation against screen boundaries
- Text input filtering to prevent injection attacks
- Key combination validation against security policies
- Rate limiting to prevent denial of service

### Privacy and Data Protection
- Screenshot data encryption and secure storage
- Action history with configurable retention policies
- User consent tracking for all computer use operations
- Optional operation recording for audit purposes

### System Security
- Sandboxed execution environment for computer use operations
- Process isolation to prevent privilege escalation
- Secure communication channels for all computer use data
- Regular security validation and vulnerability scanning

## Acceptance Criteria

1. **Anthropic API Compliance**
   - [ ] Full implementation of computer_20250124 tool specification
   - [ ] All action types supported with proper error handling
   - [ ] Screenshot capture in base64 PNG format
   - [ ] Coordinate system management for multi-monitor setups

2. **Cross-Platform Support**
   - [ ] Windows implementation using Win32 APIs
   - [ ] macOS implementation using Quartz/CGDisplay APIs
   - [ ] Linux implementation supporting X11 and Wayland
   - [ ] Consistent behavior across all platforms

3. **Security and Safety**
   - [ ] Multi-level permission system with user consent
   - [ ] Restricted area detection and enforcement
   - [ ] Rate limiting and abuse prevention
   - [ ] Comprehensive audit logging

4. **Performance**
   - [ ] Screenshot capture under 100ms on average
   - [ ] Input actions execute under 50ms
   - [ ] Memory usage under 200MB during operation
   - [ ] Support for 60+ actions per minute

5. **Integration**
   - [ ] Works with parallel execution system
   - [ ] Integrates with existing security framework
   - [ ] Configurable through TOML settings
   - [ ] Compatible with existing tool chaining

6. **User Experience**
   - [ ] Smooth, natural mouse movements
   - [ ] Human-like typing patterns
   - [ ] Real-time visual feedback through screenshots
   - [ ] Clear error messages and validation

## References

- [Anthropic Computer Use Tool - computer_20250124](https://docs.anthropic.com/claude/docs/computer-use)
- [Windows Screen Capture APIs](https://docs.microsoft.com/en-us/windows/win32/gdi/capturing-an-image)
- [macOS Screen Capture - CGDisplay](https://developer.apple.com/documentation/coregraphics/cgdisplay)
- [Linux X11 Screen Capture](https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html)
- [Tauri Desktop Security](https://tauri.app/v1/guides/building/app-security)
- [Cross-Platform Input Automation](https://docs.rs/enigo/latest/enigo/)

## Estimated Lines of Code

- Core computer use tool implementation: ~500 lines
- Screen capture service and backends: ~600 lines
- Input automation service and backends: ~700 lines
- Security framework and policies: ~400 lines
- Session management and performance monitoring: ~300 lines
- Platform-specific implementations (3 platforms): ~600 lines
- Integration with existing systems: ~200 lines
- Tests and validation: ~200 lines

**Total: ~3,500 lines**

*Note: This is a large implementation that transforms the agent from a file-focused tool to a comprehensive desktop automation system. The implementation requires careful attention to security, cross-platform compatibility, and performance optimization.*

## Conclusion

The Computer Use Tool Implementation represents a significant milestone in transforming this desktop agent from a file-focused assistant to a comprehensive desktop automation system. This implementation provides:

- **Full Anthropic Compliance**: Complete implementation of the computer_20250124 tool specification
- **Enterprise-Grade Security**: Multi-layered security with permissions, policies, and audit logging  
- **Cross-Platform Support**: Native implementations for Windows, macOS, and Linux
- **Performance Optimization**: Efficient screen capture, input automation, and resource management
- **Integration Ready**: Seamless integration with existing parallel execution and configuration systems

This foundation enables advanced capabilities like automated UI testing, accessibility assistance, and complex multi-application workflows while maintaining the security and control expected from a desktop application.

### Next Implementation Steps

1. **Issue 3.2**: Text Editor Tool - Builds on computer use for advanced file editing
2. **Issue 3.3**: Code Execution Tool - Adds Python execution with visual result display  
3. **Issue 3.4**: Performance Optimization - Optimizes the computer use system for production
4. **Issue 3.5**: Context Management - Integrates computer use with long-term memory systems

The computer use implementation provides the essential foundation for these advanced capabilities while ensuring security, performance, and maintainability.