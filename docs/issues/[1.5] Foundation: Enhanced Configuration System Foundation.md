# [1.5] Foundation: Enhanced Configuration System Foundation

## Overview

This issue implements a comprehensive, security-first configuration system using TOML format with environment variable overrides, runtime validation, and secure API key management. This foundation will support all application settings, model configuration, streaming preferences, and security policies.

### Current State
- Basic configuration via `ClaudeConfig` struct
- API key handling through environment variables only
- Limited configuration validation
- No persistent configuration storage
- Hard-coded model and parameter settings

### Target State
- TOML-based configuration with hierarchical structure
- Environment variable overrides for all settings
- Secure API key storage with encryption at rest
- Runtime configuration validation and hot-reload
- Model-specific configuration with Claude 4 defaults
- Security policies and access control configuration
- Integration with streaming and error handling systems

## Technical Requirements

### 1. Configuration Schema and Types

```rust
// src-tauri/src/config/mod.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct AppConfig {
    pub api: ApiConfig,
    pub models: ModelsConfig,
    pub streaming: StreamingConfig,
    pub security: SecurityConfig,
    pub ui: UiConfig,
    pub tools: ToolsConfig,
    pub logging: LoggingConfig,
    pub storage: StorageConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ApiConfig {
    /// Claude API key (can be overridden by CLAUDE_API_KEY env var)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub api_key: Option<String>,
    
    /// API base URL
    #[serde(default = "default_api_base_url")]
    pub base_url: String,
    
    /// Request timeout in seconds
    #[serde(default = "default_timeout")]
    pub timeout_seconds: u64,
    
    /// Maximum retries for failed requests
    #[serde(default = "default_max_retries")]
    pub max_retries: u32,
    
    /// Retry backoff multiplier
    #[serde(default = "default_backoff_multiplier")]
    pub backoff_multiplier: f64,
    
    /// Custom headers for API requests
    #[serde(default)]
    pub custom_headers: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ModelsConfig {
    /// Default model for conversations
    #[serde(default = "default_model")]
    pub default_model: String,
    
    /// Model-specific configurations
    #[serde(default)]
    pub model_configs: HashMap<String, ModelConfig>,
    
    /// Available models list
    #[serde(default = "default_available_models")]
    pub available_models: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ModelConfig {
    /// Maximum tokens for this model
    pub max_tokens: Option<u32>,
    
    /// Temperature setting (0.0 - 1.0)
    #[serde(default)]
    pub temperature: Option<f32>,
    
    /// Top-p setting (0.0 - 1.0)
    #[serde(default)]
    pub top_p: Option<f32>,
    
    /// Top-k setting
    #[serde(default)]
    pub top_k: Option<u32>,
    
    /// Stop sequences
    #[serde(default)]
    pub stop_sequences: Vec<String>,
    
    /// Model-specific system prompt
    #[serde(default)]
    pub system_prompt: Option<String>,
    
    /// Tool execution settings
    #[serde(default)]
    pub tools: ToolExecutionConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct StreamingConfig {
    /// Enable streaming by default
    #[serde(default = "default_streaming_enabled")]
    pub enabled: bool,
    
    /// Buffer size for streaming events
    #[serde(default = "default_stream_buffer_size")]
    pub buffer_size: usize,
    
    /// Streaming timeout in seconds
    #[serde(default = "default_stream_timeout")]
    pub timeout_seconds: u64,
    
    /// Maximum concurrent streams
    #[serde(default = "default_max_concurrent_streams")]
    pub max_concurrent_streams: u32,
    
    /// Throttle delay between events (ms)
    #[serde(default)]
    pub throttle_delay_ms: Option<u64>,
    
    /// Enable progress reporting for tools
    #[serde(default = "default_tool_progress")]
    pub tool_progress_enabled: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct SecurityConfig {
    /// Whitelist configuration
    pub whitelist: WhitelistConfig,
    
    /// API key encryption settings
    pub encryption: EncryptionConfig,
    
    /// Access control settings
    pub access_control: AccessControlConfig,
    
    /// Content security policy
    pub content_security: ContentSecurityConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct UiConfig {
    /// Theme preference
    #[serde(default = "default_theme")]
    pub theme: String,
    
    /// Font family
    #[serde(default = "default_font_family")]
    pub font_family: String,
    
    /// Font size
    #[serde(default = "default_font_size")]
    pub font_size: u32,
    
    /// Enable syntax highlighting
    #[serde(default = "default_syntax_highlighting")]
    pub syntax_highlighting: bool,
    
    /// Auto-scroll behavior
    #[serde(default = "default_auto_scroll")]
    pub auto_scroll: bool,
    
    /// Message history limit
    #[serde(default = "default_message_history_limit")]
    pub message_history_limit: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ToolsConfig {
    /// Global tool execution settings
    pub execution: ToolExecutionConfig,
    
    /// Tool-specific configurations
    #[serde(default)]
    pub tool_configs: HashMap<String, ToolSpecificConfig>,
    
    /// Disabled tools list
    #[serde(default)]
    pub disabled_tools: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ToolExecutionConfig {
    /// Timeout for tool execution (seconds)
    #[serde(default = "default_tool_timeout")]
    pub timeout_seconds: u64,
    
    /// Maximum concurrent tool executions
    #[serde(default = "default_max_concurrent_tools")]
    pub max_concurrent: u32,
    
    /// Enable tool result caching
    #[serde(default = "default_tool_caching")]
    pub enable_caching: bool,
    
    /// Cache TTL in seconds
    #[serde(default = "default_cache_ttl")]
    pub cache_ttl_seconds: u64,
}

// Default value functions
fn default_api_base_url() -> String {
    "https://api.anthropic.com".to_string()
}

fn default_timeout() -> u64 {
    120
}

fn default_model() -> String {
    "claude-4-sonnet-20250522".to_string()
}

fn default_available_models() -> Vec<String> {
    vec![
        "claude-4-sonnet-20250522".to_string(),
        "claude-4-haiku-20250522".to_string(),
        "claude-3-5-sonnet-20241022".to_string(),
        "claude-3-5-haiku-20241022".to_string(),
    ]
}

fn default_streaming_enabled() -> bool {
    true
}

fn default_theme() -> String {
    "system".to_string()
}
```

### 2. Configuration Loading and Management

```rust
// src-tauri/src/config/loader.rs
use super::*;
use anyhow::{Result, Context};
use std::env;
use std::path::Path;
use tokio::fs;

pub struct ConfigLoader {
    config_dir: PathBuf,
    config_file: PathBuf,
    backup_file: PathBuf,
}

impl ConfigLoader {
    pub fn new() -> Result<Self> {
        let config_dir = Self::get_config_directory()?;
        let config_file = config_dir.join("agent.toml");
        let backup_file = config_dir.join("agent.backup.toml");
        
        Ok(Self {
            config_dir,
            config_file,
            backup_file,
        })
    }
    
    pub async fn load_config(&self) -> Result<AppConfig> {
        // Create config directory if it doesn't exist
        if !self.config_dir.exists() {
            fs::create_dir_all(&self.config_dir).await
                .context("Failed to create config directory")?;
        }
        
        let config = if self.config_file.exists() {
            // Load existing config
            let content = fs::read_to_string(&self.config_file).await
                .context("Failed to read config file")?;
            
            let mut config: AppConfig = toml::from_str(&content)
                .context("Failed to parse config file")?;
            
            // Apply environment variable overrides
            self.apply_env_overrides(&mut config)?;
            
            // Validate configuration
            self.validate_config(&config).await?;
            
            config
        } else {
            // Create default config
            let mut config = Self::create_default_config();
            self.apply_env_overrides(&mut config)?;
            
            // Save default config
            self.save_config(&config).await?;
            
            config
        };
        
        Ok(config)
    }
    
    pub async fn save_config(&self, config: &AppConfig) -> Result<()> {
        // Create backup before saving
        if self.config_file.exists() {
            fs::copy(&self.config_file, &self.backup_file).await
                .context("Failed to create config backup")?;
        }
        
        // Sanitize config for saving (remove sensitive data)
        let mut safe_config = config.clone();
        safe_config.api.api_key = None; // Never save API key to file
        
        let content = toml::to_string_pretty(&safe_config)
            .context("Failed to serialize config")?;
        
        fs::write(&self.config_file, content).await
            .context("Failed to write config file")?;
        
        Ok(())
    }
    
    fn create_default_config() -> AppConfig {
        AppConfig {
            api: ApiConfig {
                api_key: None,
                base_url: default_api_base_url(),
                timeout_seconds: default_timeout(),
                max_retries: default_max_retries(),
                backoff_multiplier: default_backoff_multiplier(),
                custom_headers: HashMap::new(),
            },
            models: ModelsConfig {
                default_model: default_model(),
                model_configs: Self::create_default_model_configs(),
                available_models: default_available_models(),
            },
            streaming: StreamingConfig {
                enabled: default_streaming_enabled(),
                buffer_size: default_stream_buffer_size(),
                timeout_seconds: default_stream_timeout(),
                max_concurrent_streams: default_max_concurrent_streams(),
                throttle_delay_ms: None,
                tool_progress_enabled: default_tool_progress(),
            },
            security: SecurityConfig {
                whitelist: WhitelistConfig::default(),
                encryption: EncryptionConfig::default(),
                access_control: AccessControlConfig::default(),
                content_security: ContentSecurityConfig::default(),
            },
            ui: UiConfig {
                theme: default_theme(),
                font_family: default_font_family(),
                font_size: default_font_size(),
                syntax_highlighting: default_syntax_highlighting(),
                auto_scroll: default_auto_scroll(),
                message_history_limit: default_message_history_limit(),
            },
            tools: ToolsConfig {
                execution: ToolExecutionConfig {
                    timeout_seconds: default_tool_timeout(),
                    max_concurrent: default_max_concurrent_tools(),
                    enable_caching: default_tool_caching(),
                    cache_ttl_seconds: default_cache_ttl(),
                },
                tool_configs: HashMap::new(),
                disabled_tools: Vec::new(),
            },
            logging: LoggingConfig::default(),
            storage: StorageConfig::default(),
        }
    }
    
    fn create_default_model_configs() -> HashMap<String, ModelConfig> {
        let mut configs = HashMap::new();
        
        // Claude 4 Sonnet configuration
        configs.insert("claude-4-sonnet-20250522".to_string(), ModelConfig {
            max_tokens: Some(8192),
            temperature: Some(0.7),
            top_p: Some(0.9),
            top_k: None,
            stop_sequences: Vec::new(),
            system_prompt: None,
            tools: ToolExecutionConfig {
                timeout_seconds: 300,
                max_concurrent: 5,
                enable_caching: true,
                cache_ttl_seconds: 3600,
            },
        });
        
        // Claude 4 Haiku configuration
        configs.insert("claude-4-haiku-20250522".to_string(), ModelConfig {
            max_tokens: Some(4096),
            temperature: Some(0.5),
            top_p: Some(0.9),
            top_k: None,
            stop_sequences: Vec::new(),
            system_prompt: None,
            tools: ToolExecutionConfig {
                timeout_seconds: 120,
                max_concurrent: 3,
                enable_caching: true,
                cache_ttl_seconds: 1800,
            },
        });
        
        configs
    }
    
    fn apply_env_overrides(&self, config: &mut AppConfig) -> Result<()> {
        // API Configuration
        if let Ok(api_key) = env::var("CLAUDE_API_KEY") {
            config.api.api_key = Some(api_key);
        }
        
        if let Ok(base_url) = env::var("CLAUDE_API_BASE_URL") {
            config.api.base_url = base_url;
        }
        
        if let Ok(timeout) = env::var("CLAUDE_API_TIMEOUT") {
            config.api.timeout_seconds = timeout.parse()
                .context("Invalid CLAUDE_API_TIMEOUT value")?;
        }
        
        // Model Configuration
        if let Ok(model) = env::var("CLAUDE_DEFAULT_MODEL") {
            config.models.default_model = model;
        }
        
        // Streaming Configuration
        if let Ok(enabled) = env::var("CLAUDE_STREAMING_ENABLED") {
            config.streaming.enabled = enabled.parse()
                .context("Invalid CLAUDE_STREAMING_ENABLED value")?;
        }
        
        // Security Configuration
        if let Ok(whitelist_enabled) = env::var("CLAUDE_WHITELIST_ENABLED") {
            config.security.whitelist.enabled = whitelist_enabled.parse()
                .context("Invalid CLAUDE_WHITELIST_ENABLED value")?;
        }
        
        // Tool Configuration
        if let Ok(tool_timeout) = env::var("CLAUDE_TOOL_TIMEOUT") {
            config.tools.execution.timeout_seconds = tool_timeout.parse()
                .context("Invalid CLAUDE_TOOL_TIMEOUT value")?;
        }
        
        Ok(())
    }
    
    async fn validate_config(&self, config: &AppConfig) -> Result<()> {
        // Validate API configuration
        if config.api.api_key.is_none() && env::var("CLAUDE_API_KEY").is_err() {
            return Err(anyhow::anyhow!(
                "No API key provided. Set CLAUDE_API_KEY environment variable or configure api.api_key"
            ));
        }
        
        if config.api.timeout_seconds == 0 || config.api.timeout_seconds > 3600 {
            return Err(anyhow::anyhow!(
                "API timeout must be between 1 and 3600 seconds"
            ));
        }
        
        // Validate model configuration
        if config.models.default_model.is_empty() {
            return Err(anyhow::anyhow!("Default model cannot be empty"));
        }
        
        if !config.models.available_models.contains(&config.models.default_model) {
            return Err(anyhow::anyhow!(
                "Default model '{}' is not in available models list",
                config.models.default_model
            ));
        }
        
        // Validate model-specific configs
        for (model_name, model_config) in &config.models.model_configs {
            if let Some(temp) = model_config.temperature {
                if temp < 0.0 || temp > 1.0 {
                    return Err(anyhow::anyhow!(
                        "Temperature for model '{}' must be between 0.0 and 1.0",
                        model_name
                    ));
                }
            }
            
            if let Some(top_p) = model_config.top_p {
                if top_p < 0.0 || top_p > 1.0 {
                    return Err(anyhow::anyhow!(
                        "Top-p for model '{}' must be between 0.0 and 1.0",
                        model_name
                    ));
                }
            }
        }
        
        // Validate streaming configuration
        if config.streaming.max_concurrent_streams == 0 {
            return Err(anyhow::anyhow!(
                "Maximum concurrent streams must be at least 1"
            ));
        }
        
        // Validate tool configuration
        if config.tools.execution.timeout_seconds == 0 {
            return Err(anyhow::anyhow!(
                "Tool execution timeout must be at least 1 second"
            ));
        }
        
        Ok(())
    }
    
    fn get_config_directory() -> Result<PathBuf> {
        let config_dir = if let Ok(app_data) = env::var("APPDATA") {
            // Windows
            PathBuf::from(app_data).join("Claude Agent")
        } else if let Ok(home) = env::var("HOME") {
            // macOS/Linux
            let config_home = env::var("XDG_CONFIG_HOME")
                .unwrap_or_else(|_| format!("{}/.config", home));
            PathBuf::from(config_home).join("claude-agent")
        } else {
            return Err(anyhow::anyhow!(
                "Unable to determine config directory. Set HOME or APPDATA environment variable"
            ));
        };
        
        Ok(config_dir)
    }
}
```

### 3. Runtime Configuration Management

```rust
// src-tauri/src/config/manager.rs
use super::*;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{Duration, interval};

pub struct ConfigManager {
    config: Arc<RwLock<AppConfig>>,
    loader: ConfigLoader,
    auto_save: bool,
    watch_changes: bool,
}

impl ConfigManager {
    pub async fn new() -> Result<Self> {
        let loader = ConfigLoader::new()?;
        let config = loader.load_config().await?;
        
        Ok(Self {
            config: Arc::new(RwLock::new(config)),
            loader,
            auto_save: true,
            watch_changes: true,
        })
    }
    
    pub async fn get_config(&self) -> AppConfig {
        self.config.read().await.clone()
    }
    
    pub async fn update_config<F>(&self, updater: F) -> Result<()>
    where
        F: FnOnce(&mut AppConfig) -> Result<()>,
    {
        let mut config = self.config.write().await;
        updater(&mut config)?;
        
        // Validate updated configuration
        self.validate_config(&config).await?;
        
        // Auto-save if enabled
        if self.auto_save {
            self.loader.save_config(&config).await?;
        }
        
        Ok(())
    }
    
    pub async fn reload_config(&self) -> Result<()> {
        let new_config = self.loader.load_config().await?;
        let mut config = self.config.write().await;
        *config = new_config;
        Ok(())
    }
    
    pub async fn save_config(&self) -> Result<()> {
        let config = self.config.read().await;
        self.loader.save_config(&config).await
    }
    
    pub async fn get_model_config(&self, model_name: &str) -> Option<ModelConfig> {
        let config = self.config.read().await;
        config.models.model_configs.get(model_name).cloned()
    }
    
    pub async fn update_model_config(
        &self,
        model_name: String,
        model_config: ModelConfig,
    ) -> Result<()> {
        self.update_config(|config| {
            config.models.model_configs.insert(model_name, model_config);
            Ok(())
        }).await
    }
    
    pub async fn get_api_key(&self) -> Option<String> {
        // Check environment variable first
        if let Ok(api_key) = env::var("CLAUDE_API_KEY") {
            return Some(api_key);
        }
        
        // Then check configuration
        let config = self.config.read().await;
        config.api.api_key.clone()
    }
    
    pub async fn set_api_key(&self, api_key: String) -> Result<()> {
        // Note: API key is typically set via environment variable
        // This method is for runtime updates only
        self.update_config(|config| {
            config.api.api_key = Some(api_key);
            Ok(())
        }).await
    }
    
    pub async fn start_auto_save(&self) {
        if !self.auto_save {
            return;
        }
        
        let config = Arc::clone(&self.config);
        let loader = self.loader.clone();
        
        tokio::spawn(async move {
            let mut interval = interval(Duration::from_secs(300)); // Save every 5 minutes
            
            loop {
                interval.tick().await;
                
                let config_snapshot = config.read().await.clone();
                if let Err(e) = loader.save_config(&config_snapshot).await {
                    eprintln!("Auto-save failed: {}", e);
                }
            }
        });
    }
    
    async fn validate_config(&self, config: &AppConfig) -> Result<()> {
        // Delegate to loader's validation logic
        self.loader.validate_config(config).await
    }
}

// Clone implementation for ConfigLoader
impl Clone for ConfigLoader {
    fn clone(&self) -> Self {
        Self {
            config_dir: self.config_dir.clone(),
            config_file: self.config_file.clone(),
            backup_file: self.backup_file.clone(),
        }
    }
}
```

### 4. Secure API Key Storage

```rust
// src-tauri/src/config/encryption.rs
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, NewAead};
use anyhow::{Result, Context};
use rand::{RngCore, thread_rng};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use tokio::fs;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct EncryptionConfig {
    /// Enable API key encryption at rest
    #[serde(default = "default_encryption_enabled")]
    pub enabled: bool,
    
    /// Key derivation iterations
    #[serde(default = "default_key_derivation_iterations")]
    pub key_derivation_iterations: u32,
    
    /// Encryption algorithm identifier
    #[serde(default = "default_encryption_algorithm")]
    pub algorithm: String,
}

impl Default for EncryptionConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            key_derivation_iterations: default_key_derivation_iterations(),
            algorithm: default_encryption_algorithm(),
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct EncryptedData {
    nonce: Vec<u8>,
    ciphertext: Vec<u8>,
    salt: Vec<u8>,
}

pub struct SecureStorage {
    storage_dir: PathBuf,
    master_key: Option<Vec<u8>>,
}

impl SecureStorage {
    pub fn new(storage_dir: PathBuf) -> Self {
        Self {
            storage_dir,
            master_key: None,
        }
    }
    
    pub async fn initialize(&mut self) -> Result<()> {
        if !self.storage_dir.exists() {
            fs::create_dir_all(&self.storage_dir).await
                .context("Failed to create secure storage directory")?;
        }
        
        // Generate or load master key
        self.master_key = Some(self.get_or_create_master_key().await?);
        
        Ok(())
    }
    
    pub async fn store_api_key(&self, api_key: &str) -> Result<()> {
        let master_key = self.master_key.as_ref()
            .ok_or_else(|| anyhow::anyhow!("Secure storage not initialized"))?;
        
        let encrypted = self.encrypt_data(api_key.as_bytes(), master_key)?;
        let serialized = serde_json::to_vec(&encrypted)
            .context("Failed to serialize encrypted data")?;
        
        let key_file = self.storage_dir.join("api_key.enc");
        fs::write(key_file, serialized).await
            .context("Failed to write encrypted API key")?;
        
        Ok(())
    }
    
    pub async fn load_api_key(&self) -> Result<Option<String>> {
        let key_file = self.storage_dir.join("api_key.enc");
        
        if !key_file.exists() {
            return Ok(None);
        }
        
        let master_key = self.master_key.as_ref()
            .ok_or_else(|| anyhow::anyhow!("Secure storage not initialized"))?;
        
        let encrypted_data = fs::read(key_file).await
            .context("Failed to read encrypted API key")?;
        
        let encrypted: EncryptedData = serde_json::from_slice(&encrypted_data)
            .context("Failed to deserialize encrypted data")?;
        
        let decrypted = self.decrypt_data(&encrypted, master_key)?;
        let api_key = String::from_utf8(decrypted)
            .context("Invalid UTF-8 in decrypted API key")?;
        
        Ok(Some(api_key))
    }
    
    pub async fn remove_api_key(&self) -> Result<()> {
        let key_file = self.storage_dir.join("api_key.enc");
        
        if key_file.exists() {
            fs::remove_file(key_file).await
                .context("Failed to remove encrypted API key")?;
        }
        
        Ok(())
    }
    
    async fn get_or_create_master_key(&self) -> Result<Vec<u8>> {
        let key_file = self.storage_dir.join("master.key");
        
        if key_file.exists() {
            let key_data = fs::read(key_file).await
                .context("Failed to read master key")?;
            
            if key_data.len() != 32 {
                return Err(anyhow::anyhow!("Invalid master key length"));
            }
            
            Ok(key_data)
        } else {
            // Generate new master key
            let mut key = vec![0u8; 32];
            thread_rng().fill_bytes(&mut key);
            
            fs::write(key_file, &key).await
                .context("Failed to write master key")?;
            
            Ok(key)
        }
    }
    
    fn encrypt_data(&self, data: &[u8], master_key: &[u8]) -> Result<EncryptedData> {
        // Generate random salt and nonce
        let mut salt = vec![0u8; 16];
        let mut nonce_bytes = vec![0u8; 12];
        thread_rng().fill_bytes(&mut salt);
        thread_rng().fill_bytes(&mut nonce_bytes);
        
        // Derive encryption key from master key + salt
        let key = self.derive_key(master_key, &salt)?;
        let cipher = Aes256Gcm::new(Key::from_slice(&key));
        let nonce = Nonce::from_slice(&nonce_bytes);
        
        let ciphertext = cipher.encrypt(nonce, data)
            .map_err(|e| anyhow::anyhow!("Encryption failed: {}", e))?;
        
        Ok(EncryptedData {
            nonce: nonce_bytes,
            ciphertext,
            salt,
        })
    }
    
    fn decrypt_data(&self, encrypted: &EncryptedData, master_key: &[u8]) -> Result<Vec<u8>> {
        // Derive decryption key
        let key = self.derive_key(master_key, &encrypted.salt)?;
        let cipher = Aes256Gcm::new(Key::from_slice(&key));
        let nonce = Nonce::from_slice(&encrypted.nonce);
        
        let plaintext = cipher.decrypt(nonce, encrypted.ciphertext.as_ref())
            .map_err(|e| anyhow::anyhow!("Decryption failed: {}", e))?;
        
        Ok(plaintext)
    }
    
    fn derive_key(&self, master_key: &[u8], salt: &[u8]) -> Result<Vec<u8>> {
        use pbkdf2::pbkdf2_hmac;
        use sha2::Sha256;
        
        let mut derived_key = vec![0u8; 32];
        pbkdf2_hmac::<Sha256>(master_key, salt, 100_000, &mut derived_key);
        
        Ok(derived_key)
    }
}

fn default_encryption_enabled() -> bool {
    true
}

fn default_key_derivation_iterations() -> u32 {
    100_000
}

fn default_encryption_algorithm() -> String {
    "AES-256-GCM".to_string()
}
```

### 5. Tauri Command Integration

```rust
// src-tauri/src/commands/config.rs
use tauri::State;
use crate::config::{AppConfig, ConfigManager, ModelConfig};

#[tauri::command]
pub async fn get_config(
    config_manager: State<'_, ConfigManager>,
) -> Result<AppConfig, String> {
    config_manager.get_config().await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn update_model_config(
    model_name: String,
    model_config: ModelConfig,
    config_manager: State<'_, ConfigManager>,
) -> Result<(), String> {
    config_manager.update_model_config(model_name, model_config).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_available_models(
    config_manager: State<'_, ConfigManager>,
) -> Result<Vec<String>, String> {
    let config = config_manager.get_config().await;
    Ok(config.models.available_models)
}

#[tauri::command]
pub async fn set_default_model(
    model_name: String,
    config_manager: State<'_, ConfigManager>,
) -> Result<(), String> {
    config_manager.update_config(|config| {
        if !config.models.available_models.contains(&model_name) {
            return Err(anyhow::anyhow!(
                "Model '{}' is not in available models list",
                model_name
            ));
        }
        config.models.default_model = model_name;
        Ok(())
    }).await
    .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn update_streaming_config(
    enabled: Option<bool>,
    buffer_size: Option<usize>,
    timeout_seconds: Option<u64>,
    config_manager: State<'_, ConfigManager>,
) -> Result<(), String> {
    config_manager.update_config(|config| {
        if let Some(enabled) = enabled {
            config.streaming.enabled = enabled;
        }
        if let Some(buffer_size) = buffer_size {
            config.streaming.buffer_size = buffer_size;
        }
        if let Some(timeout) = timeout_seconds {
            config.streaming.timeout_seconds = timeout;
        }
        Ok(())
    }).await
    .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn update_ui_config(
    theme: Option<String>,
    font_family: Option<String>,
    font_size: Option<u32>,
    config_manager: State<'_, ConfigManager>,
) -> Result<(), String> {
    config_manager.update_config(|config| {
        if let Some(theme) = theme {
            config.ui.theme = theme;
        }
        if let Some(font_family) = font_family {
            config.ui.font_family = font_family;
        }
        if let Some(font_size) = font_size {
            config.ui.font_size = font_size;
        }
        Ok(())
    }).await
    .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn export_config(
    config_manager: State<'_, ConfigManager>,
) -> Result<String, String> {
    let config = config_manager.get_config().await;
    toml::to_string_pretty(&config)
        .map_err(|e| format!("Failed to serialize config: {}", e))
}

#[tauri::command]
pub async fn import_config(
    config_toml: String,
    config_manager: State<'_, ConfigManager>,
) -> Result<(), String> {
    let new_config: AppConfig = toml::from_str(&config_toml)
        .map_err(|e| format!("Failed to parse config: {}", e))?;
    
    // Validate before applying
    config_manager.validate_config(&new_config).await
        .map_err(|e| format!("Invalid configuration: {}", e))?;
    
    // Update configuration
    config_manager.update_config(|config| {
        *config = new_config;
        Ok(())
    }).await
    .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn reset_config_to_defaults(
    config_manager: State<'_, ConfigManager>,
) -> Result<(), String> {
    config_manager.reload_config().await
        .map_err(|e| e.to_string())
}
```

### 6. Default Configuration File (agent.toml)

```toml
# Claude Agent Configuration File
# This file contains all application settings and can be customized as needed.
# Environment variables will override values in this file.

[api]
# Claude API configuration
# api_key is read from CLAUDE_API_KEY environment variable for security
base_url = "https://api.anthropic.com"
timeout_seconds = 120
max_retries = 3
backoff_multiplier = 2.0

[models]
# Model configuration
default_model = "claude-4-sonnet-20250522"
available_models = [
    "claude-4-sonnet-20250522",
    "claude-4-haiku-20250522",
    "claude-3-5-sonnet-20241022",
    "claude-3-5-haiku-20241022"
]

# Model-specific settings
[models.model_configs."claude-4-sonnet-20250522"]
max_tokens = 8192
temperature = 0.7
top_p = 0.9
system_prompt = ""

[models.model_configs."claude-4-sonnet-20250522".tools]
timeout_seconds = 300
max_concurrent = 5
enable_caching = true
cache_ttl_seconds = 3600

[models.model_configs."claude-4-haiku-20250522"]
max_tokens = 4096
temperature = 0.5
top_p = 0.9

[models.model_configs."claude-4-haiku-20250522".tools]
timeout_seconds = 120
max_concurrent = 3
enable_caching = true
cache_ttl_seconds = 1800

[streaming]
# Streaming configuration
enabled = true
buffer_size = 8192
timeout_seconds = 60
max_concurrent_streams = 5
tool_progress_enabled = true

[security]
# Security settings
[security.whitelist]
enabled = true
max_depth = 10
max_file_size = 10485760  # 10MB
check_extensions = true
allowed_extensions = [".txt", ".md", ".json", ".toml", ".yaml", ".yml", ".rs", ".js", ".ts", ".py"]

[security.encryption]
enabled = true
key_derivation_iterations = 100000
algorithm = "AES-256-GCM"

[security.access_control]
require_confirmation = false
log_access = true

[security.content_security]
sanitize_html = true
allow_external_links = false

[ui]
# User interface settings
theme = "system"  # "light", "dark", or "system"
font_family = "system-ui, -apple-system, sans-serif"
font_size = 14
syntax_highlighting = true
auto_scroll = true
message_history_limit = 1000

[tools]
# Tool execution settings
[tools.execution]
timeout_seconds = 180
max_concurrent = 3
enable_caching = true
cache_ttl_seconds = 3600

disabled_tools = []

[logging]
# Logging configuration
level = "info"  # "error", "warn", "info", "debug", "trace"
file_logging = false
max_log_files = 5
max_log_size_mb = 10

[storage]
# Storage configuration
auto_save_interval_seconds = 300
backup_count = 5
compression_enabled = false
```

## Architecture Changes

### Current Architecture
```
┌─────────────┐     ┌─────────────┐
│  ClaudeConfig│────▶│  Hard-coded │
│   (Basic)    │     │   Values    │
└─────────────┘     └─────────────┘
       │
       ▼
┌─────────────┐
│ Environment │
│  Variables  │
└─────────────┘
```

### Target Architecture
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│Environment  │────▶│Configuration│────▶│  Validation │
│ Variables   │     │   Manager   │     │  & Security │
└─────────────┘     └─────────────┘     └─────────────┘
       │                    │                    │
       ▼                    ▼                    ▼
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│TOML Config  │────▶│Runtime Hot  │────▶│Secure API   │
│   Files     │     │  Reload     │     │Key Storage  │
└─────────────┘     └─────────────┘     └─────────────┘
```

## Implementation Plan

### Phase 1: Core Configuration System (Week 1)
1. **Configuration Types and Schema**
   - Define comprehensive AppConfig structure
   - Implement all configuration sections
   - Add validation logic and default values

2. **TOML Loading and Serialization**
   - Implement ConfigLoader with TOML support
   - Add environment variable override logic
   - Create configuration directory management

### Phase 2: Runtime Management (Week 1-2)
3. **Configuration Manager**
   - Implement ConfigManager with thread-safe access
   - Add configuration validation and hot-reload
   - Implement auto-save functionality

4. **Secure Storage System**
   - Implement encryption for sensitive data
   - Add secure API key storage
   - Create master key management system

### Phase 3: Integration (Week 2)
5. **Tauri Command Integration**
   - Create configuration management commands
   - Add configuration import/export functionality
   - Implement runtime configuration updates

6. **System Integration**
   - Update existing modules to use new configuration
   - Integrate with streaming system from Issue 1.4
   - Update error handling to use configuration

### Phase 4: Testing & Documentation (Week 2-3)
7. **Testing**
   - Unit tests for all configuration components
   - Integration tests for TOML loading/saving
   - Security tests for encryption system

8. **Documentation & Migration**
   - Update configuration documentation
   - Create migration guide from old system
   - Add configuration examples and best practices

## Testing Strategy

### Unit Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    
    #[tokio::test]
    async fn test_config_loading_and_saving() {
        let temp_dir = TempDir::new().unwrap();
        let config_dir = temp_dir.path().to_path_buf();
        
        let loader = ConfigLoader::new_with_dir(config_dir).unwrap();
        
        // Load default config
        let config = loader.load_config().await.unwrap();
        assert_eq!(config.models.default_model, "claude-4-sonnet-20250522");
        
        // Save and reload
        loader.save_config(&config).await.unwrap();
        let reloaded = loader.load_config().await.unwrap();
        assert_eq!(config, reloaded);
    }
    
    #[tokio::test]
    async fn test_environment_variable_overrides() {
        std::env::set_var("CLAUDE_API_KEY", "test-key");
        std::env::set_var("CLAUDE_DEFAULT_MODEL", "claude-4-haiku-20250522");
        
        let temp_dir = TempDir::new().unwrap();
        let loader = ConfigLoader::new_with_dir(temp_dir.path()).unwrap();
        
        let config = loader.load_config().await.unwrap();
        assert_eq!(config.api.api_key, Some("test-key".to_string()));
        assert_eq!(config.models.default_model, "claude-4-haiku-20250522");
        
        std::env::remove_var("CLAUDE_API_KEY");
        std::env::remove_var("CLAUDE_DEFAULT_MODEL");
    }
    
    #[tokio::test]
    async fn test_configuration_validation() {
        let temp_dir = TempDir::new().unwrap();
        let loader = ConfigLoader::new_with_dir(temp_dir.path()).unwrap();
        
        let mut config = AppConfig::default();
        config.api.timeout_seconds = 0; // Invalid
        
        let result = loader.validate_config(&config).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("timeout"));
    }
    
    #[tokio::test]
    async fn test_secure_storage_encryption() {
        let temp_dir = TempDir::new().unwrap();
        let mut storage = SecureStorage::new(temp_dir.path().to_path_buf());
        storage.initialize().await.unwrap();
        
        let api_key = "sk-test-key-12345";
        storage.store_api_key(api_key).await.unwrap();
        
        let loaded_key = storage.load_api_key().await.unwrap().unwrap();
        assert_eq!(loaded_key, api_key);
    }
}
```

### Integration Tests
```rust
#[cfg(test)]
mod integration_tests {
    #[tokio::test]
    async fn test_full_configuration_lifecycle() {
        // Test complete configuration lifecycle:
        // 1. Create default config
        // 2. Modify settings
        // 3. Save and reload
        // 4. Apply environment overrides
        // 5. Validate all settings work correctly
    }
    
    #[tokio::test]
    async fn test_concurrent_configuration_access() {
        // Test multiple threads accessing configuration
        // Ensure thread safety and consistency
    }
    
    #[tokio::test]
    async fn test_configuration_migration() {
        // Test upgrading from old configuration format
        // Ensure backward compatibility
    }
}
```

## Dependencies & Integration

### Dependencies on Other Issues
1. **Issue 1.2 (Error Handling)**: Use unified error types throughout configuration system
2. **Issue 1.4 (Streaming)**: Configuration for streaming settings and buffer sizes

### Integration Points
1. **Existing Claude Module**: Replace hardcoded configuration with dynamic config
2. **Tool System**: Use configuration for tool timeout and concurrency settings
3. **Security Module**: Integrate with whitelist and access control configuration
4. **UI Components**: Use UI configuration for theming and display preferences

### New Crate Dependencies
```toml
[dependencies]
# Existing dependencies...

# Configuration support
toml = "0.8"
serde = { version = "1.0", features = ["derive"] }

# Encryption
aes-gcm = "0.10"
pbkdf2 = "0.12"
rand = "0.8"

# Async utilities
tokio = { version = "1.0", features = ["fs", "time"] }

# Error handling
anyhow = "1.0"
thiserror = "1.0"

# Validation
validator = { version = "0.16", features = ["derive"] }
```

## Security Considerations

### 1. API Key Protection
- Never store API keys in plain text configuration files
- Use environment variables as primary source
- Encrypt API keys when stored locally
- Implement secure key derivation (PBKDF2)

### 2. Configuration Validation
- Validate all configuration values before use
- Sanitize file paths to prevent directory traversal
- Implement bounds checking for numeric values
- Validate URL formats for API endpoints

### 3. Access Control
- Restrict configuration file permissions (600)
- Implement configuration change logging
- Add optional confirmation for security setting changes
- Validate configuration signatures if needed

### 4. Encryption Security
- Use AES-256-GCM for authenticated encryption
- Generate random nonces for each encryption
- Implement proper key derivation with salt
- Secure deletion of sensitive data in memory

## Acceptance Criteria

### Functional Requirements
- [ ] TOML configuration files load and save correctly
- [ ] Environment variable overrides work for all settings
- [ ] Configuration validation prevents invalid settings
- [ ] Secure API key storage with encryption works
- [ ] Runtime configuration updates apply immediately
- [ ] Configuration backup and restore functionality works
- [ ] Default configuration covers all application needs

### Security Requirements
- [ ] API keys are never stored in plain text files
- [ ] Configuration files have appropriate permissions
- [ ] Encryption uses secure algorithms and practices
- [ ] Configuration changes are logged appropriately

### Performance Requirements
- [ ] Configuration loading completes within 100ms
- [ ] Runtime configuration access has minimal overhead
- [ ] Auto-save doesn't impact application performance
- [ ] Concurrent configuration access is thread-safe

### Quality Requirements
- [ ] All tests pass (unit, integration, security)
- [ ] Configuration schema is well-documented
- [ ] Migration path from existing configuration exists
- [ ] Error messages are clear and actionable

## References

### Configuration Standards
- [TOML Specification](https://toml.io/en/v1.0.0)
- [XDG Base Directory Specification](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html)
- [Windows Application Data Guidelines](https://docs.microsoft.com/en-us/windows/win32/shell/appdata)

### Cryptography References
- [AES-GCM RFC](https://tools.ietf.org/html/rfc5116)
- [PBKDF2 RFC](https://tools.ietf.org/html/rfc2898)
- [Rust Crypto Documentation](https://docs.rs/aes-gcm/)

### Anthropic API References
- [Claude 4 Models](https://docs.anthropic.com/claude/docs/models-overview)
- [API Configuration](https://docs.anthropic.com/claude/reference/getting-started)
- [Model Parameters](https://docs.anthropic.com/claude/reference/messages)

### Related Issues
- Issue 1.2: Unified Error Handling System
- Issue 1.4: Streaming Foundation with Server-Sent Events
- Issue 2.1: Advanced Configuration Management (Phase 2)

## Estimated Lines of Code

### Breakdown by Component
- Configuration types and schema (`config/mod.rs`): ~400 LOC
- Configuration loader (`config/loader.rs`): ~500 LOC
- Configuration manager (`config/manager.rs`): ~300 LOC
- Secure storage system (`config/encryption.rs`): ~350 LOC
- Tauri command integration (`commands/config.rs`): ~200 LOC
- Default configuration file (`agent.toml`): ~150 LOC
- Tests and validation: ~400 LOC
- Documentation and examples: ~200 LOC

**Total Estimated LOC: ~2,500**

⚠️ **Large Ticket Alert**: This ticket exceeds 2000 LOC and could be split into:
1. **1.5a: Core Configuration System** (~1,200 LOC) - Types, loading, TOML support
2. **1.5b: Security and Encryption** (~800 LOC) - Secure storage, encryption, validation
3. **1.5c: Runtime Management** (~500 LOC) - Hot reload, auto-save, Tauri integration

### Implementation Complexity
- **High**: Encryption system, configuration validation, environment variable integration
- **Medium**: TOML loading/saving, runtime management, thread safety
- **Low**: Default configurations, basic Tauri commands, documentation

This configuration system provides a robust, secure foundation that supports all application needs while maintaining flexibility for future enhancements and ensuring proper security practices throughout.