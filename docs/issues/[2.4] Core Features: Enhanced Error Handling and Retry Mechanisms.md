# [2.4] Core Features: Enhanced Error Handling and Retry Mechanisms

## Overview

### Current State
- Basic error handling with simple error types
- Limited retry capabilities without sophistication
- No circuit breaker patterns or failure recovery
- Minimal error categorization and context preservation

### Target State
- Advanced retry strategies with exponential backoff and circuit breakers
- Sophisticated error categorization and recovery mechanisms
- Distributed system error handling patterns
- Integration with streaming for real-time error reporting
- Comprehensive error analytics and monitoring

### Why This Matters
- **Reliability**: Robust error handling prevents system failures from cascading
- **User Experience**: Graceful error recovery with meaningful feedback
- **Observability**: Detailed error tracking and analytics for system improvement
- **Resilience**: Circuit breakers and retry mechanisms improve system stability

## Technical Requirements

### 1. Advanced Error Classification System

```rust
use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use tokio::sync::{RwLock, Mutex};
use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

/// Comprehensive error classification and handling system
pub struct ErrorManager {
    /// Error classifier for categorizing errors
    classifier: Arc<ErrorClassifier>,
    
    /// Retry strategy manager
    retry_manager: Arc<RetryStrategyManager>,
    
    /// Circuit breaker registry
    circuit_breakers: Arc<RwLock<HashMap<String, CircuitBreaker>>>,
    
    /// Error analytics engine
    analytics: Arc<ErrorAnalytics>,
    
    /// Recovery mechanism coordinator
    recovery_coordinator: Arc<RecoveryCoordinator>,
    
    /// Error event stream for real-time reporting
    error_stream: Arc<ErrorEventStream>,
}

/// Enhanced error types with detailed context
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnhancedError {
    pub id: Uuid,
    pub error_type: ErrorType,
    pub category: ErrorCategory,
    pub severity: ErrorSeverity,
    pub message: String,
    pub context: ErrorContext,
    pub timestamp: DateTime<Utc>,
    pub source: ErrorSource,
    pub recovery_suggestions: Vec<RecoverySuggestion>,
    pub correlation_id: Option<Uuid>,
    pub user_facing_message: Option<String>,
    pub technical_details: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ErrorCategory {
    /// Network-related errors (timeouts, connection failures)
    Network,
    /// Authentication and authorization errors
    Authentication,
    /// Input validation and parsing errors
    Validation,
    /// Resource exhaustion (memory, disk, CPU)
    Resource,
    /// External service dependencies
    ExternalService,
    /// Configuration and setup errors
    Configuration,
    /// Business logic errors
    BusinessLogic,
    /// System and infrastructure errors
    System,
    /// Concurrency and synchronization errors
    Concurrency,
    /// Data consistency and integrity errors
    DataIntegrity,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum ErrorSeverity {
    Critical = 0,  // System failure, immediate attention required
    High = 1,      // Significant impact, urgent attention needed
    Medium = 2,    // Moderate impact, should be addressed soon
    Low = 3,       // Minor impact, can be deferred
    Info = 4,      // Informational, no immediate action needed
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorContext {
    pub operation: String,
    pub component: String,
    pub user_id: Option<Uuid>,
    pub session_id: Option<Uuid>,
    pub request_id: Option<Uuid>,
    pub environment: String,
    pub stack_trace: Option<String>,
    pub system_state: HashMap<String, serde_json::Value>,
    pub related_entities: Vec<EntityReference>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EntityReference {
    pub entity_type: String,
    pub entity_id: String,
    pub relationship: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ErrorSource {
    Tool { name: String, version: Option<String> },
    Workflow { id: Uuid, step: Option<String> },
    API { endpoint: String, method: String },
    Internal { module: String, function: String },
    External { service: String, endpoint: Option<String> },
}

/// Error classifier for intelligent error categorization
pub struct ErrorClassifier {
    /// Classification rules
    rules: Arc<RwLock<Vec<ClassificationRule>>>,
    
    /// Machine learning model for error classification
    ml_classifier: Arc<MLErrorClassifier>,
    
    /// Pattern matching engine
    pattern_matcher: Arc<ErrorPatternMatcher>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClassificationRule {
    pub id: String,
    pub name: String,
    pub condition: ErrorCondition,
    pub classification: ErrorClassification,
    pub confidence: f64,
    pub enabled: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ErrorCondition {
    MessageContains(String),
    ErrorTypeMatches(String),
    SourceMatches(String),
    ContextMatches(String, String), // field, value
    And(Vec<ErrorCondition>),
    Or(Vec<ErrorCondition>),
    Not(Box<ErrorCondition>),
    Custom(String), // Custom classification function name
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorClassification {
    pub category: ErrorCategory,
    pub severity: ErrorSeverity,
    pub is_transient: bool,
    pub recovery_strategy: RecoveryStrategy,
    pub user_notification: UserNotificationLevel,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum UserNotificationLevel {
    None,        // No user notification needed
    Silent,      // Log but don't notify user
    Notification, // Show non-intrusive notification
    Warning,     // Show warning message
    Error,       // Show error dialog
    Critical,    // Show critical error with escalation
}

impl ErrorClassifier {
    pub fn new() -> Self {
        Self {
            rules: Arc::new(RwLock::new(Vec::new())),
            ml_classifier: Arc::new(MLErrorClassifier::new()),
            pattern_matcher: Arc::new(ErrorPatternMatcher::new()),
        }
    }
    
    /// Classify an error with enhanced context
    pub async fn classify_error(
        &self,
        error: &dyn std::error::Error,
        context: ErrorContext,
    ) -> Result<EnhancedError, ClassificationError> {
        let error_id = Uuid::new_v4();
        let error_message = error.to_string();
        
        // Apply rule-based classification
        let rule_classification = self.apply_rules(&error_message, &context).await?;
        
        // Apply ML-based classification
        let ml_classification = self.ml_classifier
            .classify(&error_message, &context)
            .await?;
        
        // Apply pattern matching
        let pattern_classification = self.pattern_matcher
            .classify(&error_message, &context)
            .await?;
        
        // Combine classifications with confidence weighting
        let final_classification = self.combine_classifications(
            rule_classification,
            ml_classification,
            pattern_classification,
        ).await?;
        
        // Generate recovery suggestions
        let recovery_suggestions = self.generate_recovery_suggestions(
            &final_classification,
            &context,
        ).await;
        
        // Create enhanced error
        Ok(EnhancedError {
            id: error_id,
            error_type: ErrorType::from_error(error),
            category: final_classification.category,
            severity: final_classification.severity,
            message: error_message,
            context,
            timestamp: Utc::now(),
            source: self.determine_error_source(&context),
            recovery_suggestions,
            correlation_id: None,
            user_facing_message: self.generate_user_message(&final_classification, &error_message),
            technical_details: self.extract_technical_details(error),
        })
    }
    
    /// Apply rule-based classification
    async fn apply_rules(
        &self,
        message: &str,
        context: &ErrorContext,
    ) -> Result<Option<ErrorClassification>, ClassificationError> {
        let rules = self.rules.read().await;
        
        for rule in rules.iter().filter(|r| r.enabled) {
            if self.evaluate_condition(&rule.condition, message, context).await? {
                return Ok(Some(rule.classification.clone()));
            }
        }
        
        Ok(None)
    }
    
    /// Evaluate error condition
    async fn evaluate_condition(
        &self,
        condition: &ErrorCondition,
        message: &str,
        context: &ErrorContext,
    ) -> Result<bool, ClassificationError> {
        match condition {
            ErrorCondition::MessageContains(pattern) => {
                Ok(message.to_lowercase().contains(&pattern.to_lowercase()))
            }
            ErrorCondition::ErrorTypeMatches(error_type) => {
                // Match against error type patterns
                Ok(self.pattern_matcher.match_error_type(message, error_type).await)
            }
            ErrorCondition::SourceMatches(source_pattern) => {
                Ok(context.component.contains(source_pattern))
            }
            ErrorCondition::ContextMatches(field, value) => {
                if let Some(field_value) = context.system_state.get(field) {
                    Ok(field_value.as_str().unwrap_or("").contains(value))
                } else {
                    Ok(false)
                }
            }
            ErrorCondition::And(conditions) => {
                for condition in conditions {
                    if !self.evaluate_condition(condition, message, context).await? {
                        return Ok(false);
                    }
                }
                Ok(true)
            }
            ErrorCondition::Or(conditions) => {
                for condition in conditions {
                    if self.evaluate_condition(condition, message, context).await? {
                        return Ok(true);
                    }
                }
                Ok(false)
            }
            ErrorCondition::Not(condition) => {
                Ok(!self.evaluate_condition(condition, message, context).await?)
            }
            ErrorCondition::Custom(function_name) => {
                self.evaluate_custom_condition(function_name, message, context).await
            }
        }
    }
    
    /// Generate user-friendly error message
    fn generate_user_message(
        &self,
        classification: &ErrorClassification,
        technical_message: &str,
    ) -> Option<String> {
        match classification.category {
            ErrorCategory::Network => Some(
                "Network connection issue. Please check your internet connection and try again.".to_string()
            ),
            ErrorCategory::Authentication => Some(
                "Authentication failed. Please check your credentials and try again.".to_string()
            ),
            ErrorCategory::Validation => Some(
                "Invalid input provided. Please check your data and try again.".to_string()
            ),
            ErrorCategory::Resource => Some(
                "System resources are temporarily unavailable. Please try again in a moment.".to_string()
            ),
            ErrorCategory::ExternalService => Some(
                "External service is temporarily unavailable. Please try again later.".to_string()
            ),
            _ => None,
        }
    }
}
```

### 2. Advanced Retry Strategy System

```rust
/// Advanced retry strategy management system
pub struct RetryStrategyManager {
    /// Registered retry strategies
    strategies: Arc<RwLock<HashMap<String, Box<dyn RetryStrategy + Send + Sync>>>>,
    
    /// Retry attempt tracking
    attempt_tracker: Arc<RwLock<HashMap<String, RetryAttemptHistory>>>,
    
    /// Jitter calculator for retry delays
    jitter_calculator: Arc<JitterCalculator>,
    
    /// Retry metrics collector
    metrics: Arc<RetryMetrics>,
}

/// Trait for implementing retry strategies
#[async_trait]
pub trait RetryStrategy: Send + Sync {
    /// Determine if a retry should be attempted
    async fn should_retry(
        &self,
        error: &EnhancedError,
        attempt_count: usize,
        context: &RetryContext,
    ) -> bool;
    
    /// Calculate delay before next retry
    async fn calculate_delay(
        &self,
        error: &EnhancedError,
        attempt_count: usize,
        context: &RetryContext,
    ) -> Duration;
    
    /// Get maximum retry attempts
    fn max_attempts(&self) -> usize;
    
    /// Get strategy name
    fn name(&self) -> &str;
}

#[derive(Debug, Clone)]
pub struct RetryContext {
    pub operation_id: Uuid,
    pub operation_type: String,
    pub start_time: DateTime<Utc>,
    pub total_duration: Duration,
    pub previous_errors: Vec<EnhancedError>,
    pub user_id: Option<Uuid>,
    pub priority: RetryPriority,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum RetryPriority {
    Critical = 0,
    High = 1,
    Normal = 2,
    Low = 3,
    Background = 4,
}

#[derive(Debug, Clone)]
pub struct RetryAttemptHistory {
    pub operation_id: Uuid,
    pub attempts: Vec<RetryAttempt>,
    pub started_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
    pub final_result: Option<RetryResult>,
}

#[derive(Debug, Clone)]
pub struct RetryAttempt {
    pub attempt_number: usize,
    pub started_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
    pub error: Option<EnhancedError>,
    pub delay_before_attempt: Duration,
    pub strategy_used: String,
}

#[derive(Debug, Clone)]
pub enum RetryResult {
    Success,
    MaxAttemptsExceeded,
    TimeoutExceeded,
    NonRetryableError,
    CircuitBreakerOpen,
    UserCancelled,
}

/// Exponential backoff with jitter retry strategy
pub struct ExponentialBackoffStrategy {
    pub name: String,
    pub base_delay: Duration,
    pub max_delay: Duration,
    pub backoff_multiplier: f64,
    pub max_attempts: usize,
    pub jitter_type: JitterType,
    pub retryable_categories: HashSet<ErrorCategory>,
}

#[derive(Debug, Clone, Copy)]
pub enum JitterType {
    None,
    Full,      // Random jitter up to calculated delay
    Equal,     // Half fixed delay + half random jitter
    Decorrelated, // Decorrelated jitter algorithm
}

#[async_trait]
impl RetryStrategy for ExponentialBackoffStrategy {
    async fn should_retry(
        &self,
        error: &EnhancedError,
        attempt_count: usize,
        context: &RetryContext,
    ) -> bool {
        // Check attempt limit
        if attempt_count >= self.max_attempts {
            return false;
        }
        
        // Check if error category is retryable
        if !self.retryable_categories.contains(&error.category) {
            return false;
        }
        
        // Check error severity (don't retry critical errors)
        if error.severity == ErrorSeverity::Critical {
            return false;
        }
        
        // Check if error is marked as transient
        // This would be determined by the error classifier
        true
    }
    
    async fn calculate_delay(
        &self,
        _error: &EnhancedError,
        attempt_count: usize,
        _context: &RetryContext,
    ) -> Duration {
        let base_delay_ms = self.base_delay.as_millis() as f64;
        let calculated_delay = base_delay_ms * self.backoff_multiplier.powi(attempt_count as i32);
        
        let delay = Duration::from_millis(calculated_delay.min(self.max_delay.as_millis() as f64) as u64);
        
        // Apply jitter
        match self.jitter_type {
            JitterType::None => delay,
            JitterType::Full => {
                let jitter = rand::random::<f64>() * delay.as_millis() as f64;
                Duration::from_millis(jitter as u64)
            }
            JitterType::Equal => {
                let base = delay.as_millis() as f64 / 2.0;
                let jitter = rand::random::<f64>() * base;
                Duration::from_millis((base + jitter) as u64)
            }
            JitterType::Decorrelated => {
                // Decorrelated jitter algorithm
                let jitter = rand::random::<f64>() * delay.as_millis() as f64 * 3.0;
                Duration::from_millis((delay.as_millis() as f64 + jitter) as u64 / 4)
            }
        }
    }
    
    fn max_attempts(&self) -> usize {
        self.max_attempts
    }
    
    fn name(&self) -> &str {
        &self.name
    }
}

/// Circuit breaker retry strategy
pub struct CircuitBreakerStrategy {
    pub name: String,
    pub failure_threshold: usize,
    pub success_threshold: usize,
    pub timeout: Duration,
    pub retry_strategy: Box<dyn RetryStrategy + Send + Sync>,
}

#[async_trait]
impl RetryStrategy for CircuitBreakerStrategy {
    async fn should_retry(
        &self,
        error: &EnhancedError,
        attempt_count: usize,
        context: &RetryContext,
    ) -> bool {
        // Check circuit breaker state first
        // Implementation would check circuit breaker registry
        
        // Then delegate to underlying strategy
        self.retry_strategy.should_retry(error, attempt_count, context).await
    }
    
    async fn calculate_delay(
        &self,
        error: &EnhancedError,
        attempt_count: usize,
        context: &RetryContext,
    ) -> Duration {
        self.retry_strategy.calculate_delay(error, attempt_count, context).await
    }
    
    fn max_attempts(&self) -> usize {
        self.retry_strategy.max_attempts()
    }
    
    fn name(&self) -> &str {
        &self.name
    }
}

impl RetryStrategyManager {
    pub fn new() -> Self {
        let mut manager = Self {
            strategies: Arc::new(RwLock::new(HashMap::new())),
            attempt_tracker: Arc::new(RwLock::new(HashMap::new())),
            jitter_calculator: Arc::new(JitterCalculator::new()),
            metrics: Arc::new(RetryMetrics::new()),
        };
        
        // Register default strategies
        manager.register_default_strategies();
        
        manager
    }
    
    /// Execute operation with retry logic
    pub async fn execute_with_retry<F, T, E>(
        &self,
        operation: F,
        strategy_name: &str,
        context: RetryContext,
    ) -> Result<T, RetryError<E>>
    where
        F: Fn() -> Pin<Box<dyn Future<Output = Result<T, E>> + Send>> + Send + Sync,
        T: Send,
        E: std::error::Error + Send + Sync + 'static,
    {
        let strategy = {
            let strategies = self.strategies.read().await;
            strategies.get(strategy_name)
                .ok_or(RetryError::StrategyNotFound(strategy_name.to_string()))?
                .clone()
        };
        
        let mut attempt_count = 0;
        let mut history = RetryAttemptHistory {
            operation_id: context.operation_id,
            attempts: Vec::new(),
            started_at: Utc::now(),
            completed_at: None,
            final_result: None,
        };
        
        loop {
            attempt_count += 1;
            let attempt_start = Utc::now();
            
            // Execute operation
            let result = operation().await;
            
            match result {
                Ok(value) => {
                    // Success - record and return
                    history.attempts.push(RetryAttempt {
                        attempt_number: attempt_count,
                        started_at: attempt_start,
                        completed_at: Some(Utc::now()),
                        error: None,
                        delay_before_attempt: Duration::from_secs(0),
                        strategy_used: strategy.name().to_string(),
                    });
                    
                    history.completed_at = Some(Utc::now());
                    history.final_result = Some(RetryResult::Success);
                    
                    // Record metrics
                    self.metrics.record_success(strategy.name(), attempt_count).await;
                    
                    return Ok(value);
                }
                Err(error) => {
                    // Classify error
                    let enhanced_error = self.classify_error(&*error, context.clone()).await?;
                    
                    // Check if we should retry
                    if strategy.should_retry(&enhanced_error, attempt_count, &context).await {
                        // Calculate delay
                        let delay = strategy.calculate_delay(&enhanced_error, attempt_count, &context).await;
                        
                        // Record attempt
                        history.attempts.push(RetryAttempt {
                            attempt_number: attempt_count,
                            started_at: attempt_start,
                            completed_at: Some(Utc::now()),
                            error: Some(enhanced_error),
                            delay_before_attempt: delay,
                            strategy_used: strategy.name().to_string(),
                        });
                        
                        // Wait before retry
                        tokio::time::sleep(delay).await;
                        
                        // Continue to next attempt
                        continue;
                    } else {
                        // No more retries
                        history.completed_at = Some(Utc::now());
                        history.final_result = Some(RetryResult::MaxAttemptsExceeded);
                        
                        // Record metrics
                        self.metrics.record_failure(strategy.name(), attempt_count).await;
                        
                        return Err(RetryError::MaxAttemptsExceeded {
                            attempts: attempt_count,
                            last_error: Box::new(error),
                            history,
                        });
                    }
                }
            }
        }
    }
    
    /// Register default retry strategies
    fn register_default_strategies(&mut self) {
        // Exponential backoff for general errors
        let general_strategy = ExponentialBackoffStrategy {
            name: "general_exponential".to_string(),
            base_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(30),
            backoff_multiplier: 2.0,
            max_attempts: 5,
            jitter_type: JitterType::Full,
            retryable_categories: HashSet::from([
                ErrorCategory::Network,
                ErrorCategory::ExternalService,
                ErrorCategory::Resource,
            ]),
        };
        
        // Fast retry for transient network errors
        let network_strategy = ExponentialBackoffStrategy {
            name: "network_fast".to_string(),
            base_delay: Duration::from_millis(50),
            max_delay: Duration::from_secs(5),
            backoff_multiplier: 1.5,
            max_attempts: 10,
            jitter_type: JitterType::Equal,
            retryable_categories: HashSet::from([
                ErrorCategory::Network,
            ]),
        };
        
        // Conservative retry for external services
        let external_strategy = ExponentialBackoffStrategy {
            name: "external_conservative".to_string(),
            base_delay: Duration::from_secs(1),
            max_delay: Duration::from_secs(60),
            backoff_multiplier: 2.5,
            max_attempts: 3,
            jitter_type: JitterType::Decorrelated,
            retryable_categories: HashSet::from([
                ErrorCategory::ExternalService,
            ]),
        };
        
        // Register strategies
        self.strategies.blocking_write().insert(
            "general".to_string(),
            Box::new(general_strategy)
        );
        self.strategies.blocking_write().insert(
            "network".to_string(),
            Box::new(network_strategy)
        );
        self.strategies.blocking_write().insert(
            "external".to_string(),
            Box::new(external_strategy)
        );
    }
}
```

### 3. Circuit Breaker Implementation

```rust
/// Circuit breaker for preventing cascading failures
pub struct CircuitBreaker {
    pub name: String,
    pub state: Arc<RwLock<CircuitBreakerState>>,
    pub config: CircuitBreakerConfig,
    pub metrics: Arc<CircuitBreakerMetrics>,
    pub event_listener: Arc<CircuitBreakerEventListener>,
}

#[derive(Debug, Clone)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: usize,
    pub success_threshold: usize,
    pub timeout: Duration,
    pub max_concurrent_requests: usize,
    pub error_predicate: Arc<dyn Fn(&EnhancedError) -> bool + Send + Sync>,
}

#[derive(Debug, Clone)]
pub enum CircuitBreakerState {
    Closed {
        failure_count: usize,
        success_count: usize,
        last_failure_time: Option<DateTime<Utc>>,
    },
    Open {
        opened_at: DateTime<Utc>,
        last_attempt_time: Option<DateTime<Utc>>,
    },
    HalfOpen {
        success_count: usize,
        failure_count: usize,
        opened_at: DateTime<Utc>,
    },
}

#[derive(Debug, Clone)]
pub struct CircuitBreakerMetrics {
    pub total_requests: usize,
    pub successful_requests: usize,
    pub failed_requests: usize,
    pub rejected_requests: usize,
    pub state_transitions: Vec<StateTransition>,
    pub current_failure_rate: f64,
    pub average_response_time: Duration,
}

#[derive(Debug, Clone)]
pub struct StateTransition {
    pub from_state: String,
    pub to_state: String,
    pub timestamp: DateTime<Utc>,
    pub trigger: String,
}

impl CircuitBreaker {
    pub fn new(name: String, config: CircuitBreakerConfig) -> Self {
        Self {
            name,
            state: Arc::new(RwLock::new(CircuitBreakerState::Closed {
                failure_count: 0,
                success_count: 0,
                last_failure_time: None,
            })),
            config,
            metrics: Arc::new(CircuitBreakerMetrics::new()),
            event_listener: Arc::new(CircuitBreakerEventListener::new()),
        }
    }
    
    /// Execute operation with circuit breaker protection
    pub async fn execute<F, T, E>(&self, operation: F) -> Result<T, CircuitBreakerError<E>>
    where
        F: Future<Output = Result<T, E>>,
        E: std::error::Error + Send + Sync + 'static,
    {
        // Check if request should be allowed
        if !self.should_allow_request().await {
            self.record_rejected_request().await;
            return Err(CircuitBreakerError::CircuitOpen);
        }
        
        let start_time = Instant::now();
        
        // Execute operation
        match operation.await {
            Ok(result) => {
                let duration = start_time.elapsed();
                self.record_success(duration).await;
                Ok(result)
            }
            Err(error) => {
                let duration = start_time.elapsed();
                
                // Classify error to determine if it should trigger circuit breaker
                let enhanced_error = self.enhance_error(&error).await;
                
                if (self.config.error_predicate)(&enhanced_error) {
                    self.record_failure(duration).await;
                } else {
                    // Error doesn't count towards circuit breaker
                    self.record_success(duration).await;
                }
                
                Err(CircuitBreakerError::OperationFailed(error))
            }
        }
    }
    
    /// Check if request should be allowed based on current state
    async fn should_allow_request(&self) -> bool {
        let state = self.state.read().await;
        
        match &*state {
            CircuitBreakerState::Closed { .. } => true,
            CircuitBreakerState::Open { opened_at, .. } => {
                // Check if timeout has elapsed
                Utc::now().signed_duration_since(*opened_at) 
                    >= chrono::Duration::from_std(self.config.timeout).unwrap()
            }
            CircuitBreakerState::HalfOpen { .. } => {
                // Allow limited requests in half-open state
                self.get_concurrent_requests().await < self.config.max_concurrent_requests
            }
        }
    }
    
    /// Record successful operation
    async fn record_success(&self, duration: Duration) {
        let mut state = self.state.write().await;
        
        match &mut *state {
            CircuitBreakerState::Closed { success_count, failure_count, .. } => {
                *success_count += 1;
                *failure_count = 0; // Reset failure count on success
            }
            CircuitBreakerState::HalfOpen { success_count, .. } => {
                *success_count += 1;
                
                // Check if we should close the circuit
                if *success_count >= self.config.success_threshold {
                    self.transition_to_closed(&mut state).await;
                }
            }
            _ => {}
        }
        
        // Update metrics
        self.metrics.record_success(duration).await;
    }
    
    /// Record failed operation
    async fn record_failure(&self, duration: Duration) {
        let mut state = self.state.write().await;
        
        match &mut *state {
            CircuitBreakerState::Closed { failure_count, last_failure_time, .. } => {
                *failure_count += 1;
                *last_failure_time = Some(Utc::now());
                
                // Check if we should open the circuit
                if *failure_count >= self.config.failure_threshold {
                    self.transition_to_open(&mut state).await;
                }
            }
            CircuitBreakerState::HalfOpen { failure_count, .. } => {
                *failure_count += 1;
                
                // Any failure in half-open state opens the circuit
                self.transition_to_open(&mut state).await;
            }
            _ => {}
        }
        
        // Update metrics
        self.metrics.record_failure(duration).await;
    }
    
    /// Transition to open state
    async fn transition_to_open(&self, state: &mut CircuitBreakerState) {
        let old_state = format!("{:?}", state);
        *state = CircuitBreakerState::Open {
            opened_at: Utc::now(),
            last_attempt_time: None,
        };
        
        // Record state transition
        self.record_state_transition(&old_state, "Open", "Failure threshold exceeded").await;
        
        // Notify event listener
        self.event_listener.on_state_change(&self.name, "Open").await;
    }
    
    /// Transition to closed state
    async fn transition_to_closed(&self, state: &mut CircuitBreakerState) {
        let old_state = format!("{:?}", state);
        *state = CircuitBreakerState::Closed {
            failure_count: 0,
            success_count: 0,
            last_failure_time: None,
        };
        
        // Record state transition
        self.record_state_transition(&old_state, "Closed", "Success threshold met").await;
        
        // Notify event listener
        self.event_listener.on_state_change(&self.name, "Closed").await;
    }
    
    /// Get current circuit breaker metrics
    pub async fn get_metrics(&self) -> CircuitBreakerMetrics {
        self.metrics.get_current_metrics().await
    }
    
    /// Get current state
    pub async fn get_state(&self) -> CircuitBreakerState {
        self.state.read().await.clone()
    }
}

/// Circuit breaker registry for managing multiple circuit breakers
pub struct CircuitBreakerRegistry {
    breakers: Arc<RwLock<HashMap<String, Arc<CircuitBreaker>>>>,
    default_config: CircuitBreakerConfig,
}

impl CircuitBreakerRegistry {
    pub fn new() -> Self {
        Self {
            breakers: Arc::new(RwLock::new(HashMap::new())),
            default_config: CircuitBreakerConfig::default(),
        }
    }
    
    /// Get or create circuit breaker for a service
    pub async fn get_or_create(
        &self,
        service_name: &str,
        config: Option<CircuitBreakerConfig>,
    ) -> Arc<CircuitBreaker> {
        let mut breakers = self.breakers.write().await;
        
        if let Some(breaker) = breakers.get(service_name) {
            breaker.clone()
        } else {
            let config = config.unwrap_or_else(|| self.default_config.clone());
            let breaker = Arc::new(CircuitBreaker::new(service_name.to_string(), config));
            breakers.insert(service_name.to_string(), breaker.clone());
            breaker
        }
    }
    
    /// Execute operation with circuit breaker protection
    pub async fn execute_with_breaker<F, T, E>(
        &self,
        service_name: &str,
        operation: F,
    ) -> Result<T, CircuitBreakerError<E>>
    where
        F: Future<Output = Result<T, E>>,
        E: std::error::Error + Send + Sync + 'static,
    {
        let breaker = self.get_or_create(service_name, None).await;
        breaker.execute(operation).await
    }
}
```

### 4. Recovery Mechanisms

```rust
/// Recovery coordinator for handling error recovery scenarios
pub struct RecoveryCoordinator {
    /// Recovery strategies registry
    strategies: Arc<RwLock<HashMap<String, Box<dyn RecoveryStrategy + Send + Sync>>>>,
    
    /// Recovery attempt tracker
    recovery_tracker: Arc<RwLock<HashMap<Uuid, RecoveryAttempt>>>,
    
    /// Recovery success rate analyzer
    success_analyzer: Arc<RecoverySuccessAnalyzer>,
    
    /// Automated recovery engine
    auto_recovery: Arc<AutoRecoveryEngine>,
}

/// Recovery strategy trait
#[async_trait]
pub trait RecoveryStrategy: Send + Sync {
    /// Attempt to recover from the given error
    async fn attempt_recovery(
        &self,
        error: &EnhancedError,
        context: &RecoveryContext,
    ) -> Result<RecoveryResult, RecoveryError>;
    
    /// Check if this strategy is applicable to the error
    async fn is_applicable(&self, error: &EnhancedError) -> bool;
    
    /// Get strategy name
    fn name(&self) -> &str;
    
    /// Get strategy priority (lower number = higher priority)
    fn priority(&self) -> i32;
}

#[derive(Debug, Clone)]
pub struct RecoveryContext {
    pub operation_id: Uuid,
    pub user_id: Option<Uuid>,
    pub session_id: Option<Uuid>,
    pub original_request: serde_json::Value,
    pub system_state: HashMap<String, serde_json::Value>,
    pub recovery_budget: RecoveryBudget,
}

#[derive(Debug, Clone)]
pub struct RecoveryBudget {
    pub max_attempts: usize,
    pub max_duration: Duration,
    pub max_cost: f64, // Arbitrary cost units
    pub used_attempts: usize,
    pub used_duration: Duration,
    pub used_cost: f64,
}

#[derive(Debug, Clone)]
pub struct RecoveryAttempt {
    pub id: Uuid,
    pub error_id: Uuid,
    pub strategy_name: String,
    pub started_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
    pub result: Option<RecoveryResult>,
    pub cost: f64,
}

#[derive(Debug, Clone)]
pub enum RecoveryResult {
    /// Recovery was successful
    Success {
        description: String,
        new_state: Option<serde_json::Value>,
    },
    /// Recovery partially successful, operation can continue with limitations
    PartialSuccess {
        description: String,
        limitations: Vec<String>,
        new_state: Option<serde_json::Value>,
    },
    /// Recovery failed, but system is in safe state
    Failed {
        reason: String,
        safe_state: bool,
    },
    /// Recovery not possible for this error
    NotApplicable,
}

/// Network connectivity recovery strategy
pub struct NetworkRecoveryStrategy {
    name: String,
    connection_tester: Arc<NetworkConnectivityTester>,
    fallback_endpoints: Vec<String>,
}

#[async_trait]
impl RecoveryStrategy for NetworkRecoveryStrategy {
    async fn attempt_recovery(
        &self,
        error: &EnhancedError,
        context: &RecoveryContext,
    ) -> Result<RecoveryResult, RecoveryError> {
        // Test primary connection
        if self.connection_tester.test_primary_connection().await? {
            return Ok(RecoveryResult::Success {
                description: "Network connectivity restored".to_string(),
                new_state: None,
            });
        }
        
        // Try fallback endpoints
        for endpoint in &self.fallback_endpoints {
            if self.connection_tester.test_endpoint(endpoint).await? {
                return Ok(RecoveryResult::PartialSuccess {
                    description: format!("Fallback endpoint {} available", endpoint),
                    limitations: vec!["Using fallback endpoint - reduced functionality".to_string()],
                    new_state: Some(json!({ "fallback_endpoint": endpoint })),
                });
            }
        }
        
        Ok(RecoveryResult::Failed {
            reason: "No network connectivity available".to_string(),
            safe_state: true,
        })
    }
    
    async fn is_applicable(&self, error: &EnhancedError) -> bool {
        error.category == ErrorCategory::Network
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn priority(&self) -> i32 {
        1 // High priority for network issues
    }
}

/// Authentication recovery strategy
pub struct AuthenticationRecoveryStrategy {
    name: String,
    token_refresher: Arc<TokenRefresher>,
    credential_validator: Arc<CredentialValidator>,
}

#[async_trait]
impl RecoveryStrategy for AuthenticationRecoveryStrategy {
    async fn attempt_recovery(
        &self,
        error: &EnhancedError,
        context: &RecoveryContext,
    ) -> Result<RecoveryResult, RecoveryError> {
        // Try to refresh authentication token
        match self.token_refresher.refresh_token(context.user_id).await {
            Ok(new_token) => {
                // Validate new token
                if self.credential_validator.validate_token(&new_token).await? {
                    Ok(RecoveryResult::Success {
                        description: "Authentication token refreshed successfully".to_string(),
                        new_state: Some(json!({ "new_token": new_token })),
                    })
                } else {
                    Ok(RecoveryResult::Failed {
                        reason: "Token refresh succeeded but validation failed".to_string(),
                        safe_state: true,
                    })
                }
            }
            Err(_) => {
                Ok(RecoveryResult::Failed {
                    reason: "Token refresh failed - user re-authentication required".to_string(),
                    safe_state: true,
                })
            }
        }
    }
    
    async fn is_applicable(&self, error: &EnhancedError) -> bool {
        error.category == ErrorCategory::Authentication
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn priority(&self) -> i32 {
        2 // Medium-high priority
    }
}

/// Resource cleanup recovery strategy
pub struct ResourceCleanupStrategy {
    name: String,
    resource_monitor: Arc<ResourceMonitor>,
    cleanup_handlers: HashMap<String, Box<dyn CleanupHandler + Send + Sync>>,
}

#[async_trait]
impl RecoveryStrategy for ResourceCleanupStrategy {
    async fn attempt_recovery(
        &self,
        error: &EnhancedError,
        context: &RecoveryContext,
    ) -> Result<RecoveryResult, RecoveryError> {
        // Identify resource pressure points
        let resource_state = self.resource_monitor.get_current_state().await?;
        
        let mut cleanup_performed = Vec::new();
        let mut resources_freed = 0;
        
        // Perform cleanup based on resource pressure
        if resource_state.memory_usage > 0.9 {
            if let Some(handler) = self.cleanup_handlers.get("memory") {
                match handler.cleanup().await {
                    Ok(freed) => {
                        cleanup_performed.push("memory cleanup".to_string());
                        resources_freed += freed;
                    }
                    Err(_) => {}
                }
            }
        }
        
        if resource_state.disk_usage > 0.95 {
            if let Some(handler) = self.cleanup_handlers.get("disk") {
                match handler.cleanup().await {
                    Ok(freed) => {
                        cleanup_performed.push("disk cleanup".to_string());
                        resources_freed += freed;
                    }
                    Err(_) => {}
                }
            }
        }
        
        if resources_freed > 0 {
            Ok(RecoveryResult::Success {
                description: format!("Cleaned up resources: {}", cleanup_performed.join(", ")),
                new_state: Some(json!({ "resources_freed": resources_freed })),
            })
        } else {
            Ok(RecoveryResult::Failed {
                reason: "No resources could be freed".to_string(),
                safe_state: true,
            })
        }
    }
    
    async fn is_applicable(&self, error: &EnhancedError) -> bool {
        error.category == ErrorCategory::Resource
    }
    
    fn name(&self) -> &str {
        &self.name
    }
    
    fn priority(&self) -> i32 {
        3 // Medium priority
    }
}

impl RecoveryCoordinator {
    pub fn new() -> Self {
        let mut coordinator = Self {
            strategies: Arc::new(RwLock::new(HashMap::new())),
            recovery_tracker: Arc::new(RwLock::new(HashMap::new())),
            success_analyzer: Arc::new(RecoverySuccessAnalyzer::new()),
            auto_recovery: Arc::new(AutoRecoveryEngine::new()),
        };
        
        // Register default recovery strategies
        coordinator.register_default_strategies();
        
        coordinator
    }
    
    /// Attempt to recover from an error
    pub async fn attempt_recovery(
        &self,
        error: &EnhancedError,
        context: RecoveryContext,
    ) -> Result<RecoveryResult, RecoveryError> {
        // Find applicable recovery strategies
        let applicable_strategies = self.find_applicable_strategies(error).await;
        
        if applicable_strategies.is_empty() {
            return Ok(RecoveryResult::NotApplicable);
        }
        
        // Sort by priority
        let mut sorted_strategies = applicable_strategies;
        sorted_strategies.sort_by_key(|s| s.priority());
        
        // Try each strategy until one succeeds
        for strategy in sorted_strategies {
            // Check recovery budget
            if !self.check_recovery_budget(&context) {
                return Err(RecoveryError::BudgetExceeded);
            }
            
            let attempt_id = Uuid::new_v4();
            let attempt = RecoveryAttempt {
                id: attempt_id,
                error_id: error.id,
                strategy_name: strategy.name().to_string(),
                started_at: Utc::now(),
                completed_at: None,
                result: None,
                cost: 1.0, // Default cost
            };
            
            // Record attempt
            self.recovery_tracker.write().await.insert(attempt_id, attempt);
            
            // Attempt recovery
            match strategy.attempt_recovery(error, &context).await {
                Ok(result) => {
                    match &result {
                        RecoveryResult::Success { .. } | RecoveryResult::PartialSuccess { .. } => {
                            // Success - record and return
                            self.record_recovery_attempt(attempt_id, result.clone()).await;
                            return Ok(result);
                        }
                        RecoveryResult::Failed { .. } => {
                            // Strategy failed, try next one
                            self.record_recovery_attempt(attempt_id, result).await;
                            continue;
                        }
                        RecoveryResult::NotApplicable => {
                            // Strategy not applicable, try next one
                            self.record_recovery_attempt(attempt_id, result).await;
                            continue;
                        }
                    }
                }
                Err(recovery_error) => {
                    // Strategy errored, try next one
                    let failed_result = RecoveryResult::Failed {
                        reason: recovery_error.to_string(),
                        safe_state: false,
                    };
                    self.record_recovery_attempt(attempt_id, failed_result).await;
                    continue;
                }
            }
        }
        
        // All strategies failed
        Ok(RecoveryResult::Failed {
            reason: "All recovery strategies failed".to_string(),
            safe_state: true,
        })
    }
}
```

### 5. Error Analytics and Monitoring

```rust
/// Error analytics engine for tracking and analyzing error patterns
pub struct ErrorAnalytics {
    /// Error event store
    event_store: Arc<ErrorEventStore>,
    
    /// Pattern detection engine
    pattern_detector: Arc<ErrorPatternDetector>,
    
    /// Metrics aggregator
    metrics_aggregator: Arc<ErrorMetricsAggregator>,
    
    /// Alerting system
    alerting: Arc<ErrorAlertingSystem>,
    
    /// Dashboard generator
    dashboard: Arc<ErrorDashboard>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorEvent {
    pub event_id: Uuid,
    pub error_id: Uuid,
    pub event_type: ErrorEventType,
    pub timestamp: DateTime<Utc>,
    pub context: ErrorContext,
    pub metadata: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ErrorEventType {
    ErrorOccurred,
    ErrorResolved,
    RetryAttempted,
    RecoveryAttempted,
    CircuitBreakerTriggered,
    PatternDetected,
}

/// Error pattern detection
pub struct ErrorPatternDetector {
    /// Known error patterns
    patterns: Arc<RwLock<Vec<ErrorPattern>>>,
    
    /// Pattern matching engine
    matcher: Arc<PatternMatcher>,
    
    /// Machine learning model for pattern detection
    ml_model: Arc<ErrorPatternMLModel>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorPattern {
    pub id: Uuid,
    pub name: String,
    pub description: String,
    pub pattern_type: ErrorPatternType,
    pub conditions: Vec<PatternCondition>,
    pub confidence_threshold: f64,
    pub alert_severity: ErrorSeverity,
    pub suggested_actions: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ErrorPatternType {
    /// Errors occurring at regular intervals
    Periodic,
    /// Sudden spike in error rate
    Spike,
    /// Gradual increase in error rate
    Trend,
    /// Errors affecting specific user groups
    Segmented,
    /// Cascading failures
    Cascade,
    /// Resource exhaustion patterns
    ResourceExhaustion,
}

impl ErrorAnalytics {
    /// Analyze error trends and patterns
    pub async fn analyze_errors(
        &self,
        time_range: TimeRange,
        filters: Option<ErrorFilters>,
    ) -> Result<ErrorAnalysisReport, AnalyticsError> {
        // Fetch error events for the time range
        let events = self.event_store
            .get_events(time_range, filters)
            .await?;
        
        // Detect patterns
        let patterns = self.pattern_detector
            .detect_patterns(&events)
            .await?;
        
        // Generate metrics
        let metrics = self.metrics_aggregator
            .aggregate_metrics(&events)
            .await?;
        
        // Create analysis report
        Ok(ErrorAnalysisReport {
            time_range,
            total_errors: events.len(),
            patterns_detected: patterns,
            metrics,
            recommendations: self.generate_recommendations(&patterns).await,
            generated_at: Utc::now(),
        })
    }
    
    /// Real-time error monitoring
    pub async fn start_real_time_monitoring(&self) -> ErrorMonitorHandle {
        let analytics = self.clone();
        let (tx, rx) = mpsc::unbounded_channel();
        
        tokio::spawn(async move {
            let mut event_stream = analytics.event_store.subscribe_to_events().await;
            
            while let Some(event) = event_stream.next().await {
                // Analyze event in real-time
                if let Some(alert) = analytics.analyze_event_real_time(&event).await {
                    let _ = tx.send(alert);
                }
            }
        });
        
        ErrorMonitorHandle { receiver: rx }
    }
    
    /// Generate error dashboard data
    pub async fn generate_dashboard_data(
        &self,
        time_range: TimeRange,
    ) -> Result<ErrorDashboardData, AnalyticsError> {
        let events = self.event_store.get_events(time_range, None).await?;
        
        // Error rate over time
        let error_rate_series = self.calculate_error_rate_series(&events, time_range).await;
        
        // Error distribution by category
        let category_distribution = self.calculate_category_distribution(&events).await;
        
        // Top error sources
        let top_sources = self.identify_top_error_sources(&events).await;
        
        // Recovery success rates
        let recovery_rates = self.calculate_recovery_success_rates(&events).await;
        
        Ok(ErrorDashboardData {
            time_range,
            error_rate_series,
            category_distribution,
            top_sources,
            recovery_rates,
            current_alerts: self.alerting.get_active_alerts().await,
            system_health: self.calculate_system_health_score(&events).await,
        })
    }
}
```

## Architecture Changes

### Current Architecture
```

  Basic Errors   

 Simple Types    
 Basic Retry     
 No Recovery     

```

### Target Architecture
```

                Enhanced Error Handling System                   

    
    Error         Retry          Circuit Breakers        
 Classifier &   Strategy       & Failure Prevention      
 Enhancement    Manager                                  
    

    
   Recovery    Error Analytics     Real-time Monitoring    
 Coordinator & & Pattern          & Alerting System        
 Mechanisms     Detection                                  
    

```

## Implementation Plan

### Phase 1: Error Classification System (Week 1-2)
1. Implement `EnhancedError` types and `ErrorClassifier`
2. Create rule-based and ML-based classification
3. Build error context enrichment
4. Set up error event streaming

### Phase 2: Advanced Retry Strategies (Week 2-3)
1. Implement `RetryStrategyManager` with multiple strategies
2. Create exponential backoff with jitter
3. Build retry attempt tracking and metrics
4. Add custom retry strategy support

### Phase 3: Circuit Breaker System (Week 3-4)
1. Implement `CircuitBreaker` with state management
2. Create circuit breaker registry
3. Build metrics and monitoring
4. Add event notifications

### Phase 4: Recovery Mechanisms (Week 4-5)
1. Implement `RecoveryCoordinator` and strategies
2. Create automated recovery engine
3. Build recovery budget management
4. Add recovery success tracking

### Phase 5: Analytics & Monitoring (Week 5-6)
1. Implement error analytics engine
2. Create pattern detection system
3. Build real-time monitoring and alerting
4. Add error dashboard and reporting

## Testing Strategy

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_error_classification() {
        let classifier = ErrorClassifier::new();
        
        // Add classification rule
        let rule = ClassificationRule {
            id: "network_timeout".to_string(),
            name: "Network Timeout".to_string(),
            condition: ErrorCondition::MessageContains("timeout".to_string()),
            classification: ErrorClassification {
                category: ErrorCategory::Network,
                severity: ErrorSeverity::Medium,
                is_transient: true,
                recovery_strategy: RecoveryStrategy::Retry,
                user_notification: UserNotificationLevel::Notification,
            },
            confidence: 0.9,
            enabled: true,
        };
        
        classifier.add_rule(rule).await;
        
        // Test classification
        let error = std::io::Error::new(std::io::ErrorKind::TimedOut, "Connection timeout");
        let context = ErrorContext::default();
        
        let enhanced = classifier.classify_error(&error, context).await.unwrap();
        
        assert_eq!(enhanced.category, ErrorCategory::Network);
        assert_eq!(enhanced.severity, ErrorSeverity::Medium);
        assert!(enhanced.user_facing_message.is_some());
    }
    
    #[tokio::test]
    async fn test_retry_strategy() {
        let strategy = ExponentialBackoffStrategy {
            name: "test_strategy".to_string(),
            base_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(10),
            backoff_multiplier: 2.0,
            max_attempts: 5,
            jitter_type: JitterType::None,
            retryable_categories: HashSet::from([ErrorCategory::Network]),
        };
        
        let error = create_test_enhanced_error(ErrorCategory::Network);
        let context = RetryContext::default();
        
        // Should retry for network errors
        assert!(strategy.should_retry(&error, 1, &context).await);
        assert!(strategy.should_retry(&error, 3, &context).await);
        assert!(!strategy.should_retry(&error, 6, &context).await); // Exceeds max attempts
        
        // Test delay calculation
        let delay1 = strategy.calculate_delay(&error, 1, &context).await;
        let delay2 = strategy.calculate_delay(&error, 2, &context).await;
        
        assert!(delay2 > delay1); // Should increase with attempt count
    }
    
    #[tokio::test]
    async fn test_circuit_breaker() {
        let config = CircuitBreakerConfig {
            failure_threshold: 3,
            success_threshold: 2,
            timeout: Duration::from_secs(5),
            max_concurrent_requests: 10,
            error_predicate: Arc::new(|_| true),
        };
        
        let breaker = CircuitBreaker::new("test_service".to_string(), config);
        
        // Initially closed
        assert!(matches!(
            breaker.get_state().await,
            CircuitBreakerState::Closed { .. }
        ));
        
        // Simulate failures
        for _ in 0..3 {
            let result: Result<(), std::io::Error> = Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Test error"
            ));
            let _ = breaker.execute(async { result }).await;
        }
        
        // Should be open now
        assert!(matches!(
            breaker.get_state().await,
            CircuitBreakerState::Open { .. }
        ));
        
        // Requests should be rejected
        let result = breaker.execute(async { Ok::<(), std::io::Error>(()) }).await;
        assert!(matches!(result, Err(CircuitBreakerError::CircuitOpen)));
    }
    
    #[tokio::test]
    async fn test_recovery_coordination() {
        let coordinator = RecoveryCoordinator::new();
        
        let error = create_test_enhanced_error(ErrorCategory::Network);
        let context = RecoveryContext::default();
        
        let result = coordinator.attempt_recovery(&error, context).await.unwrap();
        
        // Should attempt some form of recovery for network errors
        assert!(!matches!(result, RecoveryResult::NotApplicable));
    }
    
    #[tokio::test]
    async fn test_error_analytics() {
        let analytics = ErrorAnalytics::new();
        
        // Generate test error events
        let events = create_test_error_events(100);
        
        // Analyze patterns
        let report = analytics.analyze_errors(
            TimeRange::last_hour(),
            None
        ).await.unwrap();
        
        assert!(report.total_errors > 0);
        assert!(!report.metrics.is_empty());
    }
}
```

### Integration Tests

```rust
#[tokio::test]
async fn test_end_to_end_error_handling() {
    let error_manager = ErrorManager::new();
    
    // Configure with real strategies
    error_manager.configure_default_strategies().await;
    
    // Simulate a failing operation
    let operation = || async {
        // Simulate network timeout
        Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Connection timeout"))
    };
    
    let context = RetryContext {
        operation_id: Uuid::new_v4(),
        operation_type: "test_operation".to_string(),
        start_time: Utc::now(),
        total_duration: Duration::from_secs(0),
        previous_errors: Vec::new(),
        user_id: None,
        priority: RetryPriority::Normal,
    };
    
    // Execute with retry
    let result = error_manager
        .retry_manager
        .execute_with_retry(operation, "network", context)
        .await;
    
    // Should have attempted retries
    assert!(result.is_err());
    
    // Check that error was classified and recovery attempted
    let metrics = error_manager.get_metrics().await;
    assert!(metrics.total_errors > 0);
    assert!(metrics.retry_attempts > 0);
}

#[tokio::test]
async fn test_circuit_breaker_integration() {
    let error_manager = ErrorManager::new();
    let registry = error_manager.circuit_breakers.clone();
    
    // Execute operations that will trigger circuit breaker
    for i in 0..10 {
        let result = registry.execute_with_breaker(
            "failing_service",
            async {
                if i < 5 {
                    Err(std::io::Error::new(std::io::ErrorKind::Other, "Service error"))
                } else {
                    Ok("Success")
                }
            }
        ).await;
        
        if i < 3 {
            // First few should fail normally
            assert!(result.is_err());
        } else if i < 5 {
            // Circuit should be open, requests rejected
            assert!(matches!(result, Err(CircuitBreakerError::CircuitOpen)));
        }
    }
}
```

### Performance Tests

```rust
#[tokio::test]
async fn benchmark_error_handling_overhead() {
    let error_manager = ErrorManager::new();
    
    // Measure classification overhead
    let start = Instant::now();
    
    for _ in 0..1000 {
        let error = std::io::Error::new(std::io::ErrorKind::Other, "Test error");
        let context = ErrorContext::default();
        
        let _ = error_manager
            .classifier
            .classify_error(&error, context)
            .await
            .unwrap();
    }
    
    let classification_time = start.elapsed();
    println!("1000 error classifications in {:?}", classification_time);
    
    // Should be fast (< 100ms for 1000 classifications)
    assert!(classification_time < Duration::from_millis(100));
}

#[tokio::test]
async fn stress_test_circuit_breakers() {
    let registry = CircuitBreakerRegistry::new();
    
    // Create many concurrent requests
    let handles: Vec<_> = (0..1000)
        .map(|i| {
            let registry = registry.clone();
            tokio::spawn(async move {
                registry.execute_with_breaker(
                    &format!("service_{}", i % 10), // 10 different services
                    async {
                        if rand::random::<f64>() < 0.1 {
                            Err(std::io::Error::new(std::io::ErrorKind::Other, "Random error"))
                        } else {
                            Ok("Success")
                        }
                    }
                ).await
            })
        })
        .collect();
    
    // Wait for all to complete
    let results = futures::future::join_all(handles).await;
    
    // Most should succeed or be rejected by circuit breaker
    let success_count = results.iter()
        .filter(|r| r.as_ref().unwrap().is_ok())
        .count();
    
    println!("Success rate: {:.2}%", success_count as f64 / 1000.0 * 100.0);
    assert!(success_count > 800); // Should have high success rate
}
```

## Dependencies & Integration

### Direct Dependencies
- **Issue 1.2**: Error Handling Foundation
  - Extends basic error types and handling
  - Required for enhanced error classification

- **Issue 2.3**: Advanced Streaming Implementation
  - Integration for real-time error streaming
  - Required for error event notifications

### Integration Points
- **All Systems**: Enhanced error handling throughout
- **Tool System**: Advanced retry for tool execution
- **Workflow System**: Recovery mechanisms for workflows
- **Streaming System**: Real-time error notifications

### API Changes
- Enhanced error response formats
- New retry configuration endpoints
- Circuit breaker status and control APIs
- Error analytics and monitoring dashboards

## Security Considerations

### Error Information Security
- Sanitize error messages to prevent information disclosure
- Control access to detailed error analytics
- Secure error logs and prevent data leakage

### Retry Attack Prevention
- Rate limiting on retry attempts
- Prevention of DoS through excessive retries
- Authentication for retry configuration changes

### Recovery Security
- Secure recovery mechanisms to prevent privilege escalation
- Validation of recovery actions
- Audit trail for all recovery attempts

## Acceptance Criteria

1. **Error Classification**
   - [ ] Automatic categorization of errors with 95% accuracy
   - [ ] User-friendly error messages for common categories
   - [ ] Rich error context and technical details

2. **Advanced Retry Strategies**
   - [ ] Multiple retry strategies with different algorithms
   - [ ] Configurable retry policies per operation type
   - [ ] Retry attempt tracking and metrics

3. **Circuit Breaker Protection**
   - [ ] Automatic circuit breaker activation on failure thresholds
   - [ ] Graceful degradation with fallback mechanisms
   - [ ] Real-time circuit breaker status monitoring

4. **Recovery Mechanisms**
   - [ ] Automated recovery for common error scenarios
   - [ ] Recovery budget management and cost tracking
   - [ ] Recovery success rate optimization

5. **Analytics & Monitoring**
   - [ ] Real-time error pattern detection
   - [ ] Comprehensive error analytics dashboard
   - [ ] Proactive alerting for error rate spikes

6. **Performance**
   - [ ] Error handling overhead < 1ms per error
   - [ ] Support for 10,000+ errors per second
   - [ ] Circuit breaker decision time < 100s

## References

- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html)
- [Retry Patterns](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry)
- [Exponential Backoff](https://cloud.google.com/storage/docs/exponential-backoff)
- [Error Handling Best Practices](https://www.postgresql.org/docs/current/error-handling.html)
- [Resilience Engineering](https://queue.acm.org/detail.cfm?id=2371297)

## Estimated Lines of Code

- Error classification system: ~400 lines
- Advanced retry strategies: ~300 lines
- Circuit breaker implementation: ~250 lines
- Recovery mechanisms: ~250 lines
- Error analytics and monitoring: ~200 lines
- Integration and utilities: ~100 lines

**Total: ~1,500 lines**