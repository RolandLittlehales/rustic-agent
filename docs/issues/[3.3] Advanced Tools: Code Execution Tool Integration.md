# [3.3] Advanced Tools: Code Execution Tool Integration

## Overview

### Current State
- Basic file system tools (read, write, list directory)
- Text editor tool for file modifications (Issue 3.2)
- No code execution capabilities
- Limited to static file operations
- No dynamic code analysis or data processing

### Target State
- Full integration with Anthropic's code_execution_20250522 tool
- Sandboxed Python execution environment with security isolation
- Package management and dependency handling for dynamic imports
- Result visualization and data analysis capabilities
- Multi-format output support (text, images, tables, plots)
- Secure code execution with timeout and resource limits

### Why This Matters
- **Dynamic Analysis**: Enable Claude to execute code and analyze results in real-time
- **Data Processing**: Perform complex data analysis, transformations, and visualizations
- **Prototyping**: Rapid code prototyping and testing without external setup
- **Educational Support**: Interactive code examples and explanations
- **Developer Productivity**: Code validation, testing, and debugging assistance
- **Strategic Value**: Transform from static code editing to dynamic development environment

## Technical Requirements

### 1. Anthropic Code Execution Tool Integration

```rust
use std::collections::HashMap;
use std::sync::Arc;
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use std::time::{Duration, Instant};
use tokio::sync::{RwLock, Mutex};
use tokio::process::{Child, Command as TokioCommand};
use tokio::time::timeout;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;
use base64::{Engine as _, engine::general_purpose};
use image::{ImageBuffer, RgbaImage};

/// Code execution tool implementing Anthropic's code_execution_20250522 specification
#[derive(Debug)]
pub struct CodeExecutionTool {
    /// Python execution environment manager
    python_env: Arc<PythonEnvironmentManager>,
    
    /// Package manager for dependencies
    package_manager: Arc<PythonPackageManager>,
    
    /// Code execution sandbox
    execution_sandbox: Arc<CodeExecutionSandbox>,
    
    /// Result processor for multiple output formats
    result_processor: Arc<ExecutionResultProcessor>,
    
    /// Security enforcer for code validation
    security_enforcer: Arc<CodeExecutionSecurityEnforcer>,
    
    /// Session manager for execution state
    session_manager: Arc<CodeExecutionSessionManager>,
    
    /// Performance monitor for resource tracking
    performance_monitor: Arc<CodeExecutionPerformanceMonitor>,
}

/// Code execution request as defined by Anthropic
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeExecutionRequest {
    /// Programming language (currently Python only)
    pub language: ProgrammingLanguage,
    
    /// Source code to execute
    pub code: String,
    
    /// Optional execution timeout in seconds
    pub timeout: Option<u32>,
    
    /// Optional working directory
    pub working_directory: Option<PathBuf>,
    
    /// Optional environment variables
    pub environment: Option<HashMap<String, String>>,
    
    /// Whether to capture stdout/stderr
    pub capture_output: bool,
    
    /// Whether to return execution result as base64
    pub return_base64: Option<bool>,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum ProgrammingLanguage {
    Python,
    // Future support for other languages
    JavaScript,
    Rust,
    Go,
}

/// Code execution result containing output and metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeExecutionResult {
    /// Exit code of the execution
    pub exit_code: i32,
    
    /// Standard output from execution
    pub stdout: String,
    
    /// Standard error from execution
    pub stderr: String,
    
    /// Base64 encoded binary output (for images, plots, etc.)
    pub base64_output: Option<String>,
    
    /// Execution duration in milliseconds
    pub execution_time_ms: u64,
    
    /// Memory usage during execution
    pub memory_usage_mb: f64,
    
    /// CPU usage percentage
    pub cpu_usage_percent: f64,
    
    /// Files created during execution
    pub created_files: Vec<CreatedFile>,
    
    /// Installed packages during execution
    pub installed_packages: Vec<String>,
    
    /// Security validation results
    pub security_validation: SecurityValidationResult,
    
    /// Performance metrics
    pub performance_metrics: ExecutionPerformanceMetrics,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreatedFile {
    pub path: PathBuf,
    pub size_bytes: u64,
    pub mime_type: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityValidationResult {
    pub allowed: bool,
    pub risk_level: SecurityRiskLevel,
    pub blocked_operations: Vec<String>,
    pub warnings: Vec<String>,
    pub scan_duration_ms: u64,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SecurityRiskLevel {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionPerformanceMetrics {
    pub sandbox_setup_time_ms: u64,
    pub code_validation_time_ms: u64,
    pub execution_time_ms: u64,
    pub result_processing_time_ms: u64,
    pub total_time_ms: u64,
}
```

### 2. Python Environment Manager

```rust
/// Manages isolated Python execution environments
#[derive(Debug)]
pub struct PythonEnvironmentManager {
    /// Base Python interpreter path
    python_executable: PathBuf,
    
    /// Virtual environment directory
    venv_directory: PathBuf,
    
    /// Environment configuration
    config: PythonEnvironmentConfig,
    
    /// Active virtual environments
    active_environments: Arc<RwLock<HashMap<String, VirtualEnvironment>>>,
    
    /// Environment lock for concurrent access
    environment_lock: Arc<Mutex<()>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PythonEnvironmentConfig {
    /// Python version requirement
    pub python_version: String,
    
    /// Maximum execution time per code block
    pub max_execution_time_seconds: u32,
    
    /// Maximum memory usage in MB
    pub max_memory_mb: u64,
    
    /// Maximum disk usage in MB
    pub max_disk_usage_mb: u64,
    
    /// Allowed built-in modules
    pub allowed_builtins: Vec<String>,
    
    /// Blocked modules for security
    pub blocked_modules: Vec<String>,
    
    /// Pre-installed packages
    pub preinstalled_packages: Vec<String>,
}

#[derive(Debug)]
pub struct VirtualEnvironment {
    /// Unique environment identifier
    pub id: String,
    
    /// Environment path
    pub path: PathBuf,
    
    /// Python executable in this environment
    pub python_executable: PathBuf,
    
    /// Installed packages
    pub installed_packages: Arc<RwLock<HashMap<String, String>>>,
    
    /// Environment state
    pub state: EnvironmentState,
    
    /// Creation timestamp
    pub created_at: chrono::DateTime<chrono::Utc>,
    
    /// Last used timestamp
    pub last_used: Arc<RwLock<chrono::DateTime<chrono::Utc>>>,
}

#[derive(Debug, Clone, Copy)]
pub enum EnvironmentState {
    Creating,
    Ready,
    InUse,
    Error,
    Cleanup,
}

impl PythonEnvironmentManager {
    pub fn new(config: PythonEnvironmentConfig) -> ClaudeResult<Self> {
        let python_executable = Self::find_python_executable()?;
        let venv_directory = Self::setup_venv_directory()?;
        
        Ok(Self {
            python_executable,
            venv_directory,
            config,
            active_environments: Arc::new(RwLock::new(HashMap::new())),
            environment_lock: Arc::new(Mutex::new(())),
        })
    }
    
    /// Create a new isolated virtual environment
    pub async fn create_environment(&self) -> ClaudeResult<String> {
        let _lock = self.environment_lock.lock().await;
        
        let env_id = format!("env_{}", Uuid::new_v4().to_string()[..8]);
        let env_path = self.venv_directory.join(&env_id);
        
        // Create virtual environment
        let output = TokioCommand::new(&self.python_executable)
            .args(&["-m", "venv", env_path.to_str().unwrap()])
            .output()
            .await
            .map_err(|e| ClaudeError::CodeExecutionError {
                message: format!("Failed to create virtual environment: {}", e),
                code: None,
                context: None,
            })?;
        
        if !output.status.success() {
            return Err(ClaudeError::CodeExecutionError {
                message: format!("Virtual environment creation failed: {}", 
                    String::from_utf8_lossy(&output.stderr)),
                code: None,
                context: None,
            });
        }
        
        // Setup environment
        let python_executable = env_path.join("bin").join("python");
        let venv = VirtualEnvironment {
            id: env_id.clone(),
            path: env_path,
            python_executable,
            installed_packages: Arc::new(RwLock::new(HashMap::new())),
            state: EnvironmentState::Ready,
            created_at: chrono::Utc::now(),
            last_used: Arc::new(RwLock::new(chrono::Utc::now())),
        };
        
        // Install pre-configured packages
        self.install_preinstalled_packages(&venv).await?;
        
        // Register environment
        let mut environments = self.active_environments.write().await;
        environments.insert(env_id.clone(), venv);
        
        Ok(env_id)
    }
    
    /// Get or create an environment for execution
    pub async fn get_environment(&self, env_id: Option<String>) -> ClaudeResult<String> {
        if let Some(id) = env_id {
            let environments = self.active_environments.read().await;
            if environments.contains_key(&id) {
                return Ok(id);
            }
        }
        
        // Create new environment
        self.create_environment().await
    }
    
    /// Execute code in specified environment
    pub async fn execute_code(&self, env_id: &str, code: &str, timeout: Duration) -> ClaudeResult<CodeExecutionResult> {
        let environment = {
            let environments = self.active_environments.read().await;
            environments.get(env_id)
                .ok_or_else(|| ClaudeError::CodeExecutionError {
                    message: format!("Environment {} not found", env_id),
                    code: None,
                    context: None,
                })?
                .clone()
        };
        
        // Update last used timestamp
        {
            let mut last_used = environment.last_used.write().await;
            *last_used = chrono::Utc::now();
        }
        
        let start_time = Instant::now();
        
        // Create temporary script file
        let script_path = environment.path.join(format!("script_{}.py", Uuid::new_v4()));
        tokio::fs::write(&script_path, code).await
            .map_err(|e| ClaudeError::CodeExecutionError {
                message: format!("Failed to write script: {}", e),
                code: Some(code.to_string()),
                context: None,
            })?;
        
        // Execute with timeout
        let execution_result = timeout(timeout, async {
            TokioCommand::new(&environment.python_executable)
                .arg(&script_path)
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .output()
                .await
        }).await;
        
        // Clean up script file
        let _ = tokio::fs::remove_file(&script_path).await;
        
        let execution_time = start_time.elapsed();
        
        match execution_result {
            Ok(Ok(output)) => Ok(CodeExecutionResult {
                exit_code: output.status.code().unwrap_or(-1),
                stdout: String::from_utf8_lossy(&output.stdout).to_string(),
                stderr: String::from_utf8_lossy(&output.stderr).to_string(),
                base64_output: None,
                execution_time_ms: execution_time.as_millis() as u64,
                memory_usage_mb: 0.0, // TODO: Implement memory tracking
                cpu_usage_percent: 0.0, // TODO: Implement CPU tracking
                created_files: Vec::new(),
                installed_packages: Vec::new(),
                security_validation: SecurityValidationResult {
                    allowed: true,
                    risk_level: SecurityRiskLevel::Low,
                    blocked_operations: Vec::new(),
                    warnings: Vec::new(),
                    scan_duration_ms: 0,
                },
                performance_metrics: ExecutionPerformanceMetrics {
                    sandbox_setup_time_ms: 0,
                    code_validation_time_ms: 0,
                    execution_time_ms: execution_time.as_millis() as u64,
                    result_processing_time_ms: 0,
                    total_time_ms: execution_time.as_millis() as u64,
                },
            }),
            Ok(Err(e)) => Err(ClaudeError::CodeExecutionError {
                message: format!("Execution failed: {}", e),
                code: Some(code.to_string()),
                context: None,
            }),
            Err(_) => Err(ClaudeError::CodeExecutionError {
                message: "Execution timed out".to_string(),
                code: Some(code.to_string()),
                context: None,
            }),
        }
    }
    
    fn find_python_executable() -> ClaudeResult<PathBuf> {
        // Try common Python paths
        let candidates = vec!["python3", "python", "/usr/bin/python3", "/usr/local/bin/python3"];
        
        for candidate in candidates {
            if let Ok(output) = std::process::Command::new(candidate)
                .args(&["--version"])
                .output() {
                if output.status.success() {
                    return Ok(PathBuf::from(candidate));
                }
            }
        }
        
        Err(ClaudeError::ConfigError {
            message: "Python executable not found".to_string(),
            context: None,
        })
    }
    
    fn setup_venv_directory() -> ClaudeResult<PathBuf> {
        let venv_dir = std::env::temp_dir().join("claude_venvs");
        std::fs::create_dir_all(&venv_dir)
            .map_err(|e| ClaudeError::CodeExecutionError {
                message: format!("Failed to create venv directory: {}", e),
                code: None,
                context: None,
            })?;
        Ok(venv_dir)
    }
    
    async fn install_preinstalled_packages(&self, env: &VirtualEnvironment) -> ClaudeResult<()> {
        for package in &self.config.preinstalled_packages {
            let output = TokioCommand::new(&env.python_executable)
                .args(&["-m", "pip", "install", package])
                .output()
                .await
                .map_err(|e| ClaudeError::CodeExecutionError {
                    message: format!("Failed to install package {}: {}", package, e),
                    code: None,
                    context: None,
                })?;
            
            if !output.status.success() {
                eprintln!("Warning: Failed to install package {}: {}", 
                    package, String::from_utf8_lossy(&output.stderr));
            }
        }
        Ok(())
    }
}
```

### 3. Package Manager

```rust
/// Manages Python package installation and dependencies
#[derive(Debug)]
pub struct PythonPackageManager {
    /// Package cache directory
    cache_directory: PathBuf,
    
    /// Package installation policy
    installation_policy: PackageInstallationPolicy,
    
    /// Security scanner for packages
    security_scanner: Arc<PackageSecurityScanner>,
    
    /// Dependency resolver
    dependency_resolver: Arc<DependencyResolver>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageInstallationPolicy {
    /// Allow automatic package installation
    pub auto_install: bool,
    
    /// Maximum packages per session
    pub max_packages_per_session: u32,
    
    /// Allowed package sources
    pub allowed_sources: Vec<String>,
    
    /// Blocked packages
    pub blocked_packages: Vec<String>,
    
    /// Size limit for packages in MB
    pub max_package_size_mb: u64,
}

#[derive(Debug)]
pub struct PackageSecurityScanner {
    /// Known malicious packages
    malicious_packages: Arc<RwLock<HashSet<String>>>,
    
    /// Package reputation database
    reputation_db: Arc<RwLock<HashMap<String, PackageReputation>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageReputation {
    pub score: f64, // 0.0 to 1.0
    pub download_count: u64,
    pub last_updated: chrono::DateTime<chrono::Utc>,
    pub maintainer_reputation: f64,
}

impl PythonPackageManager {
    pub fn new(config: PackageInstallationPolicy) -> ClaudeResult<Self> {
        let cache_directory = std::env::temp_dir().join("claude_package_cache");
        std::fs::create_dir_all(&cache_directory)
            .map_err(|e| ClaudeError::CodeExecutionError {
                message: format!("Failed to create package cache: {}", e),
                code: None,
                context: None,
            })?;
        
        Ok(Self {
            cache_directory,
            installation_policy: config,
            security_scanner: Arc::new(PackageSecurityScanner::new()),
            dependency_resolver: Arc::new(DependencyResolver::new()),
        })
    }
    
    /// Install package in specified environment
    pub async fn install_package(&self, env_id: &str, package_name: &str, env: &VirtualEnvironment) -> ClaudeResult<PackageInstallationResult> {
        // Security validation
        self.security_scanner.validate_package(package_name).await?;
        
        // Check installation policy
        if self.installation_policy.blocked_packages.contains(&package_name.to_string()) {
            return Err(ClaudeError::CodeExecutionError {
                message: format!("Package {} is blocked by policy", package_name),
                code: None,
                context: None,
            });
        }
        
        let start_time = Instant::now();
        
        // Install package
        let output = TokioCommand::new(&env.python_executable)
            .args(&["-m", "pip", "install", package_name, "--cache-dir", 
                self.cache_directory.to_str().unwrap()])
            .output()
            .await
            .map_err(|e| ClaudeError::CodeExecutionError {
                message: format!("Failed to install package {}: {}", package_name, e),
                code: None,
                context: None,
            })?;
        
        let installation_time = start_time.elapsed();
        
        if output.status.success() {
            // Update package registry
            let mut packages = env.installed_packages.write().await;
            packages.insert(package_name.to_string(), "latest".to_string());
            
            Ok(PackageInstallationResult {
                package_name: package_name.to_string(),
                version: "latest".to_string(),
                success: true,
                installation_time_ms: installation_time.as_millis() as u64,
                dependencies: Vec::new(), // TODO: Parse dependencies
                size_bytes: 0, // TODO: Calculate package size
                error: None,
            })
        } else {
            Err(ClaudeError::CodeExecutionError {
                message: format!("Package installation failed: {}", 
                    String::from_utf8_lossy(&output.stderr)),
                code: None,
                context: None,
            })
        }
    }
    
    /// Get installed packages in environment
    pub async fn list_installed_packages(&self, env: &VirtualEnvironment) -> ClaudeResult<Vec<InstalledPackage>> {
        let output = TokioCommand::new(&env.python_executable)
            .args(&["-m", "pip", "list", "--format=json"])
            .output()
            .await
            .map_err(|e| ClaudeError::CodeExecutionError {
                message: format!("Failed to list packages: {}", e),
                code: None,
                context: None,
            })?;
        
        if output.status.success() {
            let packages: Vec<InstalledPackage> = serde_json::from_slice(&output.stdout)
                .map_err(|e| ClaudeError::JsonError(e))?;
            Ok(packages)
        } else {
            Err(ClaudeError::CodeExecutionError {
                message: format!("Failed to list packages: {}", 
                    String::from_utf8_lossy(&output.stderr)),
                code: None,
                context: None,
            })
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageInstallationResult {
    pub package_name: String,
    pub version: String,
    pub success: bool,
    pub installation_time_ms: u64,
    pub dependencies: Vec<String>,
    pub size_bytes: u64,
    pub error: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InstalledPackage {
    pub name: String,
    pub version: String,
}
```

### 4. Execution Sandbox

```rust
/// Provides secure sandbox for code execution
#[derive(Debug)]
pub struct CodeExecutionSandbox {
    /// Sandbox configuration
    config: SandboxConfig,
    
    /// Resource monitor
    resource_monitor: Arc<ResourceMonitor>,
    
    /// File system isolation
    filesystem_isolation: Arc<FilesystemIsolation>,
    
    /// Network isolation
    network_isolation: Arc<NetworkIsolation>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxConfig {
    /// Maximum execution time
    pub max_execution_time_seconds: u32,
    
    /// Maximum memory usage in MB
    pub max_memory_mb: u64,
    
    /// Maximum CPU usage percentage
    pub max_cpu_percent: f64,
    
    /// Maximum disk usage in MB
    pub max_disk_usage_mb: u64,
    
    /// Allow network access
    pub allow_network: bool,
    
    /// Allow file system access outside sandbox
    pub allow_external_files: bool,
    
    /// Blocked system calls
    pub blocked_syscalls: Vec<String>,
}

#[derive(Debug)]
pub struct ResourceMonitor {
    /// Process monitoring state
    monitoring_state: Arc<RwLock<MonitoringState>>,
}

#[derive(Debug, Clone)]
pub struct MonitoringState {
    pub memory_usage_mb: f64,
    pub cpu_usage_percent: f64,
    pub disk_usage_mb: f64,
    pub network_bytes_sent: u64,
    pub network_bytes_received: u64,
    pub open_file_count: u32,
}

impl CodeExecutionSandbox {
    pub fn new(config: SandboxConfig) -> Self {
        Self {
            config,
            resource_monitor: Arc::new(ResourceMonitor::new()),
            filesystem_isolation: Arc::new(FilesystemIsolation::new()),
            network_isolation: Arc::new(NetworkIsolation::new()),
        }
    }
    
    /// Execute code with sandbox restrictions
    pub async fn execute_sandboxed(&self, request: CodeExecutionRequest) -> ClaudeResult<CodeExecutionResult> {
        // Validate code before execution
        self.validate_code(&request.code).await?;
        
        // Setup sandbox environment
        let sandbox_env = self.setup_sandbox_environment(&request).await?;
        
        // Start resource monitoring
        let monitoring_handle = self.resource_monitor.start_monitoring().await;
        
        let start_time = Instant::now();
        
        // Execute code with restrictions
        let result = self.execute_with_restrictions(&request, &sandbox_env).await;
        
        // Stop monitoring
        self.resource_monitor.stop_monitoring(monitoring_handle).await;
        
        // Cleanup sandbox
        self.cleanup_sandbox_environment(sandbox_env).await?;
        
        let total_time = start_time.elapsed();
        
        // Process and return result
        match result {
            Ok(mut exec_result) => {
                exec_result.performance_metrics.total_time_ms = total_time.as_millis() as u64;
                Ok(exec_result)
            }
            Err(e) => Err(e),
        }
    }
    
    async fn validate_code(&self, code: &str) -> ClaudeResult<()> {
        // Check for dangerous operations
        let dangerous_patterns = vec![
            "import os",
            "import subprocess",
            "import sys",
            "__import__",
            "eval(",
            "exec(",
            "compile(",
            "open(",
            "file(",
        ];
        
        for pattern in dangerous_patterns {
            if code.contains(pattern) {
                return Err(ClaudeError::CodeExecutionError {
                    message: format!("Potentially dangerous operation detected: {}", pattern),
                    code: Some(code.to_string()),
                    context: None,
                });
            }
        }
        
        Ok(())
    }
    
    async fn setup_sandbox_environment(&self, request: &CodeExecutionRequest) -> ClaudeResult<SandboxEnvironment> {
        let sandbox_id = Uuid::new_v4().to_string();
        let sandbox_dir = std::env::temp_dir().join(format!("claude_sandbox_{}", sandbox_id));
        
        std::fs::create_dir_all(&sandbox_dir)
            .map_err(|e| ClaudeError::CodeExecutionError {
                message: format!("Failed to create sandbox directory: {}", e),
                code: None,
                context: None,
            })?;
        
        Ok(SandboxEnvironment {
            id: sandbox_id,
            directory: sandbox_dir,
            created_at: chrono::Utc::now(),
        })
    }
    
    async fn execute_with_restrictions(&self, request: &CodeExecutionRequest, sandbox: &SandboxEnvironment) -> ClaudeResult<CodeExecutionResult> {
        // This is a simplified implementation
        // In production, this would use proper sandboxing technologies like containers or chroot
        
        let script_path = sandbox.directory.join("script.py");
        tokio::fs::write(&script_path, &request.code).await
            .map_err(|e| ClaudeError::CodeExecutionError {
                message: format!("Failed to write script: {}", e),
                code: Some(request.code.clone()),
                context: None,
            })?;
        
        let timeout_duration = Duration::from_secs(
            request.timeout.unwrap_or(self.config.max_execution_time_seconds) as u64
        );
        
        let start_time = Instant::now();
        
        let execution_result = timeout(timeout_duration, async {
            TokioCommand::new("python3")
                .arg(&script_path)
                .current_dir(&sandbox.directory)
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .output()
                .await
        }).await;
        
        let execution_time = start_time.elapsed();
        
        match execution_result {
            Ok(Ok(output)) => Ok(CodeExecutionResult {
                exit_code: output.status.code().unwrap_or(-1),
                stdout: String::from_utf8_lossy(&output.stdout).to_string(),
                stderr: String::from_utf8_lossy(&output.stderr).to_string(),
                base64_output: None,
                execution_time_ms: execution_time.as_millis() as u64,
                memory_usage_mb: 0.0,
                cpu_usage_percent: 0.0,
                created_files: self.scan_created_files(&sandbox.directory).await?,
                installed_packages: Vec::new(),
                security_validation: SecurityValidationResult {
                    allowed: true,
                    risk_level: SecurityRiskLevel::Low,
                    blocked_operations: Vec::new(),
                    warnings: Vec::new(),
                    scan_duration_ms: 0,
                },
                performance_metrics: ExecutionPerformanceMetrics {
                    sandbox_setup_time_ms: 0,
                    code_validation_time_ms: 0,
                    execution_time_ms: execution_time.as_millis() as u64,
                    result_processing_time_ms: 0,
                    total_time_ms: execution_time.as_millis() as u64,
                },
            }),
            Ok(Err(e)) => Err(ClaudeError::CodeExecutionError {
                message: format!("Execution failed: {}", e),
                code: Some(request.code.clone()),
                context: None,
            }),
            Err(_) => Err(ClaudeError::CodeExecutionError {
                message: "Execution timed out".to_string(),
                code: Some(request.code.clone()),
                context: None,
            }),
        }
    }
    
    async fn scan_created_files(&self, directory: &Path) -> ClaudeResult<Vec<CreatedFile>> {
        let mut created_files = Vec::new();
        
        let mut entries = tokio::fs::read_dir(directory).await
            .map_err(|e| ClaudeError::CodeExecutionError {
                message: format!("Failed to scan directory: {}", e),
                code: None,
                context: None,
            })?;
        
        while let Some(entry) = entries.next_entry().await
            .map_err(|e| ClaudeError::CodeExecutionError {
                message: format!("Failed to read directory entry: {}", e),
                code: None,
                context: None,
            })? {
            
            let path = entry.path();
            if path.is_file() && path.file_name().unwrap_or_default() != "script.py" {
                let metadata = entry.metadata().await
                    .map_err(|e| ClaudeError::CodeExecutionError {
                        message: format!("Failed to read file metadata: {}", e),
                        code: None,
                        context: None,
                    })?;
                
                created_files.push(CreatedFile {
                    path: path.clone(),
                    size_bytes: metadata.len(),
                    mime_type: Self::detect_mime_type(&path),
                    created_at: chrono::Utc::now(),
                });
            }
        }
        
        Ok(created_files)
    }
    
    fn detect_mime_type(path: &Path) -> String {
        match path.extension().and_then(|ext| ext.to_str()) {
            Some("png") => "image/png".to_string(),
            Some("jpg") | Some("jpeg") => "image/jpeg".to_string(),
            Some("gif") => "image/gif".to_string(),
            Some("svg") => "image/svg+xml".to_string(),
            Some("txt") => "text/plain".to_string(),
            Some("json") => "application/json".to_string(),
            Some("csv") => "text/csv".to_string(),
            _ => "application/octet-stream".to_string(),
        }
    }
    
    async fn cleanup_sandbox_environment(&self, sandbox: SandboxEnvironment) -> ClaudeResult<()> {
        tokio::fs::remove_dir_all(&sandbox.directory).await
            .map_err(|e| ClaudeError::CodeExecutionError {
                message: format!("Failed to cleanup sandbox: {}", e),
                code: None,
                context: None,
            })?;
        
        Ok(())
    }
}

#[derive(Debug)]
pub struct SandboxEnvironment {
    pub id: String,
    pub directory: PathBuf,
    pub created_at: chrono::DateTime<chrono::Utc>,
}
```

### 5. Tool Implementation

```rust
use async_trait::async_trait;
use crate::claude::{
    tools::{AgentTool, ToolResult},
    types::ContentBlock,
    error::{ClaudeError, ClaudeResult},
    whitelist::WhitelistConfig,
};

/// Code execution tool implementation
#[derive(Debug)]
pub struct CodeExecutionAgentTool {
    /// Code execution engine
    execution_engine: Arc<CodeExecutionTool>,
    
    /// Whitelist configuration
    whitelist: Option<Arc<RwLock<WhitelistConfig>>>,
    
    /// Tool configuration
    config: CodeExecutionToolConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeExecutionToolConfig {
    /// Enable code execution
    pub enabled: bool,
    
    /// Maximum execution time per request
    pub max_execution_time_seconds: u32,
    
    /// Maximum concurrent executions
    pub max_concurrent_executions: u32,
    
    /// Enable package installation
    pub enable_package_installation: bool,
    
    /// Default Python environment settings
    pub default_environment: PythonEnvironmentConfig,
    
    /// Sandbox configuration
    pub sandbox_config: SandboxConfig,
}

#[async_trait]
impl AgentTool for CodeExecutionAgentTool {
    fn name(&self) -> &'static str {
        "code_execution"
    }
    
    fn description(&self) -> &'static str {
        "Execute Python code in a secure sandboxed environment with package management support"
    }
    
    fn parameters(&self) -> serde_json::Value {
        json!({
            "type": "object",
            "properties": {
                "language": {
                    "type": "string",
                    "enum": ["python"],
                    "description": "Programming language to execute (currently only Python is supported)"
                },
                "code": {
                    "type": "string",
                    "description": "Python code to execute"
                },
                "timeout": {
                    "type": "integer",
                    "description": "Optional execution timeout in seconds (default: 30)",
                    "minimum": 1,
                    "maximum": 300
                },
                "install_packages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional list of packages to install before execution"
                },
                "working_directory": {
                    "type": "string",
                    "description": "Optional working directory for execution (must be within whitelist)"
                },
                "capture_output": {
                    "type": "boolean",
                    "description": "Whether to capture stdout/stderr (default: true)"
                },
                "return_base64": {
                    "type": "boolean",
                    "description": "Whether to return binary output as base64 (default: false)"
                }
            },
            "required": ["language", "code"],
            "additionalProperties": false
        })
    }
    
    async fn execute(&self, input: serde_json::Value) -> ToolResult {
        if !self.config.enabled {
            return ToolResult::error("Code execution is disabled");
        }
        
        // Parse input parameters
        let language = input["language"].as_str()
            .ok_or_else(|| "Missing required parameter: language")?;
        
        if language != "python" {
            return ToolResult::error("Only Python code execution is currently supported");
        }
        
        let code = input["code"].as_str()
            .ok_or_else(|| "Missing required parameter: code")?;
        
        let timeout = input["timeout"].as_u64()
            .unwrap_or(self.config.max_execution_time_seconds as u64) as u32;
        
        let install_packages = input["install_packages"].as_array()
            .map(|arr| arr.iter()
                .filter_map(|v| v.as_str())
                .map(|s| s.to_string())
                .collect::<Vec<_>>())
            .unwrap_or_default();
        
        let working_directory = input["working_directory"].as_str()
            .map(PathBuf::from);
        
        let capture_output = input["capture_output"].as_bool().unwrap_or(true);
        let return_base64 = input["return_base64"].as_bool().unwrap_or(false);
        
        // Validate working directory against whitelist
        if let Some(ref wd) = working_directory {
            if let Some(ref whitelist) = self.whitelist {
                let whitelist_guard = whitelist.read().await;
                if !whitelist_guard.is_path_allowed(wd) {
                    return ToolResult::error("Working directory not allowed by whitelist");
                }
            }
        }
        
        // Create execution request
        let request = CodeExecutionRequest {
            language: ProgrammingLanguage::Python,
            code: code.to_string(),
            timeout: Some(timeout),
            working_directory,
            environment: None,
            capture_output,
            return_base64: Some(return_base64),
        };
        
        // Execute code
        match self.execute_code_with_packages(request, install_packages).await {
            Ok(result) => {
                let mut response = json!({
                    "exit_code": result.exit_code,
                    "execution_time_ms": result.execution_time_ms,
                    "success": result.exit_code == 0
                });
                
                if capture_output {
                    response["stdout"] = json!(result.stdout);
                    response["stderr"] = json!(result.stderr);
                }
                
                if let Some(base64_output) = result.base64_output {
                    response["base64_output"] = json!(base64_output);
                }
                
                if !result.created_files.is_empty() {
                    response["created_files"] = json!(result.created_files);
                }
                
                if !result.installed_packages.is_empty() {
                    response["installed_packages"] = json!(result.installed_packages);
                }
                
                response["performance_metrics"] = json!(result.performance_metrics);
                
                ToolResult::success(response)
            }
            Err(e) => ToolResult::error(&format!("Code execution failed: {}", e)),
        }
    }
    
    fn set_whitelist(&mut self, whitelist: Arc<RwLock<WhitelistConfig>>) {
        self.whitelist = Some(whitelist);
    }
}

impl CodeExecutionAgentTool {
    pub fn new(config: CodeExecutionToolConfig) -> ClaudeResult<Self> {
        let python_env_config = config.default_environment.clone();
        let sandbox_config = config.sandbox_config.clone();
        
        let python_env_manager = Arc::new(PythonEnvironmentManager::new(python_env_config)?);
        let package_manager = Arc::new(PythonPackageManager::new(PackageInstallationPolicy {
            auto_install: config.enable_package_installation,
            max_packages_per_session: 50,
            allowed_sources: vec!["https://pypi.org".to_string()],
            blocked_packages: vec![
                "os".to_string(),
                "subprocess".to_string(),
                "sys".to_string(),
            ],
            max_package_size_mb: 100,
        })?);
        
        let execution_sandbox = Arc::new(CodeExecutionSandbox::new(sandbox_config));
        
        let execution_engine = Arc::new(CodeExecutionTool {
            python_env: python_env_manager,
            package_manager,
            execution_sandbox,
            result_processor: Arc::new(ExecutionResultProcessor::new()),
            security_enforcer: Arc::new(CodeExecutionSecurityEnforcer::new()),
            session_manager: Arc::new(CodeExecutionSessionManager::new()),
            performance_monitor: Arc::new(CodeExecutionPerformanceMonitor::new()),
        });
        
        Ok(Self {
            execution_engine,
            whitelist: None,
            config,
        })
    }
    
    async fn execute_code_with_packages(
        &self,
        request: CodeExecutionRequest,
        packages: Vec<String>,
    ) -> ClaudeResult<CodeExecutionResult> {
        // Get or create environment
        let env_id = self.execution_engine.python_env.get_environment(None).await?;
        
        // Install packages if requested
        if !packages.is_empty() && self.config.enable_package_installation {
            let environments = self.execution_engine.python_env.active_environments.read().await;
            if let Some(env) = environments.get(&env_id) {
                for package in &packages {
                    self.execution_engine.package_manager
                        .install_package(&env_id, package, env).await?;
                }
            }
        }
        
        // Execute code in sandbox
        self.execution_engine.execution_sandbox.execute_sandboxed(request).await
    }
}

/// Error types specific to code execution
#[derive(Debug)]
pub enum CodeExecutionError {
    EnvironmentSetupFailed(String),
    PackageInstallationFailed(String),
    ExecutionTimeout,
    SecurityViolation(String),
    ResourceLimitExceeded(String),
}

impl std::fmt::Display for CodeExecutionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CodeExecutionError::EnvironmentSetupFailed(msg) => 
                write!(f, "Environment setup failed: {}", msg),
            CodeExecutionError::PackageInstallationFailed(msg) => 
                write!(f, "Package installation failed: {}", msg),
            CodeExecutionError::ExecutionTimeout => 
                write!(f, "Code execution timed out"),
            CodeExecutionError::SecurityViolation(msg) => 
                write!(f, "Security violation: {}", msg),
            CodeExecutionError::ResourceLimitExceeded(msg) => 
                write!(f, "Resource limit exceeded: {}", msg),
        }
    }
}

impl std::error::Error for CodeExecutionError {}
```

## Architecture Changes

### 1. Current vs. Target Architecture

**Current Architecture:**
```
File System Tools
    ↓
Static File Operations
    ↓
Text Editor Tool (3.2)
    ↓
Manual Code Review
```

**Target Architecture:**
```
File System Tools
    ↓
Text Editor Tool (3.2)
    ↓
Code Execution Tool (3.3)
    ↓
Dynamic Code Analysis
    ↓
Result Visualization
    ↓
Iterative Development Loop
```

### 2. File Structure Changes

**New Files:**
- `src-tauri/src/claude/tools/code_execution/` - Code execution tool module
  - `mod.rs` - Module exports and configuration
  - `python_env.rs` - Python environment management
  - `package_manager.rs` - Package installation and management
  - `sandbox.rs` - Execution sandbox implementation
  - `security.rs` - Security enforcement and validation
  - `result_processor.rs` - Result processing and visualization
- `src-tauri/src/claude/tools/code_execution_tool.rs` - Tool implementation

**Modified Files:**
- `src-tauri/src/claude/tools/mod.rs` - Register code execution tool
- `src-tauri/src/claude/error.rs` - Add code execution error types
- `src-tauri/src/main.rs` - Add code execution Tauri commands
- `ui/js/app.js` - Add code execution UI components

### 3. Integration Points

**Text Editor Integration:**
```rust
// Integration with Issue 3.2 Text Editor Tool
pub struct CodeExecutionWorkflow {
    text_editor: Arc<TextEditorTool>,
    code_executor: Arc<CodeExecutionTool>,
}

impl CodeExecutionWorkflow {
    pub async fn edit_and_execute(&self, file_path: &Path, modifications: Vec<TextEdit>) -> ClaudeResult<CodeExecutionResult> {
        // Use text editor to modify code
        self.text_editor.apply_edits(file_path, modifications).await?;
        
        // Read modified code
        let code = tokio::fs::read_to_string(file_path).await?;
        
        // Execute modified code
        let request = CodeExecutionRequest {
            language: ProgrammingLanguage::Python,
            code,
            working_directory: Some(file_path.parent().unwrap().to_path_buf()),
            // ... other parameters
        };
        
        self.code_executor.execution_sandbox.execute_sandboxed(request).await
    }
}
```

## Implementation Plan

### Phase 1: Core Infrastructure (Week 1-2)
**Target: ~400 LOC**

1. **Basic Python Environment Setup** (3 days)
   - Implement `PythonEnvironmentManager`
   - Virtual environment creation and management
   - Basic Python executable detection
   
2. **Simple Code Execution** (2 days)
   - Basic code execution without sandbox
   - Stdout/stderr capture
   - Timeout implementation

3. **Error Handling Integration** (2 days)
   - Add code execution error types
   - Integrate with unified error framework
   - Basic error recovery

### Phase 2: Package Management (Week 2-3)
**Target: ~300 LOC**

1. **Package Manager Implementation** (3 days)
   - Implement `PythonPackageManager`
   - Package installation and validation
   - Dependency resolution basics

2. **Security Scanner** (2 days)
   - Package security validation
   - Malicious package detection
   - Installation policies

3. **Package Integration** (2 days)
   - Integrate package manager with environment
   - Dynamic package installation
   - Package lifecycle management

### Phase 3: Execution Sandbox (Week 3-4)
**Target: ~400 LOC**

1. **Sandbox Infrastructure** (3 days)
   - Implement `CodeExecutionSandbox`
   - File system isolation
   - Resource monitoring

2. **Security Enforcement** (2 days)
   - Code validation and scanning
   - Dangerous operation detection
   - Execution restrictions

3. **Resource Management** (2 days)
   - Memory and CPU monitoring
   - Disk usage tracking
   - Resource limit enforcement

### Phase 4: Tool Integration (Week 4-5)
**Target: ~300 LOC**

1. **AgentTool Implementation** (2 days)
   - Implement `CodeExecutionAgentTool`
   - Parameter validation
   - Result formatting

2. **Tauri Command Integration** (2 days)
   - Add Tauri commands for code execution
   - Frontend integration
   - Error handling

3. **Text Editor Workflow** (1 day)
   - Integrate with Issue 3.2 text editor
   - Edit-and-execute workflows
   - Result feedback loops

### Phase 5: Result Processing (Week 5-6)
**Target: ~200 LOC**

1. **Result Processor** (2 days)
   - Implement output format detection
   - Base64 encoding for binary data
   - File creation tracking

2. **Visualization Support** (2 days)
   - Image output handling
   - Plot and chart detection
   - Data format processing

3. **Performance Optimization** (1 day)
   - Execution performance tuning
   - Memory usage optimization
   - Concurrent execution support

### Phase 6: Testing and Documentation (Week 6)
**Target: ~100 LOC + Documentation**

1. **Comprehensive Testing** (3 days)
   - Unit tests for all components
   - Integration tests with text editor
   - Security validation tests

2. **Documentation** (1 day)
   - API documentation
   - Usage examples
   - Security guidelines

3. **Performance Validation** (1 day)
   - Performance benchmarks
   - Resource usage validation
   - Concurrent execution tests

## Testing Strategy

### 1. Unit Tests (300 LOC)

#### Python Environment Tests
```rust
#[cfg(test)]
mod python_env_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_environment_creation() {
        let config = PythonEnvironmentConfig::default();
        let manager = PythonEnvironmentManager::new(config).unwrap();
        
        let env_id = manager.create_environment().await.unwrap();
        assert!(!env_id.is_empty());
        
        let environments = manager.active_environments.read().await;
        assert!(environments.contains_key(&env_id));
    }
    
    #[tokio::test]
    async fn test_code_execution() {
        let config = PythonEnvironmentConfig::default();
        let manager = PythonEnvironmentManager::new(config).unwrap();
        let env_id = manager.create_environment().await.unwrap();
        
        let code = "print('Hello, World!')";
        let result = manager.execute_code(&env_id, code, Duration::from_secs(10)).await.unwrap();
        
        assert_eq!(result.exit_code, 0);
        assert_eq!(result.stdout.trim(), "Hello, World!");
        assert!(result.stderr.is_empty());
    }
    
    #[tokio::test]
    async fn test_execution_timeout() {
        let config = PythonEnvironmentConfig::default();
        let manager = PythonEnvironmentManager::new(config).unwrap();
        let env_id = manager.create_environment().await.unwrap();
        
        let code = "import time; time.sleep(60)";
        let result = manager.execute_code(&env_id, code, Duration::from_secs(1)).await;
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("timeout"));
    }
}
```

#### Package Manager Tests
```rust
#[cfg(test)]
mod package_manager_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_package_installation() {
        let policy = PackageInstallationPolicy {
            auto_install: true,
            max_packages_per_session: 10,
            allowed_sources: vec!["https://pypi.org".to_string()],
            blocked_packages: vec!["os".to_string()],
            max_package_size_mb: 100,
        };
        
        let manager = PythonPackageManager::new(policy).unwrap();
        
        // Create test environment
        let config = PythonEnvironmentConfig::default();
        let env_manager = PythonEnvironmentManager::new(config).unwrap();
        let env_id = env_manager.create_environment().await.unwrap();
        
        let environments = env_manager.active_environments.read().await;
        let env = environments.get(&env_id).unwrap();
        
        // Test package installation
        let result = manager.install_package(&env_id, "requests", env).await.unwrap();
        assert!(result.success);
        assert_eq!(result.package_name, "requests");
    }
    
    #[tokio::test]
    async fn test_blocked_package() {
        let policy = PackageInstallationPolicy {
            auto_install: true,
            max_packages_per_session: 10,
            allowed_sources: vec!["https://pypi.org".to_string()],
            blocked_packages: vec!["dangerous-package".to_string()],
            max_package_size_mb: 100,
        };
        
        let manager = PythonPackageManager::new(policy).unwrap();
        
        // Create test environment
        let config = PythonEnvironmentConfig::default();
        let env_manager = PythonEnvironmentManager::new(config).unwrap();
        let env_id = env_manager.create_environment().await.unwrap();
        
        let environments = env_manager.active_environments.read().await;
        let env = environments.get(&env_id).unwrap();
        
        // Test blocked package
        let result = manager.install_package(&env_id, "dangerous-package", env).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("blocked"));
    }
}
```

#### Sandbox Security Tests
```rust
#[cfg(test)]
mod sandbox_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_dangerous_code_detection() {
        let config = SandboxConfig {
            max_execution_time_seconds: 30,
            max_memory_mb: 100,
            max_cpu_percent: 80.0,
            max_disk_usage_mb: 50,
            allow_network: false,
            allow_external_files: false,
            blocked_syscalls: vec!["system".to_string()],
        };
        
        let sandbox = CodeExecutionSandbox::new(config);
        
        let dangerous_code = "import os; os.system('rm -rf /')";
        let result = sandbox.validate_code(dangerous_code).await;
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("dangerous"));
    }
    
    #[tokio::test]
    async fn test_safe_code_execution() {
        let config = SandboxConfig {
            max_execution_time_seconds: 30,
            max_memory_mb: 100,
            max_cpu_percent: 80.0,
            max_disk_usage_mb: 50,
            allow_network: false,
            allow_external_files: false,
            blocked_syscalls: vec!["system".to_string()],
        };
        
        let sandbox = CodeExecutionSandbox::new(config);
        
        let request = CodeExecutionRequest {
            language: ProgrammingLanguage::Python,
            code: "result = 2 + 2\nprint(result)".to_string(),
            timeout: Some(10),
            working_directory: None,
            environment: None,
            capture_output: true,
            return_base64: Some(false),
        };
        
        let result = sandbox.execute_sandboxed(request).await.unwrap();
        assert_eq!(result.exit_code, 0);
        assert_eq!(result.stdout.trim(), "4");
    }
}
```

### 2. Integration Tests (200 LOC)

#### Tool Integration Tests
```rust
#[tokio::test]
async fn test_code_execution_tool_integration() {
    let config = CodeExecutionToolConfig {
        enabled: true,
        max_execution_time_seconds: 30,
        max_concurrent_executions: 5,
        enable_package_installation: true,
        default_environment: PythonEnvironmentConfig::default(),
        sandbox_config: SandboxConfig::default(),
    };
    
    let mut tool = CodeExecutionAgentTool::new(config).unwrap();
    
    let input = json!({
        "language": "python",
        "code": "import math\nresult = math.sqrt(16)\nprint(f'Square root of 16 is {result}')",
        "timeout": 10,
        "capture_output": true
    });
    
    let result = tool.execute(input).await;
    assert!(result.is_success());
    
    let response = result.unwrap_success();
    assert_eq!(response["exit_code"], 0);
    assert!(response["stdout"].as_str().unwrap().contains("Square root of 16 is 4"));
}

#[tokio::test]
async fn test_package_installation_integration() {
    let config = CodeExecutionToolConfig {
        enabled: true,
        max_execution_time_seconds: 60,
        max_concurrent_executions: 5,
        enable_package_installation: true,
        default_environment: PythonEnvironmentConfig::default(),
        sandbox_config: SandboxConfig::default(),
    };
    
    let mut tool = CodeExecutionAgentTool::new(config).unwrap();
    
    let input = json!({
        "language": "python",
        "code": "import json\ndata = {'test': 'value'}\nprint(json.dumps(data))",
        "install_packages": ["json"],
        "timeout": 30,
        "capture_output": true
    });
    
    let result = tool.execute(input).await;
    assert!(result.is_success());
    
    let response = result.unwrap_success();
    assert_eq!(response["exit_code"], 0);
    assert!(response["stdout"].as_str().unwrap().contains("{\"test\": \"value\"}"));
}
```

### 3. Security Tests (150 LOC)

#### Security Validation Tests
```rust
#[cfg(test)]
mod security_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_file_system_isolation() {
        let config = CodeExecutionToolConfig {
            enabled: true,
            max_execution_time_seconds: 30,
            max_concurrent_executions: 5,
            enable_package_installation: false,
            default_environment: PythonEnvironmentConfig::default(),
            sandbox_config: SandboxConfig {
                allow_external_files: false,
                ..SandboxConfig::default()
            },
        };
        
        let mut tool = CodeExecutionAgentTool::new(config).unwrap();
        
        let input = json!({
            "language": "python",
            "code": "with open('/etc/passwd', 'r') as f: print(f.read())",
            "timeout": 10
        });
        
        let result = tool.execute(input).await;
        // Should either fail or not have access to /etc/passwd
        assert!(result.is_error() || 
                !result.unwrap_success()["stdout"].as_str().unwrap().contains("root"));
    }
    
    #[tokio::test]
    async fn test_network_isolation() {
        let config = CodeExecutionToolConfig {
            enabled: true,
            max_execution_time_seconds: 30,
            max_concurrent_executions: 5,
            enable_package_installation: false,
            default_environment: PythonEnvironmentConfig::default(),
            sandbox_config: SandboxConfig {
                allow_network: false,
                ..SandboxConfig::default()
            },
        };
        
        let mut tool = CodeExecutionAgentTool::new(config).unwrap();
        
        let input = json!({
            "language": "python",
            "code": "import urllib.request\nresponse = urllib.request.urlopen('http://example.com')\nprint('Network access successful')",
            "timeout": 10
        });
        
        let result = tool.execute(input).await;
        // Should fail due to network restrictions
        if result.is_success() {
            let response = result.unwrap_success();
            assert_ne!(response["exit_code"], 0);
        }
    }
}
```

### 4. Performance Tests (100 LOC)

#### Performance Benchmark Tests
```rust
#[cfg(test)]
mod performance_tests {
    use super::*;
    use std::time::Instant;
    
    #[tokio::test]
    async fn test_execution_performance() {
        let config = CodeExecutionToolConfig::default();
        let mut tool = CodeExecutionAgentTool::new(config).unwrap();
        
        let input = json!({
            "language": "python",
            "code": "result = sum(range(10000))\nprint(result)",
            "timeout": 5
        });
        
        let start = Instant::now();
        let result = tool.execute(input).await;
        let duration = start.elapsed();
        
        assert!(result.is_success());
        assert!(duration.as_millis() < 5000, "Execution too slow: {:?}", duration);
    }
    
    #[tokio::test]
    async fn test_concurrent_executions() {
        let config = CodeExecutionToolConfig {
            max_concurrent_executions: 3,
            ..CodeExecutionToolConfig::default()
        };
        
        let tool = Arc::new(Mutex::new(CodeExecutionAgentTool::new(config).unwrap()));
        
        let mut handles = Vec::new();
        
        for i in 0..3 {
            let tool_clone = tool.clone();
            let handle = tokio::spawn(async move {
                let input = json!({
                    "language": "python",
                    "code": format!("import time\ntime.sleep(0.1)\nprint('Execution {}')", i),
                    "timeout": 5
                });
                
                let mut tool_guard = tool_clone.lock().await;
                tool_guard.execute(input).await
            });
            handles.push(handle);
        }
        
        let start = Instant::now();
        let results: Vec<_> = futures::future::join_all(handles).await;
        let duration = start.elapsed();
        
        // All executions should succeed
        for result in results {
            assert!(result.unwrap().is_success());
        }
        
        // Should complete in reasonable time (concurrent, not sequential)
        assert!(duration.as_millis() < 1000, "Concurrent execution too slow: {:?}", duration);
    }
}
```

## Dependencies & Integration

### 1. Direct Dependencies
**Requires Issue 3.2 (Text Editor Tool):**
- Text editor integration for edit-and-execute workflows
- File modification capabilities for iterative development
- Shared whitelist validation patterns

### 2. Required Crate Dependencies
```toml
# Add to Cargo.toml
[dependencies]
uuid = { version = "1.0", features = ["v4", "serde"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["process", "fs", "time"] }
futures = "0.3"
image = "0.24"
base64 = "0.21"
mime_guess = "2.0"
sysinfo = "0.29"  # For resource monitoring
```

### 3. Integration Points

#### 3.1 Text Editor Workflow Integration
```rust
// Integration with Issue 3.2 Text Editor Tool
#[tauri::command]
async fn edit_and_execute_code(
    file_path: String,
    edits: Vec<TextEdit>,
    execution_config: Option<CodeExecutionRequest>,
    state: tauri::State<'_, AppState>,
) -> Result<CodeExecutionResult, String> {
    let text_editor = state.get_text_editor_tool();
    let code_executor = state.get_code_execution_tool();
    
    // Apply edits using text editor
    text_editor.apply_edits(&PathBuf::from(&file_path), edits).await
        .map_err(|e| e.to_string())?;
    
    // Read modified code
    let code = tokio::fs::read_to_string(&file_path).await
        .map_err(|e| e.to_string())?;
    
    // Execute code
    let request = execution_config.unwrap_or(CodeExecutionRequest {
        language: ProgrammingLanguage::Python,
        code,
        timeout: Some(30),
        working_directory: Some(PathBuf::from(&file_path).parent().unwrap().to_path_buf()),
        environment: None,
        capture_output: true,
        return_base64: Some(false),
    });
    
    code_executor.execution_sandbox.execute_sandboxed(request).await
        .map_err(|e| e.to_string())
}
```

#### 3.2 Whitelist System Integration
```rust
// Integration with existing whitelist system
impl CodeExecutionAgentTool {
    async fn validate_execution_paths(&self, request: &CodeExecutionRequest) -> ClaudeResult<()> {
        if let Some(ref whitelist) = self.whitelist {
            let whitelist_guard = whitelist.read().await;
            
            // Validate working directory
            if let Some(ref wd) = request.working_directory {
                if !whitelist_guard.is_path_allowed(wd) {
                    return Err(ClaudeError::CodeExecutionError {
                        message: "Working directory not allowed by whitelist".to_string(),
                        code: None,
                        context: None,
                    });
                }
            }
            
            // Validate file operations in code
            if request.code.contains("open(") || request.code.contains("with open") {
                // Parse file paths from code and validate
                self.validate_file_operations_in_code(&request.code, &whitelist_guard).await?;
            }
        }
        
        Ok(())
    }
}
```

## Security Considerations

### 1. Code Execution Security
- **Sandboxed Environment**: All code execution happens in isolated virtual environments
- **Resource Limits**: Memory, CPU, and disk usage limits prevent resource exhaustion
- **Timeout Protection**: Execution timeout prevents infinite loops and hanging processes
- **Code Validation**: Static analysis to detect dangerous operations before execution

### 2. Package Installation Security
- **Package Validation**: Security scanning of packages before installation
- **Whitelist Control**: Only pre-approved packages can be installed
- **Size Limits**: Package size restrictions prevent large package attacks
- **Source Validation**: Only trusted package sources allowed

### 3. File System Security
- **Path Validation**: All file operations validated against whitelist
- **Sandbox Isolation**: Code execution isolated to sandbox directories
- **Temporary Files**: Automatic cleanup of temporary execution files
- **Permission Control**: Limited file system permissions within sandbox

### 4. Network Security
- **Network Isolation**: Optional network access control for code execution
- **Request Filtering**: Network request validation and filtering
- **Rate Limiting**: Prevent excessive network usage
- **Proxy Support**: Optional proxy for controlled network access

## Acceptance Criteria

### 1. Core Functionality
- [ ] Python code execution in sandboxed environment
- [ ] Package installation and management
- [ ] Result capture (stdout, stderr, files, images)
- [ ] Timeout and resource limit enforcement
- [ ] Integration with text editor tool (Issue 3.2)

### 2. Security Requirements
- [ ] Code validation prevents dangerous operations
- [ ] Sandbox isolation protects host system
- [ ] Package security scanning works correctly
- [ ] Whitelist integration enforces path restrictions
- [ ] Resource limits prevent system abuse

### 3. Performance Requirements
- [ ] Code execution completes within timeout limits
- [ ] Concurrent execution supports multiple sessions
- [ ] Memory usage remains within configured limits
- [ ] Package installation completes in reasonable time

### 4. Integration Requirements
- [ ] Seamless integration with text editor workflows
- [ ] Proper error handling and reporting
- [ ] Result visualization for images and plots
- [ ] File creation tracking and management

### 5. Tool Interface Requirements
- [ ] Proper AgentTool implementation
- [ ] Comprehensive parameter validation
- [ ] Structured result format
- [ ] Error handling with context

### 6. Documentation Requirements
- [ ] API documentation for all components
- [ ] Security guidelines and best practices
- [ ] Usage examples and tutorials
- [ ] Integration guides with other tools

## References

### 1. Anthropic Documentation
- [Code Execution Tool Specification](https://docs.anthropic.com/en/docs/tool-use/computer-use)
- [Claude Tool Use Documentation](https://docs.anthropic.com/en/docs/tool-use)
- [Security Best Practices](https://docs.anthropic.com/en/docs/build-with-claude/security)

### 2. GitHub Issues
- [Issue 3.2: Text Editor Tool with Advanced Editing Commands](https://github.com/user/repo/issues/3.2)
- [Issue 2.1: Parallel Tool Execution System](https://github.com/user/repo/issues/2.1)
- [Issue 2.2: Tool Chaining and Orchestration System](https://github.com/user/repo/issues/2.2)
- [Implementation Sequencing Guide](../implementation-sequencing.md)

### 3. Technical Resources
- [Python Virtual Environment Documentation](https://docs.python.org/3/library/venv.html)
- [Tokio Async Documentation](https://docs.rs/tokio/)
- [Serde JSON Documentation](https://docs.serde.rs/serde_json/)
- [Security Sandboxing Best Practices](https://security.stackexchange.com/questions/tagged/sandbox)

### 4. Internal Documentation
- [Architecture Overview](../architecture/overview.md)
- [Security Guidelines](../security/guidelines.md)
- [Tool Development Guide](../development/tools.md)
- [Testing Standards](../development/testing.md)

## Estimated Lines of Code

**Implementation: ~1,500 LOC**
- Python environment management: ~400 LOC
- Package manager: ~300 LOC
- Execution sandbox: ~400 LOC
- Tool implementation: ~300 LOC
- Security enforcement: ~100 LOC

**Testing: ~750 LOC**
- Unit tests: ~300 LOC
- Integration tests: ~200 LOC
- Security tests: ~150 LOC
- Performance tests: ~100 LOC

**Total: ~2,250 LOC**

This comprehensive implementation provides secure, sandboxed Python code execution capabilities with package management, result visualization, and seamless integration with the text editor tool, enabling dynamic development workflows and interactive code analysis.