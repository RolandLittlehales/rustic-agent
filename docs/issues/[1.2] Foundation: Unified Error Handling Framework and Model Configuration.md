# [1.2] Foundation: Unified Error Handling Framework and Model Configuration

## Overview

This issue implements a comprehensive error handling framework and model configuration system that provides the foundation for reliable Claude 4 integration. This system establishes robust error categorization, recovery mechanisms, and model management capabilities that support all subsequent features in the agent.

**Why This Matters:**
- Current error handling is basic and inconsistent across components
- Claude 4 integration requires sophisticated error handling for API failures, rate limits, and model-specific issues
- Model configuration needs to support multiple Claude models with fallback strategies
- Foundation for all error-critical features like streaming, tool execution, and parallel processing

**Current State:**
- Basic error handling with simple string error messages
- No unified error taxonomy or recovery strategies
- Hard-coded model configuration with no validation
- Inconsistent error propagation across components

**Target State:**
- Comprehensive error taxonomy with context-aware error handling
- Unified error handling framework with retry logic and circuit breakers
- Robust model configuration system with validation and fallback
- Integration with all existing and future components

## Technical Requirements

### 1. Unified Error Handling Framework

#### 1.1 Core Error Types System
```rust
// Enhanced error system in src-tauri/src/claude/error.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ErrorContext {
    pub operation: String,
    pub timestamp: DateTime<Utc>,
    pub request_id: Option<String>,
    pub model: Option<String>,
    pub tool_name: Option<String>,
    pub retry_count: u32,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, thiserror::Error)]
pub enum ClaudeError {
    // API-related errors
    #[error("HTTP request failed: {message}")]
    HttpError {
        message: String,
        status_code: Option<u16>,
        context: Option<ErrorContext>,
    },

    #[error("API error: {message}")]
    ApiError {
        error_type: String,
        message: String,
        status_code: u16,
        param: Option<String>,
        context: Option<ErrorContext>,
    },

    #[error("Authentication failed: {message}")]
    AuthError {
        message: String,
        context: Option<ErrorContext>,
    },

    #[error("Rate limit exceeded: {message}")]
    RateLimitError {
        message: String,
        retry_after: Option<u64>,
        context: Option<ErrorContext>,
    },

    // Model-related errors
    #[error("Model error: {message}")]
    ModelError {
        model: String,
        message: String,
        context: Option<ErrorContext>,
    },

    #[error("Invalid model configuration: {message}")]
    ModelConfigError {
        field: String,
        message: String,
        context: Option<ErrorContext>,
    },

    // Tool execution errors
    #[error("Tool execution failed: {message}")]
    ToolError {
        tool_name: String,
        message: String,
        is_retryable: bool,
        context: Option<ErrorContext>,
    },

    #[error("Tool validation failed: {message}")]
    ToolValidationError {
        tool_name: String,
        field: String,
        message: String,
        context: Option<ErrorContext>,
    },

    // Content and message errors
    #[error("Content validation failed: {message}")]
    ContentValidationError {
        content_type: String,
        message: String,
        context: Option<ErrorContext>,
    },

    #[error("Message processing failed: {message}")]
    MessageProcessingError {
        message: String,
        context: Option<ErrorContext>,
    },

    // Configuration errors
    #[error("Configuration error: {message}")]
    ConfigError {
        section: String,
        message: String,
        context: Option<ErrorContext>,
    },

    #[error("Validation error: {message}")]
    ValidationError {
        field: String,
        message: String,
        value: Option<String>,
        context: Option<ErrorContext>,
    },

    // Streaming-related errors (future-ready)
    #[error("Streaming error: {message}")]
    StreamingError {
        message: String,
        stream_id: Option<String>,
        context: Option<ErrorContext>,
    },

    // System-level errors
    #[error("Timeout error: operation took {duration:?}")]
    TimeoutError {
        duration: std::time::Duration,
        operation: String,
        context: Option<ErrorContext>,
    },

    #[error("System error: {message}")]
    SystemError {
        message: String,
        source: Option<Box<dyn std::error::Error + Send + Sync>>,
        context: Option<ErrorContext>,
    },

    // JSON and serialization errors
    #[error("JSON error: {message}")]
    JsonError {
        message: String,
        context: Option<ErrorContext>,
    },

    // IO errors
    #[error("IO error: {message}")]
    IoError {
        message: String,
        path: Option<String>,
        context: Option<ErrorContext>,
    },
}

impl ClaudeError {
    pub fn with_context(mut self, context: ErrorContext) -> Self {
        match &mut self {
            ClaudeError::HttpError { context: c, .. } |
            ClaudeError::ApiError { context: c, .. } |
            ClaudeError::AuthError { context: c, .. } |
            ClaudeError::RateLimitError { context: c, .. } |
            ClaudeError::ModelError { context: c, .. } |
            ClaudeError::ModelConfigError { context: c, .. } |
            ClaudeError::ToolError { context: c, .. } |
            ClaudeError::ToolValidationError { context: c, .. } |
            ClaudeError::ContentValidationError { context: c, .. } |
            ClaudeError::MessageProcessingError { context: c, .. } |
            ClaudeError::ConfigError { context: c, .. } |
            ClaudeError::ValidationError { context: c, .. } |
            ClaudeError::StreamingError { context: c, .. } |
            ClaudeError::TimeoutError { context: c, .. } |
            ClaudeError::SystemError { context: c, .. } |
            ClaudeError::JsonError { context: c, .. } |
            ClaudeError::IoError { context: c, .. } => {
                *c = Some(context);
            }
        }
        self
    }

    pub fn is_retryable(&self) -> bool {
        matches!(self,
            ClaudeError::HttpError { status_code: Some(code), .. } if *code >= 500,
            | ClaudeError::TimeoutError { .. }
            | ClaudeError::RateLimitError { .. }
            | ClaudeError::ToolError { is_retryable: true, .. }
        )
    }

    pub fn should_retry_after(&self) -> Option<std::time::Duration> {
        match self {
            ClaudeError::RateLimitError { retry_after: Some(seconds), .. } => {
                Some(std::time::Duration::from_secs(*seconds))
            }
            ClaudeError::TimeoutError { .. } => {
                Some(std::time::Duration::from_secs(5))
            }
            ClaudeError::HttpError { status_code: Some(503), .. } => {
                Some(std::time::Duration::from_secs(10))
            }
            _ => None,
        }
    }

    pub fn get_error_code(&self) -> String {
        match self {
            ClaudeError::HttpError { .. } => "HTTP_ERROR".to_string(),
            ClaudeError::ApiError { error_type, .. } => error_type.to_uppercase(),
            ClaudeError::AuthError { .. } => "AUTH_ERROR".to_string(),
            ClaudeError::RateLimitError { .. } => "RATE_LIMIT_ERROR".to_string(),
            ClaudeError::ModelError { .. } => "MODEL_ERROR".to_string(),
            ClaudeError::ModelConfigError { .. } => "MODEL_CONFIG_ERROR".to_string(),
            ClaudeError::ToolError { .. } => "TOOL_ERROR".to_string(),
            ClaudeError::ToolValidationError { .. } => "TOOL_VALIDATION_ERROR".to_string(),
            ClaudeError::ContentValidationError { .. } => "CONTENT_VALIDATION_ERROR".to_string(),
            ClaudeError::MessageProcessingError { .. } => "MESSAGE_PROCESSING_ERROR".to_string(),
            ClaudeError::ConfigError { .. } => "CONFIG_ERROR".to_string(),
            ClaudeError::ValidationError { .. } => "VALIDATION_ERROR".to_string(),
            ClaudeError::StreamingError { .. } => "STREAMING_ERROR".to_string(),
            ClaudeError::TimeoutError { .. } => "TIMEOUT_ERROR".to_string(),
            ClaudeError::SystemError { .. } => "SYSTEM_ERROR".to_string(),
            ClaudeError::JsonError { .. } => "JSON_ERROR".to_string(),
            ClaudeError::IoError { .. } => "IO_ERROR".to_string(),
        }
    }
}

// Type alias for consistent error handling
pub type ClaudeResult<T> = Result<T, ClaudeError>;
```

#### 1.2 Error Handler with Retry Logic
```rust
// Error handling utilities in src-tauri/src/claude/error_handler.rs
use super::error::{ClaudeError, ClaudeResult, ErrorContext};
use std::sync::atomic::{AtomicU32, Ordering};
use std::time::{Duration, Instant};
use tokio::time::sleep;
use tracing::{error, warn, info};

#[derive(Debug, Clone)]
pub struct ErrorHandlerConfig {
    pub max_retries: u32,
    pub base_delay: Duration,
    pub max_delay: Duration,
    pub backoff_multiplier: f64,
    pub jitter: bool,
}

impl Default for ErrorHandlerConfig {
    fn default() -> Self {
        Self {
            max_retries: 3,
            base_delay: Duration::from_millis(500),
            max_delay: Duration::from_secs(30),
            backoff_multiplier: 2.0,
            jitter: true,
        }
    }
}

pub struct ErrorHandler {
    config: ErrorHandlerConfig,
    retry_count: AtomicU32,
}

impl ErrorHandler {
    pub fn new(config: ErrorHandlerConfig) -> Self {
        Self {
            config,
            retry_count: AtomicU32::new(0),
        }
    }

    pub fn default() -> Self {
        Self::new(ErrorHandlerConfig::default())
    }

    pub async fn handle_with_retry<F, T, Fut>(&self, operation_name: &str, operation: F) -> ClaudeResult<T>
    where
        F: Fn() -> Fut,
        Fut: std::future::Future<Output = ClaudeResult<T>>,
    {
        let mut last_error = None;
        let start_time = Instant::now();

        for attempt in 0..=self.config.max_retries {
            let attempt_start = Instant::now();
            
            match operation().await {
                Ok(result) => {
                    if attempt > 0 {
                        info!("Operation '{}' succeeded after {} retries in {:?}", 
                              operation_name, attempt, start_time.elapsed());
                    }
                    return Ok(result);
                }
                Err(error) => {
                    if !error.is_retryable() || attempt == self.config.max_retries {
                        error!("Operation '{}' failed permanently: {}", operation_name, error);
                        return Err(error.with_context(ErrorContext {
                            operation: operation_name.to_string(),
                            timestamp: chrono::Utc::now(),
                            request_id: None,
                            model: None,
                            tool_name: None,
                            retry_count: attempt,
                            metadata: HashMap::new(),
                        }));
                    }

                    let delay = self.calculate_delay(attempt, &error);
                    
                    warn!("Operation '{}' failed (attempt {}/{}): {}. Retrying in {:?}", 
                          operation_name, attempt + 1, self.config.max_retries + 1, error, delay);
                    
                    sleep(delay).await;
                    last_error = Some(error);
                }
            }
        }

        Err(last_error.unwrap())
    }

    fn calculate_delay(&self, attempt: u32, error: &ClaudeError) -> Duration {
        // Use error-specific delay if available
        if let Some(delay) = error.should_retry_after() {
            return delay;
        }

        // Calculate exponential backoff
        let base_delay_ms = self.config.base_delay.as_millis() as f64;
        let delay_ms = base_delay_ms * self.config.backoff_multiplier.powi(attempt as i32);
        let delay = Duration::from_millis(delay_ms as u64);

        // Apply maximum delay cap
        let capped_delay = std::cmp::min(delay, self.config.max_delay);

        // Apply jitter if enabled
        if self.config.jitter {
            let jitter_factor = 0.1; // 10% jitter
            let jitter = (rand::random::<f64>() - 0.5) * 2.0 * jitter_factor;
            let jittered_ms = (capped_delay.as_millis() as f64) * (1.0 + jitter);
            Duration::from_millis(jittered_ms.max(0.0) as u64)
        } else {
            capped_delay
        }
    }

    pub async fn handle_with_circuit_breaker<F, T, Fut>(
        &self,
        operation_name: &str,
        circuit_breaker: &mut CircuitBreaker,
        operation: F,
    ) -> ClaudeResult<T>
    where
        F: Fn() -> Fut,
        Fut: std::future::Future<Output = ClaudeResult<T>>,
    {
        if circuit_breaker.is_open() {
            return Err(ClaudeError::SystemError {
                message: format!("Circuit breaker is open for operation '{}'", operation_name),
                source: None,
                context: None,
            });
        }

        match self.handle_with_retry(operation_name, operation).await {
            Ok(result) => {
                circuit_breaker.record_success();
                Ok(result)
            }
            Err(error) => {
                circuit_breaker.record_failure();
                Err(error)
            }
        }
    }
}

#[derive(Debug)]
pub struct CircuitBreaker {
    failure_count: AtomicU32,
    last_failure_time: std::sync::Mutex<Option<Instant>>,
    failure_threshold: u32,
    timeout: Duration,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: u32, timeout: Duration) -> Self {
        Self {
            failure_count: AtomicU32::new(0),
            last_failure_time: std::sync::Mutex::new(None),
            failure_threshold,
            timeout,
        }
    }

    pub fn is_open(&self) -> bool {
        let current_failures = self.failure_count.load(Ordering::Relaxed);
        if current_failures < self.failure_threshold {
            return false;
        }

        let last_failure = self.last_failure_time.lock().unwrap();
        match *last_failure {
            Some(time) => time.elapsed() < self.timeout,
            None => false,
        }
    }

    pub fn record_success(&self) {
        self.failure_count.store(0, Ordering::Relaxed);
        *self.last_failure_time.lock().unwrap() = None;
    }

    pub fn record_failure(&self) {
        self.failure_count.fetch_add(1, Ordering::Relaxed);
        *self.last_failure_time.lock().unwrap() = Some(Instant::now());
    }
}
```

### 2. Model Configuration System

#### 2.1 Model Registry and Configuration
```rust
// Model configuration system in src-tauri/src/claude/model_config.rs
use super::error::{ClaudeError, ClaudeResult};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelInfo {
    pub name: String,
    pub family: String,
    pub variant: String,
    pub max_tokens: u32,
    pub context_window: u32,
    pub supports_thinking: bool,
    pub supports_tool_use: bool,
    pub supports_streaming: bool,
    pub cost_per_million_input: f64,
    pub cost_per_million_output: f64,
    pub release_date: String,
    pub is_deprecated: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelConfig {
    pub model: String,
    pub max_tokens: u32,
    pub temperature: f64,
    pub system_prompt: Option<String>,
    pub fallback_models: Vec<String>,
    pub timeout_seconds: u64,
    pub retry_config: RetryConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RetryConfig {
    pub max_retries: u32,
    pub base_delay_ms: u64,
    pub max_delay_ms: u64,
    pub backoff_multiplier: f64,
    pub jitter_enabled: bool,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_retries: 3,
            base_delay_ms: 500,
            max_delay_ms: 30000,
            backoff_multiplier: 2.0,
            jitter_enabled: true,
        }
    }
}

impl Default for ModelConfig {
    fn default() -> Self {
        Self {
            model: "claude-4-sonnet-20250522".to_string(),
            max_tokens: 8192,
            temperature: 0.7,
            system_prompt: None,
            fallback_models: vec![
                "claude-4-haiku-20250522".to_string(),
                "claude-3-5-sonnet-20241022".to_string(),
            ],
            timeout_seconds: 120,
            retry_config: RetryConfig::default(),
        }
    }
}

pub struct ModelRegistry {
    models: HashMap<String, ModelInfo>,
    default_model: String,
    fallback_chain: Vec<String>,
}

impl ModelRegistry {
    pub fn new() -> Self {
        let mut registry = Self {
            models: HashMap::new(),
            default_model: "claude-4-sonnet-20250522".to_string(),
            fallback_chain: vec![
                "claude-4-sonnet-20250522".to_string(),
                "claude-4-haiku-20250522".to_string(),
                "claude-3-5-sonnet-20241022".to_string(),
            ],
        };
        registry.initialize_default_models();
        registry
    }

    fn initialize_default_models(&mut self) {
        // Claude 4 models
        self.models.insert("claude-4-opus-20250522".to_string(), ModelInfo {
            name: "claude-4-opus-20250522".to_string(),
            family: "claude-4".to_string(),
            variant: "opus".to_string(),
            max_tokens: 8192,
            context_window: 200000,
            supports_thinking: true,
            supports_tool_use: true,
            supports_streaming: true,
            cost_per_million_input: 15.0,
            cost_per_million_output: 75.0,
            release_date: "2025-05-22".to_string(),
            is_deprecated: false,
        });

        self.models.insert("claude-4-sonnet-20250522".to_string(), ModelInfo {
            name: "claude-4-sonnet-20250522".to_string(),
            family: "claude-4".to_string(),
            variant: "sonnet".to_string(),
            max_tokens: 8192,
            context_window: 200000,
            supports_thinking: true,
            supports_tool_use: true,
            supports_streaming: true,
            cost_per_million_input: 3.0,
            cost_per_million_output: 15.0,
            release_date: "2025-05-22".to_string(),
            is_deprecated: false,
        });

        self.models.insert("claude-4-haiku-20250522".to_string(), ModelInfo {
            name: "claude-4-haiku-20250522".to_string(),
            family: "claude-4".to_string(),
            variant: "haiku".to_string(),
            max_tokens: 8192,
            context_window: 200000,
            supports_thinking: true,
            supports_tool_use: true,
            supports_streaming: true,
            cost_per_million_input: 0.25,
            cost_per_million_output: 1.25,
            release_date: "2025-05-22".to_string(),
            is_deprecated: false,
        });

        // Claude 3.5 models (legacy support)
        self.models.insert("claude-3-5-sonnet-20241022".to_string(), ModelInfo {
            name: "claude-3-5-sonnet-20241022".to_string(),
            family: "claude-3.5".to_string(),
            variant: "sonnet".to_string(),
            max_tokens: 8192,
            context_window: 200000,
            supports_thinking: false,
            supports_tool_use: true,
            supports_streaming: true,
            cost_per_million_input: 3.0,
            cost_per_million_output: 15.0,
            release_date: "2024-10-22".to_string(),
            is_deprecated: false,
        });

        self.models.insert("claude-3-5-haiku-20241022".to_string(), ModelInfo {
            name: "claude-3-5-haiku-20241022".to_string(),
            family: "claude-3.5".to_string(),
            variant: "haiku".to_string(),
            max_tokens: 8192,
            context_window: 200000,
            supports_thinking: false,
            supports_tool_use: true,
            supports_streaming: true,
            cost_per_million_input: 0.8,
            cost_per_million_output: 4.0,
            release_date: "2024-10-22".to_string(),
            is_deprecated: false,
        });
    }

    pub fn get_model_info(&self, model_name: &str) -> Option<&ModelInfo> {
        self.models.get(model_name)
    }

    pub fn get_all_models(&self) -> Vec<&ModelInfo> {
        self.models.values().collect()
    }

    pub fn get_available_models(&self) -> Vec<&ModelInfo> {
        self.models.values()
            .filter(|model| !model.is_deprecated)
            .collect()
    }

    pub fn get_fallback_model(&self, current_model: &str) -> Option<String> {
        let current_index = self.fallback_chain.iter()
            .position(|model| model == current_model)?;
        
        if current_index + 1 < self.fallback_chain.len() {
            Some(self.fallback_chain[current_index + 1].clone())
        } else {
            None
        }
    }

    pub fn validate_model(&self, model_name: &str) -> ClaudeResult<&ModelInfo> {
        let model_info = self.get_model_info(model_name)
            .ok_or_else(|| ClaudeError::ModelConfigError {
                field: "model".to_string(),
                message: format!("Unknown model: {}", model_name),
                context: None,
            })?;

        if model_info.is_deprecated {
            return Err(ClaudeError::ModelConfigError {
                field: "model".to_string(),
                message: format!("Model {} is deprecated", model_name),
                context: None,
            });
        }

        Ok(model_info)
    }

    pub fn select_optimal_model(&self, task_complexity: TaskComplexity, cost_priority: bool) -> String {
        match (task_complexity, cost_priority) {
            (TaskComplexity::Simple, true) => "claude-4-haiku-20250522".to_string(),
            (TaskComplexity::Simple, false) => "claude-4-sonnet-20250522".to_string(),
            (TaskComplexity::Moderate, true) => "claude-4-sonnet-20250522".to_string(),
            (TaskComplexity::Moderate, false) => "claude-4-sonnet-20250522".to_string(),
            (TaskComplexity::Complex, _) => "claude-4-opus-20250522".to_string(),
        }
    }
}

#[derive(Debug, Clone)]
pub enum TaskComplexity {
    Simple,   // File operations, simple queries
    Moderate, // Code analysis, document processing
    Complex,  // Multi-step reasoning, complex tool chains
}

impl ModelConfig {
    pub fn validate(&self, registry: &ModelRegistry) -> ClaudeResult<()> {
        // Validate main model
        registry.validate_model(&self.model)?;

        // Validate fallback models
        for fallback_model in &self.fallback_models {
            registry.validate_model(fallback_model)?;
        }

        // Validate configuration parameters
        if self.max_tokens == 0 {
            return Err(ClaudeError::ValidationError {
                field: "max_tokens".to_string(),
                message: "max_tokens must be greater than 0".to_string(),
                value: Some(self.max_tokens.to_string()),
                context: None,
            });
        }

        let model_info = registry.get_model_info(&self.model).unwrap();
        if self.max_tokens > model_info.max_tokens {
            return Err(ClaudeError::ValidationError {
                field: "max_tokens".to_string(),
                message: format!("max_tokens ({}) exceeds model limit ({})", 
                                self.max_tokens, model_info.max_tokens),
                value: Some(self.max_tokens.to_string()),
                context: None,
            });
        }

        if self.temperature < 0.0 || self.temperature > 1.0 {
            return Err(ClaudeError::ValidationError {
                field: "temperature".to_string(),
                message: "temperature must be between 0.0 and 1.0".to_string(),
                value: Some(self.temperature.to_string()),
                context: None,
            });
        }

        if self.timeout_seconds == 0 {
            return Err(ClaudeError::ValidationError {
                field: "timeout_seconds".to_string(),
                message: "timeout_seconds must be greater than 0".to_string(),
                value: Some(self.timeout_seconds.to_string()),
                context: None,
            });
        }

        Ok(())
    }

    pub fn get_model_info<'a>(&self, registry: &'a ModelRegistry) -> Option<&'a ModelInfo> {
        registry.get_model_info(&self.model)
    }

    pub fn estimate_cost(&self, input_tokens: u32, output_tokens: u32, registry: &ModelRegistry) -> Option<f64> {
        let model_info = registry.get_model_info(&self.model)?;
        let input_cost = (input_tokens as f64 / 1_000_000.0) * model_info.cost_per_million_input;
        let output_cost = (output_tokens as f64 / 1_000_000.0) * model_info.cost_per_million_output;
        Some(input_cost + output_cost)
    }
}
```

#### 2.2 Configuration Management
```rust
// Configuration management in src-tauri/src/claude/mod.rs (updates)
use super::model_config::{ModelConfig, ModelRegistry};
use super::error::{ClaudeError, ClaudeResult, ErrorContext};

#[derive(Debug, Clone)]
pub struct ClaudeConfig {
    pub api_key: String,
    pub model_config: ModelConfig,
    pub model_registry: ModelRegistry,
}

impl ClaudeConfig {
    pub fn new(api_key: String) -> Self {
        Self {
            api_key,
            model_config: ModelConfig::default(),
            model_registry: ModelRegistry::new(),
        }
    }

    pub fn with_model_config(mut self, model_config: ModelConfig) -> ClaudeResult<Self> {
        model_config.validate(&self.model_registry)?;
        self.model_config = model_config;
        Ok(self)
    }

    pub fn validate(&self) -> ClaudeResult<()> {
        if self.api_key.is_empty() {
            return Err(ClaudeError::AuthError {
                message: "API key cannot be empty".to_string(),
                context: Some(ErrorContext {
                    operation: "config_validation".to_string(),
                    timestamp: chrono::Utc::now(),
                    request_id: None,
                    model: None,
                    tool_name: None,
                    retry_count: 0,
                    metadata: HashMap::new(),
                }),
            });
        }

        if !self.api_key.starts_with("sk-") {
            return Err(ClaudeError::AuthError {
                message: "Invalid API key format".to_string(),
                context: None,
            });
        }

        self.model_config.validate(&self.model_registry)?;
        Ok(())
    }

    pub fn get_current_model_info(&self) -> Option<&ModelInfo> {
        self.model_registry.get_model_info(&self.model_config.model)
    }

    pub fn get_fallback_model(&self) -> Option<String> {
        self.model_registry.get_fallback_model(&self.model_config.model)
    }

    pub fn switch_to_fallback(&mut self) -> ClaudeResult<bool> {
        if let Some(fallback_model) = self.get_fallback_model() {
            self.model_config.model = fallback_model;
            Ok(true)
        } else {
            Ok(false)
        }
    }
}

impl Default for ClaudeConfig {
    fn default() -> Self {
        Self {
            api_key: String::new(),
            model_config: ModelConfig::default(),
            model_registry: ModelRegistry::new(),
        }
    }
}
```

### 3. Integration with Existing Systems

#### 3.1 Enhanced Client Error Handling
```rust
// Updates to src-tauri/src/claude/client.rs
use super::error::{ClaudeError, ClaudeResult, ErrorContext};
use super::error_handler::{ErrorHandler, ErrorHandlerConfig, CircuitBreaker};
use super::model_config::ModelRegistry;

impl ClaudeClient {
    pub async fn send_message_with_error_handling(
        &mut self,
        conversation: &Conversation,
        message: String,
    ) -> ClaudeResult<String> {
        let error_handler = ErrorHandler::new(ErrorHandlerConfig {
            max_retries: self.config.model_config.retry_config.max_retries,
            base_delay: Duration::from_millis(self.config.model_config.retry_config.base_delay_ms),
            max_delay: Duration::from_millis(self.config.model_config.retry_config.max_delay_ms),
            backoff_multiplier: self.config.model_config.retry_config.backoff_multiplier,
            jitter: self.config.model_config.retry_config.jitter_enabled,
        });

        let operation = || async {
            self.send_message_internal(conversation, &message).await
        };

        error_handler.handle_with_retry("send_message", operation).await
    }

    async fn send_message_internal(
        &mut self,
        conversation: &Conversation,
        message: &str,
    ) -> ClaudeResult<String> {
        let request_context = ErrorContext {
            operation: "send_message".to_string(),
            timestamp: chrono::Utc::now(),
            request_id: Some(uuid::Uuid::new_v4().to_string()),
            model: Some(self.config.model_config.model.clone()),
            tool_name: None,
            retry_count: 0,
            metadata: HashMap::new(),
        };

        // Validate configuration before sending
        self.config.validate()
            .map_err(|e| e.with_context(request_context.clone()))?;

        // Prepare request with error context
        let request = self.build_request(conversation, message)
            .map_err(|e| e.with_context(request_context.clone()))?;

        // Send request with timeout
        let response = tokio::time::timeout(
            Duration::from_secs(self.config.model_config.timeout_seconds),
            self.client.post(&self.get_api_url())
                .header("x-api-key", &self.config.api_key)
                .header("anthropic-version", "2023-06-01")
                .header("content-type", "application/json")
                .json(&request)
                .send()
        ).await
        .map_err(|_| ClaudeError::TimeoutError {
            duration: Duration::from_secs(self.config.model_config.timeout_seconds),
            operation: "api_request".to_string(),
            context: Some(request_context.clone()),
        })?
        .map_err(|e| ClaudeError::HttpError {
            message: e.to_string(),
            status_code: None,
            context: Some(request_context.clone()),
        })?;

        // Handle HTTP status codes
        if !response.status().is_success() {
            let status_code = response.status().as_u16();
            let error_body: serde_json::Value = response.json().await
                .map_err(|e| ClaudeError::JsonError {
                    message: e.to_string(),
                    context: Some(request_context.clone()),
                })?;

            return Err(self.parse_api_error(status_code, &error_body, request_context));
        }

        // Parse successful response
        let response_body: serde_json::Value = response.json().await
            .map_err(|e| ClaudeError::JsonError {
                message: e.to_string(),
                context: Some(request_context.clone()),
            })?;

        self.extract_message_content(&response_body)
            .map_err(|e| e.with_context(request_context))
    }

    fn parse_api_error(&self, status_code: u16, error_body: &serde_json::Value, context: ErrorContext) -> ClaudeError {
        match status_code {
            401 => ClaudeError::AuthError {
                message: error_body["error"]["message"].as_str()
                    .unwrap_or("Authentication failed").to_string(),
                context: Some(context),
            },
            429 => {
                let retry_after = error_body["error"]["retry_after"].as_u64();
                ClaudeError::RateLimitError {
                    message: error_body["error"]["message"].as_str()
                        .unwrap_or("Rate limit exceeded").to_string(),
                    retry_after,
                    context: Some(context),
                }
            },
            400 => ClaudeError::ValidationError {
                field: error_body["error"]["param"].as_str().unwrap_or("unknown").to_string(),
                message: error_body["error"]["message"].as_str()
                    .unwrap_or("Invalid request").to_string(),
                value: None,
                context: Some(context),
            },
            _ => ClaudeError::ApiError {
                error_type: error_body["error"]["type"].as_str().unwrap_or("unknown").to_string(),
                message: error_body["error"]["message"].as_str()
                    .unwrap_or("API error").to_string(),
                status_code,
                param: error_body["error"]["param"].as_str().map(|s| s.to_string()),
                context: Some(context),
            }
        }
    }
}
```

## Architecture Changes

### 1. Current vs. Target Architecture

**Current Architecture:**
```
Basic error handling
    ↓
Simple string errors
    ↓
No retry logic
    ↓
Hard-coded model config
```

**Target Architecture:**
```
Comprehensive error taxonomy
    ↓
Context-aware error handling
    ↓
Retry logic with circuit breakers
    ↓
Model registry with fallbacks
    ↓
Configuration validation
    ↓
Integration with all components
```

### 2. File Structure Changes

**New Files:**
- `src-tauri/src/claude/error.rs` - Enhanced error types and context
- `src-tauri/src/claude/error_handler.rs` - Retry logic and circuit breakers
- `src-tauri/src/claude/model_config.rs` - Model registry and configuration

**Modified Files:**
- `src-tauri/src/claude/mod.rs` - Updated configuration integration
- `src-tauri/src/claude/client.rs` - Enhanced error handling integration
- `src-tauri/src/main.rs` - Updated Tauri command error handling

### 3. Dependencies

**Required Crate Updates:**
```toml
# Add to Cargo.toml
[dependencies]
thiserror = "1.0"
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.0", features = ["v4"] }
rand = "0.8"
tracing = "0.1"
```

## Implementation Plan

### Phase 1: Core Error Framework (Week 1)
**Target: ~400 LOC**

1. **Error Type System** (3 days)
   - Define comprehensive error enums
   - Add error context and metadata
   - Implement error categorization

2. **Error Handler Foundation** (2 days)
   - Basic retry logic implementation
   - Exponential backoff algorithms
   - Circuit breaker patterns

### Phase 2: Model Configuration (Week 1-2)
**Target: ~500 LOC**

1. **Model Registry** (3 days)
   - Model information database
   - Validation and capability detection
   - Fallback chain management

2. **Configuration System** (2 days)
   - Configuration validation
   - Model selection logic
   - Cost estimation utilities

### Phase 3: Integration (Week 2-3)
**Target: ~400 LOC**

1. **Client Integration** (3 days)
   - Update client error handling
   - Add retry mechanisms
   - Integrate model fallbacks

2. **Tauri Command Updates** (2 days)
   - Update all Tauri commands
   - Add error serialization
   - Frontend error handling

### Phase 4: Advanced Features (Week 3)
**Target: ~200 LOC**

1. **Circuit Breakers** (2 days)
   - Advanced failure detection
   - Automatic recovery
   - Monitoring integration

2. **Performance Optimization** (1 day)
   - Error handling performance
   - Memory usage optimization
   - Metrics collection

## Testing Strategy

### 1. Unit Tests (250 LOC)

#### Error Handling Tests
```rust
#[cfg(test)]
mod error_tests {
    use super::*;
    
    #[test]
    fn test_error_context_serialization() {
        let context = ErrorContext {
            operation: "test_op".to_string(),
            timestamp: chrono::Utc::now(),
            request_id: Some("req_123".to_string()),
            model: Some("claude-4-sonnet-20250522".to_string()),
            tool_name: None,
            retry_count: 2,
            metadata: HashMap::new(),
        };
        
        let error = ClaudeError::ApiError {
            error_type: "rate_limit".to_string(),
            message: "Rate limit exceeded".to_string(),
            status_code: 429,
            param: None,
            context: Some(context),
        };
        
        assert!(error.is_retryable());
        assert_eq!(error.get_error_code(), "RATE_LIMIT");
    }
    
    #[tokio::test]
    async fn test_error_handler_retry_logic() {
        let handler = ErrorHandler::default();
        let mut attempt_count = 0;
        
        let result = handler.handle_with_retry("test_operation", || {
            attempt_count += 1;
            async move {
                if attempt_count < 3 {
                    Err(ClaudeError::TimeoutError {
                        duration: Duration::from_secs(30),
                        operation: "test".to_string(),
                        context: None,
                    })
                } else {
                    Ok("success")
                }
            }
        }).await;
        
        assert!(result.is_ok());
        assert_eq!(attempt_count, 3);
    }
}
```

#### Model Configuration Tests
```rust
#[cfg(test)]
mod model_config_tests {
    use super::*;
    
    #[test]
    fn test_model_registry_validation() {
        let registry = ModelRegistry::new();
        
        // Valid model
        assert!(registry.validate_model("claude-4-sonnet-20250522").is_ok());
        
        // Invalid model
        assert!(registry.validate_model("invalid-model").is_err());
        
        // Fallback chain
        let fallback = registry.get_fallback_model("claude-4-opus-20250522");
        assert_eq!(fallback, Some("claude-4-sonnet-20250522".to_string()));
    }
    
    #[test]
    fn test_model_config_validation() {
        let registry = ModelRegistry::new();
        let mut config = ModelConfig::default();
        
        // Valid configuration
        assert!(config.validate(&registry).is_ok());
        
        // Invalid max_tokens
        config.max_tokens = 0;
        assert!(config.validate(&registry).is_err());
        
        // Invalid temperature
        config.temperature = 1.5;
        assert!(config.validate(&registry).is_err());
    }
}
```

### 2. Integration Tests (200 LOC)

#### Error Handling Integration
```rust
#[tokio::test]
async fn test_client_error_handling_integration() {
    let config = ClaudeConfig::default();
    let mut client = ClaudeClient::new(config).unwrap();
    let conversation = Conversation::default();
    
    // Test with invalid API key
    let result = client.send_message_with_error_handling(&conversation, "test".to_string()).await;
    assert!(matches!(result, Err(ClaudeError::AuthError { .. })));
}

#[tokio::test]
async fn test_model_fallback_integration() {
    let mut config = ClaudeConfig::default();
    config.model_config.model = "claude-4-opus-20250522".to_string();
    
    // Test fallback switching
    let switched = config.switch_to_fallback().unwrap();
    assert!(switched);
    assert_eq!(config.model_config.model, "claude-4-sonnet-20250522");
}
```

### 3. Performance Tests (100 LOC)

#### Error Handler Performance
```rust
#[tokio::test]
async fn test_error_handler_performance() {
    let handler = ErrorHandler::default();
    let start = Instant::now();
    
    for _ in 0..1000 {
        let _ = handler.handle_with_retry("perf_test", || async {
            Ok("success")
        }).await;
    }
    
    let duration = start.elapsed();
    assert!(duration.as_millis() < 1000);
}
```

## Dependencies & Integration

### 1. Integration Points

**Issue 1.1 Integration:**
- Error handling for ContentBlock processing
- Model configuration for Claude 4 support
- Error context for message processing

**Issue 1.3 Integration:**
- Tool error handling and validation
- Retry logic for tool execution
- Circuit breakers for tool failures

**Issue 1.4 Integration:**
- Streaming error handling
- Connection failure recovery
- Stream interruption handling

### 2. External Dependencies

**Anthropic API Integration:**
- Error response parsing
- Rate limit handling
- Model availability checking

**Whitelist System Integration:**
- Error handling for whitelist violations
- Configuration validation for security settings

## Security Considerations

### 1. Error Information Security
- Sanitize error messages before frontend exposure
- Avoid leaking API keys in error contexts
- Secure logging of sensitive error information
- Rate limiting for error-prone operations

### 2. Configuration Security
- Validate all configuration parameters
- Secure storage of model configurations
- Audit logging for configuration changes
- Input validation for all user-provided settings

### 3. API Security
- Secure error handling for authentication failures
- Rate limit enforcement and monitoring
- Circuit breaker protection against abuse
- Secure timeout handling

## Acceptance Criteria

### 1. Core Functionality
- [ ] Comprehensive error taxonomy with proper categorization
- [ ] Retry logic with exponential backoff and jitter
- [ ] Circuit breaker patterns for failure protection
- [ ] Model registry with validation and fallback support
- [ ] Configuration system with comprehensive validation

### 2. Integration
- [ ] All existing functionality continues to work with enhanced error handling
- [ ] Model configuration integrates with all components
- [ ] Error contexts provide useful debugging information
- [ ] Fallback mechanisms work correctly

### 3. Performance
- [ ] Error handling adds minimal overhead (< 5ms per operation)
- [ ] Retry logic doesn't cause excessive delays
- [ ] Circuit breakers respond quickly to failures
- [ ] Model registry operations are fast (< 1ms)

### 4. Security
- [ ] Error messages don't leak sensitive information
- [ ] Configuration validation prevents security issues
- [ ] API key handling is secure in error scenarios
- [ ] Audit logging captures security-relevant errors

### 5. Testing
- [ ] Unit tests cover all error scenarios
- [ ] Integration tests verify end-to-end error handling
- [ ] Performance tests validate acceptable overhead
- [ ] Security tests verify information protection

### 6. Documentation
- [ ] All error types and handling patterns documented
- [ ] Model configuration guide with examples
- [ ] Error handling best practices documented
- [ ] Troubleshooting guide for common errors

## References

### 1. Anthropic Documentation
- [Claude API Error Handling](https://docs.anthropic.com/en/api/errors)
- [Claude 4 Models Overview](https://docs.anthropic.com/en/docs/about-claude/models/overview)
- [API Rate Limits](https://docs.anthropic.com/en/api/rate-limits)

### 2. GitHub Issues
- [Issue 1.1: Enhanced ContentBlock System](./1.1-enhanced-contentblock-system.md)
- [Issue 1.3: Tool Result Handling](./1.3-tool-result-handling-feedback.md)
- [Issue 1.4: Streaming Foundation](./1.4-streaming-foundation.md)

### 3. Technical Resources
- [Rust Error Handling Best Practices](https://blog.burntsushi.net/rust-error-handling/)
- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html)
- [Exponential Backoff Algorithm](https://en.wikipedia.org/wiki/Exponential_backoff)

### 4. Internal Documentation
- [Implementation Sequencing Guide](../implementation-sequencing.md)
- [Architecture Overview](../architecture/overview.md)
- [Security Guidelines](../security/guidelines.md)

## Estimated Lines of Code

**Implementation: ~1,500 LOC**
- Error type system: ~400 LOC  
- Error handler with retry logic: ~400 LOC
- Model registry and configuration: ~500 LOC
- Integration with existing components: ~200 LOC

**Testing: ~550 LOC**
- Unit tests: ~250 LOC
- Integration tests: ~200 LOC  
- Performance tests: ~100 LOC

**Total: ~2,050 LOC**

⚠️ **Large Ticket Alert**: This ticket exceeds 2000 LOC and should be reviewed for potential splitting into smaller units.

**Suggested Split:**
- **1.2a**: Core Error Framework (~1,000 LOC)
- **1.2b**: Model Configuration System (~1,050 LOC)

This comprehensive error handling and model configuration system provides the foundation for all subsequent features while ensuring robust, secure, and maintainable error handling throughout the application.