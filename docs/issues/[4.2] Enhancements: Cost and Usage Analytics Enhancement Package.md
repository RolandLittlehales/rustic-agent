# [4.2] Enhancements: Cost and Usage Analytics Enhancement Package

## Overview

This issue implements comprehensive cost and usage analytics to provide detailed insights into token consumption, API costs, billing controls, and usage optimization. This package ensures organizations can effectively monitor, control, and optimize their Claude API usage with granular cost tracking, budget enforcement, and predictive analytics.

**Why This Matters:**
- Current system lacks detailed token usage tracking and cost visibility
- No budget controls or spending limits enforcement
- Limited ability to optimize prompt efficiency and reduce costs
- No per-user or per-project cost allocation capabilities
- Insufficient analytics for cost prediction and optimization

**Current State:**
- Basic API calls without token tracking
- No cost calculation or usage analytics
- Manual monitoring of API expenses
- No budget enforcement mechanisms
- Limited visibility into usage patterns

**Target State:**
- Real-time token usage tracking with cost calculation
- Comprehensive usage analytics and reporting
- Automated budget controls and spending limits
- Token optimization recommendations
- Per-user and per-project cost allocation
- Predictive cost analytics and alerts

## Technical Requirements

### 1. Token Tracking System

#### 1.1 Core Token Counter Implementation
```rust
// New file: src-tauri/src/analytics/token_counter.rs
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::RwLock;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenUsage {
    pub prompt_tokens: u64,
    pub completion_tokens: u64,
    pub total_tokens: u64,
    pub model: String,
    pub timestamp: DateTime<Utc>,
    pub request_id: String,
    pub user_id: Option<String>,
    pub project_id: Option<String>,
    pub tool_uses: Vec<String>,
    pub metadata: HashMap<String, serde_json::Value>,
}

impl TokenUsage {
    pub fn new(
        prompt_tokens: u64,
        completion_tokens: u64,
        model: String,
        request_id: String,
    ) -> Self {
        let total_tokens = prompt_tokens + completion_tokens;
        Self {
            prompt_tokens,
            completion_tokens,
            total_tokens,
            model,
            timestamp: Utc::now(),
            request_id,
            user_id: None,
            project_id: None,
            tool_uses: Vec::new(),
            metadata: HashMap::new(),
        }
    }

    pub fn with_user(mut self, user_id: impl Into<String>) -> Self {
        self.user_id = Some(user_id.into());
        self
    }

    pub fn with_project(mut self, project_id: impl Into<String>) -> Self {
        self.project_id = Some(project_id.into());
        self
    }

    pub fn with_tool_uses(mut self, tools: Vec<String>) -> Self {
        self.tool_uses = tools;
        self
    }

    pub fn with_metadata(mut self, key: impl Into<String>, value: serde_json::Value) -> Self {
        self.metadata.insert(key.into(), value);
        self
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenStatistics {
    pub total_prompt_tokens: u64,
    pub total_completion_tokens: u64,
    pub total_tokens: u64,
    pub request_count: u64,
    pub average_prompt_tokens: f64,
    pub average_completion_tokens: f64,
    pub average_total_tokens: f64,
    pub period_start: DateTime<Utc>,
    pub period_end: DateTime<Utc>,
}

pub struct TokenCounter {
    prompt_tokens: AtomicU64,
    completion_tokens: AtomicU64,
    request_count: AtomicU64,
    usage_history: Arc<RwLock<Vec<TokenUsage>>>,
    usage_by_user: Arc<RwLock<HashMap<String, TokenStatistics>>>,
    usage_by_project: Arc<RwLock<HashMap<String, TokenStatistics>>>,
    usage_by_model: Arc<RwLock<HashMap<String, TokenStatistics>>>,
}

impl TokenCounter {
    pub fn new() -> Self {
        Self {
            prompt_tokens: AtomicU64::new(0),
            completion_tokens: AtomicU64::new(0),
            request_count: AtomicU64::new(0),
            usage_history: Arc::new(RwLock::new(Vec::new())),
            usage_by_user: Arc::new(RwLock::new(HashMap::new())),
            usage_by_project: Arc::new(RwLock::new(HashMap::new())),
            usage_by_model: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub async fn record_usage(&self, usage: TokenUsage) {
        // Update global counters
        self.prompt_tokens.fetch_add(usage.prompt_tokens, Ordering::Relaxed);
        self.completion_tokens.fetch_add(usage.completion_tokens, Ordering::Relaxed);
        self.request_count.fetch_add(1, Ordering::Relaxed);

        // Update per-user statistics
        if let Some(user_id) = &usage.user_id {
            let mut usage_by_user = self.usage_by_user.write().await;
            let stats = usage_by_user.entry(user_id.clone()).or_insert_with(|| {
                TokenStatistics {
                    total_prompt_tokens: 0,
                    total_completion_tokens: 0,
                    total_tokens: 0,
                    request_count: 0,
                    average_prompt_tokens: 0.0,
                    average_completion_tokens: 0.0,
                    average_total_tokens: 0.0,
                    period_start: usage.timestamp,
                    period_end: usage.timestamp,
                }
            });
            self.update_statistics(stats, &usage);
        }

        // Update per-project statistics
        if let Some(project_id) = &usage.project_id {
            let mut usage_by_project = self.usage_by_project.write().await;
            let stats = usage_by_project.entry(project_id.clone()).or_insert_with(|| {
                TokenStatistics {
                    total_prompt_tokens: 0,
                    total_completion_tokens: 0,
                    total_tokens: 0,
                    request_count: 0,
                    average_prompt_tokens: 0.0,
                    average_completion_tokens: 0.0,
                    average_total_tokens: 0.0,
                    period_start: usage.timestamp,
                    period_end: usage.timestamp,
                }
            });
            self.update_statistics(stats, &usage);
        }

        // Update per-model statistics
        {
            let mut usage_by_model = self.usage_by_model.write().await;
            let stats = usage_by_model.entry(usage.model.clone()).or_insert_with(|| {
                TokenStatistics {
                    total_prompt_tokens: 0,
                    total_completion_tokens: 0,
                    total_tokens: 0,
                    request_count: 0,
                    average_prompt_tokens: 0.0,
                    average_completion_tokens: 0.0,
                    average_total_tokens: 0.0,
                    period_start: usage.timestamp,
                    period_end: usage.timestamp,
                }
            });
            self.update_statistics(stats, &usage);
        }

        // Add to history
        self.usage_history.write().await.push(usage);
    }

    fn update_statistics(&self, stats: &mut TokenStatistics, usage: &TokenUsage) {
        stats.total_prompt_tokens += usage.prompt_tokens;
        stats.total_completion_tokens += usage.completion_tokens;
        stats.total_tokens += usage.total_tokens;
        stats.request_count += 1;
        
        // Update averages
        let count = stats.request_count as f64;
        stats.average_prompt_tokens = stats.total_prompt_tokens as f64 / count;
        stats.average_completion_tokens = stats.total_completion_tokens as f64 / count;
        stats.average_total_tokens = stats.total_tokens as f64 / count;
        
        // Update time range
        if usage.timestamp < stats.period_start {
            stats.period_start = usage.timestamp;
        }
        if usage.timestamp > stats.period_end {
            stats.period_end = usage.timestamp;
        }
    }

    pub fn get_total_usage(&self) -> (u64, u64, u64) {
        let prompt = self.prompt_tokens.load(Ordering::Relaxed);
        let completion = self.completion_tokens.load(Ordering::Relaxed);
        let requests = self.request_count.load(Ordering::Relaxed);
        (prompt, completion, requests)
    }

    pub async fn get_usage_by_user(&self, user_id: &str) -> Option<TokenStatistics> {
        self.usage_by_user.read().await.get(user_id).cloned()
    }

    pub async fn get_usage_by_project(&self, project_id: &str) -> Option<TokenStatistics> {
        self.usage_by_project.read().await.get(project_id).cloned()
    }

    pub async fn get_usage_by_model(&self, model: &str) -> Option<TokenStatistics> {
        self.usage_by_model.read().await.get(model).cloned()
    }

    pub async fn get_usage_history(
        &self,
        start_time: Option<DateTime<Utc>>,
        end_time: Option<DateTime<Utc>>,
        user_id: Option<&str>,
        project_id: Option<&str>,
    ) -> Vec<TokenUsage> {
        let history = self.usage_history.read().await;
        
        history.iter()
            .filter(|usage| {
                let time_filter = match (start_time, end_time) {
                    (Some(start), Some(end)) => usage.timestamp >= start && usage.timestamp <= end,
                    (Some(start), None) => usage.timestamp >= start,
                    (None, Some(end)) => usage.timestamp <= end,
                    (None, None) => true,
                };
                
                let user_filter = user_id.map_or(true, |id| {
                    usage.user_id.as_ref().map_or(false, |uid| uid == id)
                });
                
                let project_filter = project_id.map_or(true, |id| {
                    usage.project_id.as_ref().map_or(false, |pid| pid == id)
                });
                
                time_filter && user_filter && project_filter
            })
            .cloned()
            .collect()
    }

    pub async fn reset_counters(&self) {
        self.prompt_tokens.store(0, Ordering::Relaxed);
        self.completion_tokens.store(0, Ordering::Relaxed);
        self.request_count.store(0, Ordering::Relaxed);
        self.usage_history.write().await.clear();
        self.usage_by_user.write().await.clear();
        self.usage_by_project.write().await.clear();
        self.usage_by_model.write().await.clear();
    }

    pub async fn export_usage_data(&self) -> UsageExport {
        let (prompt, completion, requests) = self.get_total_usage();
        
        UsageExport {
            total_prompt_tokens: prompt,
            total_completion_tokens: completion,
            total_requests: requests,
            usage_by_user: self.usage_by_user.read().await.clone(),
            usage_by_project: self.usage_by_project.read().await.clone(),
            usage_by_model: self.usage_by_model.read().await.clone(),
            export_timestamp: Utc::now(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UsageExport {
    pub total_prompt_tokens: u64,
    pub total_completion_tokens: u64,
    pub total_requests: u64,
    pub usage_by_user: HashMap<String, TokenStatistics>,
    pub usage_by_project: HashMap<String, TokenStatistics>,
    pub usage_by_model: HashMap<String, TokenStatistics>,
    pub export_timestamp: DateTime<Utc>,
}

impl Default for TokenCounter {
    fn default() -> Self {
        Self::new()
    }
}
```

#### 1.2 Token Estimation and Optimization
```rust
// New file: src-tauri/src/analytics/token_optimizer.rs
use tiktoken_rs::{cl100k_base, CoreBPE};
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenEstimate {
    pub text: String,
    pub estimated_tokens: usize,
    pub optimization_suggestions: Vec<OptimizationSuggestion>,
    pub optimized_text: Option<String>,
    pub optimized_tokens: Option<usize>,
    pub savings_percentage: Option<f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimizationSuggestion {
    pub suggestion_type: OptimizationType,
    pub description: String,
    pub impact: OptimizationImpact,
    pub original_segment: String,
    pub suggested_segment: String,
    pub token_savings: i32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OptimizationType {
    RemoveRedundancy,
    SimplifyLanguage,
    CompressWhitespace,
    AbbreviateCommon,
    RemoveFillers,
    ConsolidateInstructions,
    UseTokenEfficientFormat,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OptimizationImpact {
    High,
    Medium,
    Low,
}

pub struct TokenOptimizer {
    encoder: CoreBPE,
    abbreviations: HashMap<String, String>,
    filler_words: Vec<String>,
}

impl TokenOptimizer {
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let encoder = cl100k_base()?;
        
        let mut abbreviations = HashMap::new();
        abbreviations.insert("for example".to_string(), "e.g.".to_string());
        abbreviations.insert("that is".to_string(), "i.e.".to_string());
        abbreviations.insert("et cetera".to_string(), "etc.".to_string());
        abbreviations.insert("versus".to_string(), "vs.".to_string());
        
        let filler_words = vec![
            "actually", "basically", "certainly", "definitely", "essentially",
            "literally", "obviously", "particularly", "really", "simply",
            "specifically", "totally", "very", "just", "quite"
        ].into_iter().map(String::from).collect();
        
        Ok(Self {
            encoder,
            abbreviations,
            filler_words,
        })
    }

    pub fn estimate_tokens(&self, text: &str) -> Result<usize, Box<dyn std::error::Error>> {
        let tokens = self.encoder.encode_with_special_tokens(text);
        Ok(tokens.len())
    }

    pub fn analyze_and_optimize(&self, text: &str) -> Result<TokenEstimate, Box<dyn std::error::Error>> {
        let original_tokens = self.estimate_tokens(text)?;
        let mut suggestions = Vec::new();
        let mut optimized_text = text.to_string();

        // Compress whitespace
        let whitespace_optimized = self.compress_whitespace(&optimized_text);
        if whitespace_optimized != optimized_text {
            let savings = self.calculate_token_difference(&optimized_text, &whitespace_optimized)?;
            if savings > 0 {
                suggestions.push(OptimizationSuggestion {
                    suggestion_type: OptimizationType::CompressWhitespace,
                    description: "Compress multiple whitespaces to single spaces".to_string(),
                    impact: OptimizationImpact::Low,
                    original_segment: "Multiple spaces/newlines".to_string(),
                    suggested_segment: "Single spaces".to_string(),
                    token_savings: savings,
                });
                optimized_text = whitespace_optimized;
            }
        }

        // Remove filler words
        let (filler_removed, filler_suggestions) = self.remove_filler_words(&optimized_text)?;
        if filler_removed != optimized_text {
            suggestions.extend(filler_suggestions);
            optimized_text = filler_removed;
        }

        // Apply abbreviations
        let (abbreviated, abbrev_suggestions) = self.apply_abbreviations(&optimized_text)?;
        if abbreviated != optimized_text {
            suggestions.extend(abbrev_suggestions);
            optimized_text = abbreviated;
        }

        // Simplify redundant instructions
        let (simplified, simplify_suggestions) = self.simplify_instructions(&optimized_text)?;
        if simplified != optimized_text {
            suggestions.extend(simplify_suggestions);
            optimized_text = simplified;
        }

        let optimized_tokens = self.estimate_tokens(&optimized_text)?;
        let savings_percentage = if original_tokens > 0 {
            Some(((original_tokens - optimized_tokens) as f64 / original_tokens as f64) * 100.0)
        } else {
            None
        };

        Ok(TokenEstimate {
            text: text.to_string(),
            estimated_tokens: original_tokens,
            optimization_suggestions: suggestions,
            optimized_text: if optimized_text != text { Some(optimized_text) } else { None },
            optimized_tokens: if optimized_text != text { Some(optimized_tokens) } else { None },
            savings_percentage,
        })
    }

    fn compress_whitespace(&self, text: &str) -> String {
        // Replace multiple spaces with single space
        let mut result = text.to_string();
        while result.contains("  ") {
            result = result.replace("  ", " ");
        }
        
        // Replace multiple newlines with double newline
        while result.contains("\n\n\n") {
            result = result.replace("\n\n\n", "\n\n");
        }
        
        result.trim().to_string()
    }

    fn remove_filler_words(&self, text: &str) -> Result<(String, Vec<OptimizationSuggestion>), Box<dyn std::error::Error>> {
        let mut result = text.to_string();
        let mut suggestions = Vec::new();

        for filler in &self.filler_words {
            let pattern = format!(r"\b{}\s+", regex::escape(filler));
            let re = regex::Regex::new(&pattern)?;
            
            if re.is_match(&result) {
                let before = result.clone();
                result = re.replace_all(&result, "").to_string();
                
                let savings = self.calculate_token_difference(&before, &result)?;
                if savings > 0 {
                    suggestions.push(OptimizationSuggestion {
                        suggestion_type: OptimizationType::RemoveFillers,
                        description: format!("Remove filler word '{}'", filler),
                        impact: OptimizationImpact::Low,
                        original_segment: filler.clone(),
                        suggested_segment: "".to_string(),
                        token_savings: savings,
                    });
                }
            }
        }

        Ok((result, suggestions))
    }

    fn apply_abbreviations(&self, text: &str) -> Result<(String, Vec<OptimizationSuggestion>), Box<dyn std::error::Error>> {
        let mut result = text.to_string();
        let mut suggestions = Vec::new();

        for (long_form, short_form) in &self.abbreviations {
            if result.contains(long_form) {
                let before = result.clone();
                result = result.replace(long_form, short_form);
                
                let savings = self.calculate_token_difference(&before, &result)?;
                if savings > 0 {
                    suggestions.push(OptimizationSuggestion {
                        suggestion_type: OptimizationType::AbbreviateCommon,
                        description: format!("Abbreviate '{}' to '{}'", long_form, short_form),
                        impact: OptimizationImpact::Low,
                        original_segment: long_form.clone(),
                        suggested_segment: short_form.clone(),
                        token_savings: savings,
                    });
                }
            }
        }

        Ok((result, suggestions))
    }

    fn simplify_instructions(&self, text: &str) -> Result<(String, Vec<OptimizationSuggestion>), Box<dyn std::error::Error>> {
        let mut result = text.to_string();
        let mut suggestions = Vec::new();

        // Detect and simplify common redundant patterns
        let patterns = vec![
            ("Please ensure that you", "Ensure you"),
            ("I would like you to", "Please"),
            ("It is important to note that", "Note:"),
            ("In order to", "To"),
            ("Due to the fact that", "Because"),
        ];

        for (verbose, concise) in patterns {
            if result.contains(verbose) {
                let before = result.clone();
                result = result.replace(verbose, concise);
                
                let savings = self.calculate_token_difference(&before, &result)?;
                if savings > 0 {
                    suggestions.push(OptimizationSuggestion {
                        suggestion_type: OptimizationType::SimplifyLanguage,
                        description: "Simplify verbose phrasing".to_string(),
                        impact: OptimizationImpact::Medium,
                        original_segment: verbose.to_string(),
                        suggested_segment: concise.to_string(),
                        token_savings: savings,
                    });
                }
            }
        }

        Ok((result, suggestions))
    }

    fn calculate_token_difference(&self, before: &str, after: &str) -> Result<i32, Box<dyn std::error::Error>> {
        let before_tokens = self.estimate_tokens(before)? as i32;
        let after_tokens = self.estimate_tokens(after)? as i32;
        Ok(before_tokens - after_tokens)
    }

    pub fn batch_optimize(&self, texts: Vec<&str>) -> Result<Vec<TokenEstimate>, Box<dyn std::error::Error>> {
        texts.into_iter()
            .map(|text| self.analyze_and_optimize(text))
            .collect()
    }
}

impl Default for TokenOptimizer {
    fn default() -> Self {
        Self::new().expect("Failed to create default TokenOptimizer")
    }
}
```

### 2. Cost Calculation System

#### 2.1 Pricing Engine
```rust
// New file: src-tauri/src/analytics/pricing.rs
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use rust_decimal_macros::dec;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelPricing {
    pub model_id: String,
    pub input_price_per_million: Decimal,
    pub output_price_per_million: Decimal,
    pub context_window: u32,
    pub max_output_tokens: u32,
    pub effective_date: DateTime<Utc>,
    pub currency: String,
}

impl ModelPricing {
    pub fn calculate_cost(&self, input_tokens: u64, output_tokens: u64) -> Decimal {
        let input_cost = (Decimal::from(input_tokens) / dec!(1_000_000)) * self.input_price_per_million;
        let output_cost = (Decimal::from(output_tokens) / dec!(1_000_000)) * self.output_price_per_million;
        input_cost + output_cost
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CostCalculation {
    pub request_id: String,
    pub model: String,
    pub input_tokens: u64,
    pub output_tokens: u64,
    pub input_cost: Decimal,
    pub output_cost: Decimal,
    pub total_cost: Decimal,
    pub currency: String,
    pub timestamp: DateTime<Utc>,
    pub metadata: HashMap<String, serde_json::Value>,
}

pub struct PricingEngine {
    model_pricing: HashMap<String, ModelPricing>,
    cost_history: Arc<RwLock<Vec<CostCalculation>>>,
    total_costs: Arc<RwLock<HashMap<String, Decimal>>>,
}

impl PricingEngine {
    pub fn new() -> Self {
        let mut model_pricing = HashMap::new();
        
        // Claude 3.5 Sonnet pricing (as of 2024)
        model_pricing.insert(
            "claude-3-5-sonnet-20241022".to_string(),
            ModelPricing {
                model_id: "claude-3-5-sonnet-20241022".to_string(),
                input_price_per_million: dec!(3.0),
                output_price_per_million: dec!(15.0),
                context_window: 200000,
                max_output_tokens: 8192,
                effective_date: Utc::now(),
                currency: "USD".to_string(),
            }
        );
        
        // Claude 3 Opus pricing
        model_pricing.insert(
            "claude-3-opus-20240229".to_string(),
            ModelPricing {
                model_id: "claude-3-opus-20240229".to_string(),
                input_price_per_million: dec!(15.0),
                output_price_per_million: dec!(75.0),
                context_window: 200000,
                max_output_tokens: 4096,
                effective_date: Utc::now(),
                currency: "USD".to_string(),
            }
        );
        
        // Claude 3 Haiku pricing
        model_pricing.insert(
            "claude-3-haiku-20240307".to_string(),
            ModelPricing {
                model_id: "claude-3-haiku-20240307".to_string(),
                input_price_per_million: dec!(0.25),
                output_price_per_million: dec!(1.25),
                context_window: 200000,
                max_output_tokens: 4096,
                effective_date: Utc::now(),
                currency: "USD".to_string(),
            }
        );
        
        Self {
            model_pricing,
            cost_history: Arc::new(RwLock::new(Vec::new())),
            total_costs: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub fn update_pricing(&mut self, model_id: String, pricing: ModelPricing) {
        self.model_pricing.insert(model_id, pricing);
    }

    pub async fn calculate_request_cost(
        &self,
        request_id: String,
        model: &str,
        input_tokens: u64,
        output_tokens: u64,
        metadata: HashMap<String, serde_json::Value>,
    ) -> Result<CostCalculation, String> {
        let pricing = self.model_pricing.get(model)
            .ok_or_else(|| format!("No pricing information for model: {}", model))?;
        
        let input_cost = (Decimal::from(input_tokens) / dec!(1_000_000)) * pricing.input_price_per_million;
        let output_cost = (Decimal::from(output_tokens) / dec!(1_000_000)) * pricing.output_price_per_million;
        let total_cost = input_cost + output_cost;
        
        let calculation = CostCalculation {
            request_id,
            model: model.to_string(),
            input_tokens,
            output_tokens,
            input_cost,
            output_cost,
            total_cost,
            currency: pricing.currency.clone(),
            timestamp: Utc::now(),
            metadata,
        };
        
        // Update history and totals
        self.cost_history.write().await.push(calculation.clone());
        
        let mut total_costs = self.total_costs.write().await;
        let current_total = total_costs.entry(pricing.currency.clone()).or_insert(dec!(0));
        *current_total += total_cost;
        
        Ok(calculation)
    }

    pub async fn get_total_cost(&self, currency: &str) -> Decimal {
        self.total_costs.read().await
            .get(currency)
            .cloned()
            .unwrap_or(dec!(0))
    }

    pub async fn get_cost_history(
        &self,
        start_time: Option<DateTime<Utc>>,
        end_time: Option<DateTime<Utc>>,
        model: Option<&str>,
    ) -> Vec<CostCalculation> {
        let history = self.cost_history.read().await;
        
        history.iter()
            .filter(|calc| {
                let time_filter = match (start_time, end_time) {
                    (Some(start), Some(end)) => calc.timestamp >= start && calc.timestamp <= end,
                    (Some(start), None) => calc.timestamp >= start,
                    (None, Some(end)) => calc.timestamp <= end,
                    (None, None) => true,
                };
                
                let model_filter = model.map_or(true, |m| calc.model == m);
                
                time_filter && model_filter
            })
            .cloned()
            .collect()
    }

    pub async fn get_cost_breakdown(&self) -> CostBreakdown {
        let history = self.cost_history.read().await;
        let mut breakdown = CostBreakdown::new();
        
        for calc in history.iter() {
            // By model
            let model_costs = breakdown.by_model.entry(calc.model.clone())
                .or_insert(CostSummary::new(calc.currency.clone()));
            model_costs.add_cost(calc.input_cost, calc.output_cost, 1);
            
            // By currency
            let currency_costs = breakdown.by_currency.entry(calc.currency.clone())
                .or_insert(CostSummary::new(calc.currency.clone()));
            currency_costs.add_cost(calc.input_cost, calc.output_cost, 1);
            
            // By time period (daily)
            let date = calc.timestamp.date_naive();
            let daily_costs = breakdown.by_day.entry(date)
                .or_insert(CostSummary::new(calc.currency.clone()));
            daily_costs.add_cost(calc.input_cost, calc.output_cost, 1);
        }
        
        breakdown.total_costs = self.total_costs.read().await.clone();
        breakdown
    }

    pub fn estimate_monthly_cost(
        &self,
        daily_average_tokens: u64,
        model: &str,
        input_output_ratio: f64,
    ) -> Result<Decimal, String> {
        let pricing = self.model_pricing.get(model)
            .ok_or_else(|| format!("No pricing information for model: {}", model))?;
        
        let input_tokens = (daily_average_tokens as f64 * input_output_ratio) as u64;
        let output_tokens = daily_average_tokens - input_tokens;
        
        let daily_cost = pricing.calculate_cost(input_tokens, output_tokens);
        Ok(daily_cost * dec!(30))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CostSummary {
    pub currency: String,
    pub total_input_cost: Decimal,
    pub total_output_cost: Decimal,
    pub total_cost: Decimal,
    pub request_count: u64,
    pub average_cost_per_request: Decimal,
}

impl CostSummary {
    pub fn new(currency: String) -> Self {
        Self {
            currency,
            total_input_cost: dec!(0),
            total_output_cost: dec!(0),
            total_cost: dec!(0),
            request_count: 0,
            average_cost_per_request: dec!(0),
        }
    }

    pub fn add_cost(&mut self, input_cost: Decimal, output_cost: Decimal, requests: u64) {
        self.total_input_cost += input_cost;
        self.total_output_cost += output_cost;
        self.total_cost += input_cost + output_cost;
        self.request_count += requests;
        
        if self.request_count > 0 {
            self.average_cost_per_request = self.total_cost / Decimal::from(self.request_count);
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CostBreakdown {
    pub by_model: HashMap<String, CostSummary>,
    pub by_currency: HashMap<String, CostSummary>,
    pub by_day: HashMap<chrono::NaiveDate, CostSummary>,
    pub total_costs: HashMap<String, Decimal>,
}

impl CostBreakdown {
    pub fn new() -> Self {
        Self {
            by_model: HashMap::new(),
            by_currency: HashMap::new(),
            by_day: HashMap::new(),
            total_costs: HashMap::new(),
        }
    }
}

impl Default for PricingEngine {
    fn default() -> Self {
        Self::new()
    }
}
```

### 3. Budget Control System

#### 3.1 Budget Manager
```rust
// New file: src-tauri/src/analytics/budget.rs
use std::sync::Arc;
use tokio::sync::RwLock;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc, Duration};
use rust_decimal::Decimal;
use rust_decimal_macros::dec;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum BudgetPeriod {
    Daily,
    Weekly,
    Monthly,
    Quarterly,
    Annual,
    Custom { days: u32 },
}

impl BudgetPeriod {
    pub fn duration(&self) -> Duration {
        match self {
            BudgetPeriod::Daily => Duration::days(1),
            BudgetPeriod::Weekly => Duration::days(7),
            BudgetPeriod::Monthly => Duration::days(30),
            BudgetPeriod::Quarterly => Duration::days(90),
            BudgetPeriod::Annual => Duration::days(365),
            BudgetPeriod::Custom { days } => Duration::days(*days as i64),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Budget {
    pub id: String,
    pub name: String,
    pub amount: Decimal,
    pub currency: String,
    pub period: BudgetPeriod,
    pub start_date: DateTime<Utc>,
    pub end_date: Option<DateTime<Utc>>,
    pub warning_threshold: f64, // Percentage (0.0 - 1.0)
    pub hard_limit: bool,
    pub user_id: Option<String>,
    pub project_id: Option<String>,
    pub enabled: bool,
    pub created_at: DateTime<Utc>,
    pub metadata: HashMap<String, serde_json::Value>,
}

impl Budget {
    pub fn new(
        id: String,
        name: String,
        amount: Decimal,
        currency: String,
        period: BudgetPeriod,
    ) -> Self {
        let now = Utc::now();
        Self {
            id,
            name,
            amount,
            currency,
            period,
            start_date: now,
            end_date: None,
            warning_threshold: 0.8,
            hard_limit: true,
            user_id: None,
            project_id: None,
            enabled: true,
            created_at: now,
            metadata: HashMap::new(),
        }
    }

    pub fn with_warning_threshold(mut self, threshold: f64) -> Self {
        self.warning_threshold = threshold.clamp(0.0, 1.0);
        self
    }

    pub fn with_hard_limit(mut self, hard_limit: bool) -> Self {
        self.hard_limit = hard_limit;
        self
    }

    pub fn for_user(mut self, user_id: String) -> Self {
        self.user_id = Some(user_id);
        self
    }

    pub fn for_project(mut self, project_id: String) -> Self {
        self.project_id = Some(project_id);
        self
    }

    pub fn is_active(&self) -> bool {
        if !self.enabled {
            return false;
        }
        
        let now = Utc::now();
        if now < self.start_date {
            return false;
        }
        
        if let Some(end_date) = self.end_date {
            if now > end_date {
                return false;
            }
        }
        
        true
    }

    pub fn get_current_period_bounds(&self) -> (DateTime<Utc>, DateTime<Utc>) {
        let now = Utc::now();
        let period_duration = self.period.duration();
        
        let periods_since_start = (now - self.start_date).num_seconds() / period_duration.num_seconds();
        let current_period_start = self.start_date + period_duration * (periods_since_start as i32);
        let current_period_end = current_period_start + period_duration;
        
        (current_period_start, current_period_end)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BudgetStatus {
    pub budget_id: String,
    pub budget_name: String,
    pub period_start: DateTime<Utc>,
    pub period_end: DateTime<Utc>,
    pub budget_amount: Decimal,
    pub spent_amount: Decimal,
    pub remaining_amount: Decimal,
    pub usage_percentage: f64,
    pub is_warning: bool,
    pub is_exceeded: bool,
    pub currency: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum BudgetAction {
    Allow,
    Warn { message: String },
    Block { reason: String },
}

pub struct BudgetManager {
    budgets: Arc<RwLock<HashMap<String, Budget>>>,
    spending_tracker: Arc<RwLock<HashMap<String, HashMap<DateTime<Utc>, Decimal>>>>,
    pricing_engine: Arc<PricingEngine>,
}

impl BudgetManager {
    pub fn new(pricing_engine: Arc<PricingEngine>) -> Self {
        Self {
            budgets: Arc::new(RwLock::new(HashMap::new())),
            spending_tracker: Arc::new(RwLock::new(HashMap::new())),
            pricing_engine,
        }
    }

    pub async fn add_budget(&self, budget: Budget) -> Result<(), String> {
        let mut budgets = self.budgets.write().await;
        
        if budgets.contains_key(&budget.id) {
            return Err(format!("Budget with ID '{}' already exists", budget.id));
        }
        
        budgets.insert(budget.id.clone(), budget);
        Ok(())
    }

    pub async fn update_budget(&self, budget_id: &str, budget: Budget) -> Result<(), String> {
        let mut budgets = self.budgets.write().await;
        
        if !budgets.contains_key(budget_id) {
            return Err(format!("Budget with ID '{}' not found", budget_id));
        }
        
        budgets.insert(budget_id.to_string(), budget);
        Ok(())
    }

    pub async fn remove_budget(&self, budget_id: &str) -> Result<(), String> {
        let mut budgets = self.budgets.write().await;
        
        if budgets.remove(budget_id).is_none() {
            return Err(format!("Budget with ID '{}' not found", budget_id));
        }
        
        Ok(())
    }

    pub async fn check_budget_before_request(
        &self,
        estimated_cost: Decimal,
        currency: &str,
        user_id: Option<&str>,
        project_id: Option<&str>,
    ) -> BudgetAction {
        let budgets = self.budgets.read().await;
        let mut warnings = Vec::new();
        let mut blocks = Vec::new();
        
        for budget in budgets.values() {
            if !budget.is_active() || budget.currency != currency {
                continue;
            }
            
            // Check if budget applies to this request
            let applies = match (&budget.user_id, &budget.project_id, user_id, project_id) {
                (Some(budget_user), _, Some(req_user), _) => budget_user == req_user,
                (_, Some(budget_proj), _, Some(req_proj)) => budget_proj == req_proj,
                (None, None, _, _) => true, // Global budget
                _ => false,
            };
            
            if !applies {
                continue;
            }
            
            let status = self.get_budget_status(&budget.id).await;
            if let Ok(status) = status {
                let projected_spending = status.spent_amount + estimated_cost;
                let projected_percentage = (projected_spending / budget.amount).to_f64().unwrap_or(0.0);
                
                if projected_percentage > 1.0 && budget.hard_limit {
                    blocks.push(format!(
                        "Budget '{}' would be exceeded: {:.2} {} / {:.2} {} ({}%)",
                        budget.name,
                        projected_spending,
                        currency,
                        budget.amount,
                        currency,
                        (projected_percentage * 100.0) as i32
                    ));
                } else if projected_percentage > budget.warning_threshold {
                    warnings.push(format!(
                        "Budget '{}' warning: {:.2} {} / {:.2} {} ({}%)",
                        budget.name,
                        projected_spending,
                        currency,
                        budget.amount,
                        currency,
                        (projected_percentage * 100.0) as i32
                    ));
                }
            }
        }
        
        if !blocks.is_empty() {
            BudgetAction::Block {
                reason: blocks.join("; "),
            }
        } else if !warnings.is_empty() {
            BudgetAction::Warn {
                message: warnings.join("; "),
            }
        } else {
            BudgetAction::Allow
        }
    }

    pub async fn record_spending(
        &self,
        amount: Decimal,
        currency: &str,
        timestamp: DateTime<Utc>,
        user_id: Option<&str>,
        project_id: Option<&str>,
    ) {
        let mut tracker = self.spending_tracker.write().await;
        
        // Track global spending
        let global_key = format!("global:{}", currency);
        let global_spending = tracker.entry(global_key).or_insert_with(HashMap::new);
        global_spending.insert(timestamp, amount);
        
        // Track user-specific spending
        if let Some(user) = user_id {
            let user_key = format!("user:{}:{}", user, currency);
            let user_spending = tracker.entry(user_key).or_insert_with(HashMap::new);
            user_spending.insert(timestamp, amount);
        }
        
        // Track project-specific spending
        if let Some(project) = project_id {
            let project_key = format!("project:{}:{}", project, currency);
            let project_spending = tracker.entry(project_key).or_insert_with(HashMap::new);
            project_spending.insert(timestamp, amount);
        }
    }

    pub async fn get_budget_status(&self, budget_id: &str) -> Result<BudgetStatus, String> {
        let budgets = self.budgets.read().await;
        let budget = budgets.get(budget_id)
            .ok_or_else(|| format!("Budget '{}' not found", budget_id))?;
        
        let (period_start, period_end) = budget.get_current_period_bounds();
        let spent_amount = self.calculate_period_spending(
            budget,
            period_start,
            period_end,
        ).await;
        
        let remaining_amount = budget.amount - spent_amount;
        let usage_percentage = (spent_amount / budget.amount).to_f64().unwrap_or(0.0);
        
        Ok(BudgetStatus {
            budget_id: budget.id.clone(),
            budget_name: budget.name.clone(),
            period_start,
            period_end,
            budget_amount: budget.amount,
            spent_amount,
            remaining_amount,
            usage_percentage,
            is_warning: usage_percentage >= budget.warning_threshold,
            is_exceeded: usage_percentage >= 1.0,
            currency: budget.currency.clone(),
        })
    }

    async fn calculate_period_spending(
        &self,
        budget: &Budget,
        period_start: DateTime<Utc>,
        period_end: DateTime<Utc>,
    ) -> Decimal {
        let tracker = self.spending_tracker.read().await;
        let mut total = dec!(0);
        
        // Determine the key to look up spending
        let key = match (&budget.user_id, &budget.project_id) {
            (Some(user), _) => format!("user:{}:{}", user, budget.currency),
            (_, Some(project)) => format!("project:{}:{}", project, budget.currency),
            _ => format!("global:{}", budget.currency),
        };
        
        if let Some(spending_history) = tracker.get(&key) {
            for (timestamp, amount) in spending_history {
                if *timestamp >= period_start && *timestamp < period_end {
                    total += amount;
                }
            }
        }
        
        total
    }

    pub async fn get_all_budget_statuses(&self) -> Vec<BudgetStatus> {
        let budgets = self.budgets.read().await;
        let mut statuses = Vec::new();
        
        for budget_id in budgets.keys() {
            if let Ok(status) = self.get_budget_status(budget_id).await {
                statuses.push(status);
            }
        }
        
        statuses
    }

    pub async fn get_budget_forecast(
        &self,
        budget_id: &str,
        days_ahead: u32,
    ) -> Result<BudgetForecast, String> {
        let status = self.get_budget_status(budget_id).await?;
        let budgets = self.budgets.read().await;
        let budget = budgets.get(budget_id).unwrap();
        
        // Calculate average daily spending
        let days_in_period = (status.period_end - status.period_start).num_days() as f64;
        let days_elapsed = (Utc::now() - status.period_start).num_days() as f64;
        let average_daily_spending = if days_elapsed > 0.0 {
            status.spent_amount / Decimal::from_f64_retain(days_elapsed).unwrap_or(dec!(1))
        } else {
            dec!(0)
        };
        
        // Project future spending
        let projected_spending = average_daily_spending * Decimal::from(days_ahead);
        let projected_total = status.spent_amount + projected_spending;
        let projected_percentage = (projected_total / budget.amount).to_f64().unwrap_or(0.0);
        
        Ok(BudgetForecast {
            budget_id: budget_id.to_string(),
            current_spending: status.spent_amount,
            average_daily_spending,
            projected_spending: projected_total,
            days_until_exhausted: if average_daily_spending > dec!(0) {
                Some(((budget.amount - status.spent_amount) / average_daily_spending).to_f64().unwrap_or(0.0) as u32)
            } else {
                None
            },
            projected_percentage,
            forecast_date: Utc::now() + Duration::days(days_ahead as i64),
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BudgetForecast {
    pub budget_id: String,
    pub current_spending: Decimal,
    pub average_daily_spending: Decimal,
    pub projected_spending: Decimal,
    pub days_until_exhausted: Option<u32>,
    pub projected_percentage: f64,
    pub forecast_date: DateTime<Utc>,
}
```

### 4. Analytics and Reporting

#### 4.1 Usage Analytics Engine
```rust
// New file: src-tauri/src/analytics/analytics_engine.rs
use super::{TokenCounter, PricingEngine, BudgetManager};
use std::sync::Arc;
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc, Duration};
use rust_decimal::Decimal;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UsageReport {
    pub period_start: DateTime<Utc>,
    pub period_end: DateTime<Utc>,
    pub total_requests: u64,
    pub total_tokens: u64,
    pub total_cost: Decimal,
    pub average_tokens_per_request: f64,
    pub average_cost_per_request: Decimal,
    pub model_breakdown: Vec<ModelUsage>,
    pub user_breakdown: Vec<UserUsage>,
    pub project_breakdown: Vec<ProjectUsage>,
    pub daily_usage: Vec<DailyUsage>,
    pub cost_trends: CostTrends,
    pub optimization_opportunities: Vec<OptimizationOpportunity>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelUsage {
    pub model: String,
    pub requests: u64,
    pub tokens: u64,
    pub cost: Decimal,
    pub percentage_of_total: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserUsage {
    pub user_id: String,
    pub requests: u64,
    pub tokens: u64,
    pub cost: Decimal,
    pub average_tokens_per_request: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectUsage {
    pub project_id: String,
    pub requests: u64,
    pub tokens: u64,
    pub cost: Decimal,
    pub top_users: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DailyUsage {
    pub date: chrono::NaiveDate,
    pub requests: u64,
    pub tokens: u64,
    pub cost: Decimal,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CostTrends {
    pub daily_average: Decimal,
    pub weekly_average: Decimal,
    pub monthly_projection: Decimal,
    pub growth_rate: f64,
    pub peak_day: Option<chrono::NaiveDate>,
    pub peak_cost: Option<Decimal>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimizationOpportunity {
    pub opportunity_type: String,
    pub description: String,
    pub potential_savings: Decimal,
    pub implementation_effort: EffortLevel,
    pub recommendations: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EffortLevel {
    Low,
    Medium,
    High,
}

pub struct AnalyticsEngine {
    token_counter: Arc<TokenCounter>,
    pricing_engine: Arc<PricingEngine>,
    budget_manager: Arc<BudgetManager>,
}

impl AnalyticsEngine {
    pub fn new(
        token_counter: Arc<TokenCounter>,
        pricing_engine: Arc<PricingEngine>,
        budget_manager: Arc<BudgetManager>,
    ) -> Self {
        Self {
            token_counter,
            pricing_engine,
            budget_manager,
        }
    }

    pub async fn generate_usage_report(
        &self,
        start_date: DateTime<Utc>,
        end_date: DateTime<Utc>,
    ) -> Result<UsageReport, Box<dyn std::error::Error>> {
        // Get token usage history
        let usage_history = self.token_counter.get_usage_history(
            Some(start_date),
            Some(end_date),
            None,
            None,
        ).await;
        
        // Get cost history
        let cost_history = self.pricing_engine.get_cost_history(
            Some(start_date),
            Some(end_date),
            None,
        ).await;
        
        // Calculate totals
        let total_requests = usage_history.len() as u64;
        let total_tokens: u64 = usage_history.iter().map(|u| u.total_tokens).sum();
        let total_cost: Decimal = cost_history.iter().map(|c| c.total_cost).sum();
        
        // Calculate averages
        let average_tokens_per_request = if total_requests > 0 {
            total_tokens as f64 / total_requests as f64
        } else {
            0.0
        };
        
        let average_cost_per_request = if total_requests > 0 {
            total_cost / Decimal::from(total_requests)
        } else {
            Decimal::ZERO
        };
        
        // Generate breakdowns
        let model_breakdown = self.calculate_model_breakdown(&usage_history, &cost_history).await;
        let user_breakdown = self.calculate_user_breakdown(&usage_history, &cost_history).await;
        let project_breakdown = self.calculate_project_breakdown(&usage_history, &cost_history).await;
        let daily_usage = self.calculate_daily_usage(&usage_history, &cost_history).await;
        
        // Calculate trends
        let cost_trends = self.calculate_cost_trends(&daily_usage);
        
        // Identify optimization opportunities
        let optimization_opportunities = self.identify_optimization_opportunities(
            &usage_history,
            &model_breakdown,
            &user_breakdown,
        ).await;
        
        Ok(UsageReport {
            period_start: start_date,
            period_end: end_date,
            total_requests,
            total_tokens,
            total_cost,
            average_tokens_per_request,
            average_cost_per_request,
            model_breakdown,
            user_breakdown,
            project_breakdown,
            daily_usage,
            cost_trends,
            optimization_opportunities,
        })
    }

    async fn calculate_model_breakdown(
        &self,
        usage_history: &[TokenUsage],
        cost_history: &[CostCalculation],
    ) -> Vec<ModelUsage> {
        let mut model_stats: HashMap<String, (u64, u64, Decimal)> = HashMap::new();
        
        for usage in usage_history {
            let entry = model_stats.entry(usage.model.clone()).or_insert((0, 0, Decimal::ZERO));
            entry.0 += 1; // requests
            entry.1 += usage.total_tokens; // tokens
        }
        
        for cost in cost_history {
            if let Some(entry) = model_stats.get_mut(&cost.model) {
                entry.2 += cost.total_cost; // cost
            }
        }
        
        let total_cost: Decimal = model_stats.values().map(|(_, _, cost)| *cost).sum();
        
        model_stats.into_iter()
            .map(|(model, (requests, tokens, cost))| {
                ModelUsage {
                    model,
                    requests,
                    tokens,
                    cost,
                    percentage_of_total: if total_cost > Decimal::ZERO {
                        (cost / total_cost).to_f64().unwrap_or(0.0) * 100.0
                    } else {
                        0.0
                    },
                }
            })
            .collect()
    }

    async fn calculate_user_breakdown(
        &self,
        usage_history: &[TokenUsage],
        cost_history: &[CostCalculation],
    ) -> Vec<UserUsage> {
        let mut user_stats: HashMap<String, (u64, u64, Decimal)> = HashMap::new();
        
        for usage in usage_history {
            if let Some(user_id) = &usage.user_id {
                let entry = user_stats.entry(user_id.clone()).or_insert((0, 0, Decimal::ZERO));
                entry.0 += 1; // requests
                entry.1 += usage.total_tokens; // tokens
            }
        }
        
        // Match costs to users (simplified - in real implementation would use request IDs)
        for (user_id, (requests, tokens, cost)) in user_stats.iter_mut() {
            let user_costs: Decimal = cost_history.iter()
                .filter(|c| c.metadata.get("user_id")
                    .and_then(|v| v.as_str()) == Some(user_id))
                .map(|c| c.total_cost)
                .sum();
            *cost = user_costs;
        }
        
        user_stats.into_iter()
            .map(|(user_id, (requests, tokens, cost))| {
                UserUsage {
                    user_id,
                    requests,
                    tokens,
                    cost,
                    average_tokens_per_request: if requests > 0 {
                        tokens as f64 / requests as f64
                    } else {
                        0.0
                    },
                }
            })
            .collect()
    }

    async fn calculate_project_breakdown(
        &self,
        usage_history: &[TokenUsage],
        cost_history: &[CostCalculation],
    ) -> Vec<ProjectUsage> {
        let mut project_stats: HashMap<String, (u64, u64, Decimal, HashSet<String>)> = HashMap::new();
        
        for usage in usage_history {
            if let Some(project_id) = &usage.project_id {
                let entry = project_stats.entry(project_id.clone())
                    .or_insert((0, 0, Decimal::ZERO, HashSet::new()));
                entry.0 += 1; // requests
                entry.1 += usage.total_tokens; // tokens
                
                if let Some(user_id) = &usage.user_id {
                    entry.3.insert(user_id.clone()); // unique users
                }
            }
        }
        
        // Match costs to projects
        for (project_id, (requests, tokens, cost, users)) in project_stats.iter_mut() {
            let project_costs: Decimal = cost_history.iter()
                .filter(|c| c.metadata.get("project_id")
                    .and_then(|v| v.as_str()) == Some(project_id))
                .map(|c| c.total_cost)
                .sum();
            *cost = project_costs;
        }
        
        project_stats.into_iter()
            .map(|(project_id, (requests, tokens, cost, users))| {
                let mut top_users: Vec<String> = users.into_iter().collect();
                top_users.sort();
                top_users.truncate(5); // Top 5 users
                
                ProjectUsage {
                    project_id,
                    requests,
                    tokens,
                    cost,
                    top_users,
                }
            })
            .collect()
    }

    async fn calculate_daily_usage(
        &self,
        usage_history: &[TokenUsage],
        cost_history: &[CostCalculation],
    ) -> Vec<DailyUsage> {
        let mut daily_stats: HashMap<chrono::NaiveDate, (u64, u64, Decimal)> = HashMap::new();
        
        for usage in usage_history {
            let date = usage.timestamp.date_naive();
            let entry = daily_stats.entry(date).or_insert((0, 0, Decimal::ZERO));
            entry.0 += 1; // requests
            entry.1 += usage.total_tokens; // tokens
        }
        
        for cost in cost_history {
            let date = cost.timestamp.date_naive();
            if let Some(entry) = daily_stats.get_mut(&date) {
                entry.2 += cost.total_cost; // cost
            }
        }
        
        let mut daily_usage: Vec<DailyUsage> = daily_stats.into_iter()
            .map(|(date, (requests, tokens, cost))| {
                DailyUsage {
                    date,
                    requests,
                    tokens,
                    cost,
                }
            })
            .collect();
        
        daily_usage.sort_by_key(|d| d.date);
        daily_usage
    }

    fn calculate_cost_trends(&self, daily_usage: &[DailyUsage]) -> CostTrends {
        if daily_usage.is_empty() {
            return CostTrends {
                daily_average: Decimal::ZERO,
                weekly_average: Decimal::ZERO,
                monthly_projection: Decimal::ZERO,
                growth_rate: 0.0,
                peak_day: None,
                peak_cost: None,
            };
        }
        
        let total_cost: Decimal = daily_usage.iter().map(|d| d.cost).sum();
        let days = daily_usage.len() as u32;
        
        let daily_average = total_cost / Decimal::from(days);
        let weekly_average = daily_average * Decimal::from(7);
        let monthly_projection = daily_average * Decimal::from(30);
        
        // Calculate growth rate (simplified linear regression)
        let mut growth_rate = 0.0;
        if days > 7 {
            let first_week_avg = daily_usage.iter()
                .take(7)
                .map(|d| d.cost)
                .sum::<Decimal>() / Decimal::from(7);
            
            let last_week_avg = daily_usage.iter()
                .rev()
                .take(7)
                .map(|d| d.cost)
                .sum::<Decimal>() / Decimal::from(7);
            
            if first_week_avg > Decimal::ZERO {
                growth_rate = ((last_week_avg - first_week_avg) / first_week_avg).to_f64().unwrap_or(0.0);
            }
        }
        
        let peak = daily_usage.iter()
            .max_by_key(|d| d.cost)
            .cloned();
        
        CostTrends {
            daily_average,
            weekly_average,
            monthly_projection,
            growth_rate,
            peak_day: peak.as_ref().map(|p| p.date),
            peak_cost: peak.map(|p| p.cost),
        }
    }

    async fn identify_optimization_opportunities(
        &self,
        usage_history: &[TokenUsage],
        model_breakdown: &[ModelUsage],
        user_breakdown: &[UserUsage],
    ) -> Vec<OptimizationOpportunity> {
        let mut opportunities = Vec::new();
        
        // Check for expensive model usage
        let expensive_model_usage = model_breakdown.iter()
            .find(|m| m.model.contains("opus") && m.percentage_of_total > 30.0);
        
        if let Some(usage) = expensive_model_usage {
            opportunities.push(OptimizationOpportunity {
                opportunity_type: "Model Selection".to_string(),
                description: format!(
                    "High usage of expensive model '{}' ({}% of total cost)",
                    usage.model,
                    usage.percentage_of_total as i32
                ),
                potential_savings: usage.cost * Decimal::from_f64_retain(0.5).unwrap_or(Decimal::ZERO),
                implementation_effort: EffortLevel::Low,
                recommendations: vec![
                    "Consider using Claude 3.5 Sonnet for most tasks".to_string(),
                    "Reserve Opus for complex reasoning tasks only".to_string(),
                    "Use Haiku for simple text processing".to_string(),
                ],
            });
        }
        
        // Check for users with high token usage
        let high_token_users = user_breakdown.iter()
            .filter(|u| u.average_tokens_per_request > 5000.0)
            .collect::<Vec<_>>();
        
        if !high_token_users.is_empty() {
            let total_potential_savings: Decimal = high_token_users.iter()
                .map(|u| u.cost * Decimal::from_f64_retain(0.2).unwrap_or(Decimal::ZERO))
                .sum();
            
            opportunities.push(OptimizationOpportunity {
                opportunity_type: "Token Optimization".to_string(),
                description: format!(
                    "{} users have high average token usage (>5000 tokens/request)",
                    high_token_users.len()
                ),
                potential_savings: total_potential_savings,
                implementation_effort: EffortLevel::Medium,
                recommendations: vec![
                    "Implement prompt optimization techniques".to_string(),
                    "Use compression for repetitive content".to_string(),
                    "Split large requests into smaller chunks".to_string(),
                    "Cache common responses".to_string(),
                ],
            });
        }
        
        // Check for repetitive queries
        let mut request_patterns: HashMap<u64, u32> = HashMap::new();
        for usage in usage_history {
            // Simple pattern detection based on token count similarity
            let token_bucket = (usage.total_tokens / 100) * 100; // Round to nearest 100
            *request_patterns.entry(token_bucket).or_insert(0) += 1;
        }
        
        let repetitive_patterns = request_patterns.iter()
            .filter(|(_, count)| **count > 10)
            .count();
        
        if repetitive_patterns > 5 {
            opportunities.push(OptimizationOpportunity {
                opportunity_type: "Response Caching".to_string(),
                description: format!(
                    "Detected {} patterns of similar requests that could be cached",
                    repetitive_patterns
                ),
                potential_savings: Decimal::from_f64_retain(0.3).unwrap_or(Decimal::ZERO) * 
                    (usage_history.len() as f64 * 0.1) as i32,
                implementation_effort: EffortLevel::High,
                recommendations: vec![
                    "Implement semantic caching for similar queries".to_string(),
                    "Use embedding-based similarity detection".to_string(),
                    "Cache responses for common queries".to_string(),
                ],
            });
        }
        
        opportunities
    }

    pub async fn export_analytics_report(
        &self,
        report: &UsageReport,
        format: ExportFormat,
    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        match format {
            ExportFormat::Json => {
                let json = serde_json::to_vec_pretty(report)?;
                Ok(json)
            }
            ExportFormat::Csv => {
                // Simplified CSV export
                let mut csv = String::new();
                csv.push_str("Date,Requests,Tokens,Cost\n");
                
                for daily in &report.daily_usage {
                    csv.push_str(&format!(
                        "{},{},{},{}\n",
                        daily.date,
                        daily.requests,
                        daily.tokens,
                        daily.cost
                    ));
                }
                
                Ok(csv.into_bytes())
            }
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExportFormat {
    Json,
    Csv,
}
```

### 5. Integration and Commands

#### 5.1 Tauri Command Integration
```rust
// Add to src-tauri/src/main.rs

use crate::analytics::{
    TokenCounter, TokenUsage, PricingEngine, BudgetManager, Budget, BudgetPeriod,
    AnalyticsEngine, ExportFormat,
};

#[derive(Clone)]
struct AnalyticsState {
    token_counter: Arc<TokenCounter>,
    pricing_engine: Arc<PricingEngine>,
    budget_manager: Arc<BudgetManager>,
    analytics_engine: Arc<AnalyticsEngine>,
}

#[tauri::command]
async fn get_token_usage(
    state: tauri::State<'_, AnalyticsState>,
    user_id: Option<String>,
    project_id: Option<String>,
) -> Result<serde_json::Value, String> {
    let (prompt, completion, requests) = state.token_counter.get_total_usage();
    
    let mut result = serde_json::json!({
        "total_prompt_tokens": prompt,
        "total_completion_tokens": completion,
        "total_tokens": prompt + completion,
        "total_requests": requests,
    });
    
    if let Some(user) = user_id {
        if let Some(user_stats) = state.token_counter.get_usage_by_user(&user).await {
            result["user_statistics"] = serde_json::to_value(user_stats)
                .map_err(|e| e.to_string())?;
        }
    }
    
    if let Some(project) = project_id {
        if let Some(project_stats) = state.token_counter.get_usage_by_project(&project).await {
            result["project_statistics"] = serde_json::to_value(project_stats)
                .map_err(|e| e.to_string())?;
        }
    }
    
    Ok(result)
}

#[tauri::command]
async fn get_cost_breakdown(
    state: tauri::State<'_, AnalyticsState>,
) -> Result<serde_json::Value, String> {
    let breakdown = state.pricing_engine.get_cost_breakdown().await;
    serde_json::to_value(breakdown).map_err(|e| e.to_string())
}

#[tauri::command]
async fn estimate_prompt_cost(
    text: String,
    model: String,
    state: tauri::State<'_, AnalyticsState>,
) -> Result<serde_json::Value, String> {
    // Estimate tokens (simplified - in real implementation would use proper tokenizer)
    let estimated_tokens = (text.len() / 4) as u64; // Rough estimate
    
    let cost = state.pricing_engine
        .calculate_request_cost(
            uuid::Uuid::new_v4().to_string(),
            &model,
            estimated_tokens,
            0, // No completion tokens for estimation
            HashMap::new(),
        )
        .await?;
    
    Ok(serde_json::json!({
        "estimated_tokens": estimated_tokens,
        "estimated_cost": cost.total_cost,
        "currency": cost.currency,
        "model": model,
    }))
}

#[tauri::command]
async fn create_budget(
    name: String,
    amount: f64,
    currency: String,
    period: String,
    user_id: Option<String>,
    project_id: Option<String>,
    state: tauri::State<'_, AnalyticsState>,
) -> Result<(), String> {
    let budget_period = match period.as_str() {
        "daily" => BudgetPeriod::Daily,
        "weekly" => BudgetPeriod::Weekly,
        "monthly" => BudgetPeriod::Monthly,
        "quarterly" => BudgetPeriod::Quarterly,
        "annual" => BudgetPeriod::Annual,
        _ => return Err("Invalid budget period".to_string()),
    };
    
    let mut budget = Budget::new(
        uuid::Uuid::new_v4().to_string(),
        name,
        Decimal::from_f64_retain(amount).ok_or("Invalid amount")?,
        currency,
        budget_period,
    );
    
    if let Some(user) = user_id {
        budget = budget.for_user(user);
    }
    
    if let Some(project) = project_id {
        budget = budget.for_project(project);
    }
    
    state.budget_manager.add_budget(budget).await
}

#[tauri::command]
async fn get_budget_status(
    budget_id: String,
    state: tauri::State<'_, AnalyticsState>,
) -> Result<serde_json::Value, String> {
    let status = state.budget_manager.get_budget_status(&budget_id).await?;
    serde_json::to_value(status).map_err(|e| e.to_string())
}

#[tauri::command]
async fn generate_usage_report(
    start_date: String,
    end_date: String,
    state: tauri::State<'_, AnalyticsState>,
) -> Result<serde_json::Value, String> {
    let start = DateTime::parse_from_rfc3339(&start_date)
        .map_err(|e| e.to_string())?
        .with_timezone(&Utc);
    
    let end = DateTime::parse_from_rfc3339(&end_date)
        .map_err(|e| e.to_string())?
        .with_timezone(&Utc);
    
    let report = state.analytics_engine
        .generate_usage_report(start, end)
        .await
        .map_err(|e| e.to_string())?;
    
    serde_json::to_value(report).map_err(|e| e.to_string())
}

#[tauri::command]
async fn optimize_prompt(
    text: String,
    state: tauri::State<'_, AnalyticsState>,
) -> Result<serde_json::Value, String> {
    // In real implementation, would use TokenOptimizer
    let optimizer = TokenOptimizer::new().map_err(|e| e.to_string())?;
    let result = optimizer.analyze_and_optimize(&text).map_err(|e| e.to_string())?;
    
    serde_json::to_value(result).map_err(|e| e.to_string())
}

// Hook into Claude API calls to track usage
async fn track_claude_api_usage(
    response: &ClaudeResponse,
    request_id: String,
    user_id: Option<String>,
    project_id: Option<String>,
    state: &AnalyticsState,
) -> Result<(), Box<dyn std::error::Error>> {
    // Extract token usage from response
    if let Some(usage) = &response.usage {
        let token_usage = TokenUsage::new(
            usage.input_tokens,
            usage.output_tokens,
            response.model.clone(),
            request_id.clone(),
        );
        
        let token_usage = if let Some(user) = user_id.clone() {
            token_usage.with_user(user)
        } else {
            token_usage
        };
        
        let token_usage = if let Some(project) = project_id.clone() {
            token_usage.with_project(project)
        } else {
            token_usage
        };
        
        // Record token usage
        state.token_counter.record_usage(token_usage).await;
        
        // Calculate and record cost
        let cost = state.pricing_engine
            .calculate_request_cost(
                request_id,
                &response.model,
                usage.input_tokens,
                usage.output_tokens,
                {
                    let mut metadata = HashMap::new();
                    if let Some(user) = &user_id {
                        metadata.insert("user_id".to_string(), serde_json::Value::String(user.clone()));
                    }
                    if let Some(project) = &project_id {
                        metadata.insert("project_id".to_string(), serde_json::Value::String(project.clone()));
                    }
                    metadata
                },
            )
            .await?;
        
        // Record spending for budget tracking
        state.budget_manager
            .record_spending(
                cost.total_cost,
                &cost.currency,
                cost.timestamp,
                user_id.as_deref(),
                project_id.as_deref(),
            )
            .await;
    }
    
    Ok(())
}
```

## Acceptance Criteria

### 1. Token Tracking
- [ ] Accurate token counting for all API requests
- [ ] Per-user and per-project token tracking
- [ ] Historical token usage data storage
- [ ] Token usage statistics and reporting
- [ ] Export functionality for usage data

### 2. Cost Calculation
- [ ] Accurate cost calculation based on current pricing
- [ ] Multi-model pricing support
- [ ] Cost breakdown by model, user, and project
- [ ] Historical cost tracking
- [ ] Cost forecasting capabilities

### 3. Budget Controls
- [ ] Create and manage budgets with different periods
- [ ] Real-time budget enforcement
- [ ] Warning thresholds and notifications
- [ ] Budget forecasting
- [ ] Per-user and per-project budgets

### 4. Token Optimization
- [ ] Token estimation before sending requests
- [ ] Optimization suggestions for prompts
- [ ] Batch optimization capabilities
- [ ] Token savings tracking
- [ ] Implementation of optimization techniques

### 5. Analytics and Reporting
- [ ] Comprehensive usage reports
- [ ] Cost trend analysis
- [ ] Optimization opportunity identification
- [ ] Export in multiple formats
- [ ] Real-time analytics dashboards

### 6. Integration
- [ ] Seamless integration with Claude API calls
- [ ] Tauri commands for all analytics features
- [ ] Frontend UI components for visualization
- [ ] Performance impact minimal (<1% overhead)

## References

### 1. Claude API Documentation
- [Anthropic API Pricing](https://www.anthropic.com/api#pricing)
- [Token Counting](https://docs.anthropic.com/claude/docs/models-overview#model-comparison)
- [Usage Tracking](https://docs.anthropic.com/claude/reference/usage)

### 2. Dependencies
- [tiktoken-rs](https://docs.rs/tiktoken-rs/) - Token counting
- [rust_decimal](https://docs.rs/rust_decimal/) - Precise decimal calculations
- [regex](https://docs.rs/regex/) - Pattern matching for optimization

### 3. Internal Documentation
- [Issue 4.1: Monitoring and Resilience](./4.1-monitoring-resilience.md)
- [Architecture Overview](../architecture/overview.md)
- [Configuration System](../configuration/analytics.md)

## Estimated Lines of Code

**Implementation: ~1,500 LOC**
- Token tracking system: ~300 LOC
- Token optimization: ~250 LOC
- Pricing engine: ~300 LOC
- Budget manager: ~350 LOC
- Analytics engine: ~300 LOC

**Integration and Commands: ~200 LOC**

**Total: ~1,700 LOC**

This comprehensive cost and usage analytics package provides organizations with detailed insights, budget controls, and optimization capabilities to effectively manage their Claude API usage and costs.