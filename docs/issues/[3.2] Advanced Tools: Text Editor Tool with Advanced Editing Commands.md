# [3.2] Advanced Tools: Text Editor Tool with Advanced Editing Commands

## Overview

This issue implements Anthropic's `text_editor_20250429` tool with comprehensive file editing capabilities, multi-file session management, and advanced editing features. Building on the Computer Use Tool foundation, this provides Claude with sophisticated text editing capabilities that go beyond simple file read/write operations.

**Why This Matters:**
- Enables complex code refactoring and multi-file editing workflows
- Provides transactional editing with rollback capabilities
- Supports advanced editing operations: undo/redo, search/replace, regex operations
- Integrates with existing whitelist security system
- Foundation for sophisticated code generation and editing workflows

**Current State:**
- Basic file read/write tools available through existing system
- Simple string-based file operations
- No multi-file session support
- No advanced editing features (undo, search/replace)
- No transaction support for complex edits

**Target State:**
- Full `text_editor_20250429` tool implementation with all standard operations
- Multi-file editing sessions with transactional integrity
- Advanced editing: undo/redo, search/replace, regex support, line-based operations
- Integration with Computer Use Tool for seamless workflow
- Comprehensive error handling and recovery mechanisms
- Performance optimization for large files and complex operations

## Technical Requirements

### 1. Anthropic Text Editor Tool Implementation

#### 1.1 Core TextEditor Tool Structure
```rust
// New file: src-tauri/src/claude/tools/text_editor.rs
use crate::claude::{
    error::{ClaudeError, ClaudeResult},
    tools::{AgentTool, ToolContext},
    whitelist::WhitelistConfig,
};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use tokio::fs;
use tokio::sync::{Mutex, RwLock};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEditorTool {
    name: String,
    description: String,
    sessions: Arc<Mutex<HashMap<String, EditingSession>>>,
    whitelist: Option<Arc<RwLock<WhitelistConfig>>>,
    config: TextEditorConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TextEditorConfig {
    pub max_file_size: usize,        // 10MB default
    pub max_session_files: usize,    // 100 files per session
    pub max_undo_history: usize,     // 50 operations
    pub auto_save_interval: u64,     // seconds, 0 = disabled
    pub backup_enabled: bool,
    pub line_ending_handling: LineEndingMode,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LineEndingMode {
    Preserve,
    Unix,
    Windows,
    Auto,
}

impl Default for TextEditorConfig {
    fn default() -> Self {
        Self {
            max_file_size: 10 * 1024 * 1024, // 10MB
            max_session_files: 100,
            max_undo_history: 50,
            auto_save_interval: 0, // Disabled by default
            backup_enabled: true,
            line_ending_handling: LineEndingMode::Preserve,
        }
    }
}

impl TextEditorTool {
    pub fn new() -> Self {
        Self {
            name: "text_editor_20250429".to_string(),
            description: "Text editing tool with support for viewing, creating, editing, and managing files with advanced features including undo/redo, search/replace, and multi-file sessions.".to_string(),
            sessions: Arc::new(Mutex::new(HashMap::new())),
            whitelist: None,
            config: TextEditorConfig::default(),
        }
    }
    
    pub fn with_config(config: TextEditorConfig) -> Self {
        Self {
            name: "text_editor_20250429".to_string(),
            description: "Text editing tool with advanced editing capabilities".to_string(),
            sessions: Arc::new(Mutex::new(HashMap::new())),
            whitelist: None,
            config,
        }
    }
    
    pub async fn start_session(&self, session_id: Option<String>) -> ClaudeResult<String> {
        let session_id = session_id.unwrap_or_else(|| Uuid::new_v4().to_string());
        let session = EditingSession::new(session_id.clone(), self.config.clone());
        
        let mut sessions = self.sessions.lock().await;
        sessions.insert(session_id.clone(), session);
        
        Ok(session_id)
    }
    
    pub async fn end_session(&self, session_id: &str, save_changes: bool) -> ClaudeResult<String> {
        let mut sessions = self.sessions.lock().await;
        
        if let Some(session) = sessions.get(session_id) {
            let result = if save_changes {
                session.save_all_changes().await?;
                format!("Session {} ended and all changes saved", session_id)
            } else {
                session.discard_all_changes().await?;
                format!("Session {} ended and all changes discarded", session_id)
            };
            
            sessions.remove(session_id);
            Ok(result)
        } else {
            Err(ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: format!("Session {} not found", session_id),
                context: None,
            })
        }
    }
}

#[async_trait]
impl AgentTool for TextEditorTool {
    fn name(&self) -> &str {
        &self.name
    }
    
    fn description(&self) -> &str {
        &self.description
    }
    
    fn parameters(&self) -> serde_json::Value {
        serde_json::json!({
            "type": "object",
            "properties": {
                "command": {
                    "type": "string",
                    "enum": [
                        "view", "create", "str_replace", "insert", 
                        "undo", "redo", "search", "goto", "scroll",
                        "start_session", "end_session", "list_files",
                        "regex_replace", "multi_replace", "format"
                    ],
                    "description": "The editing command to execute"
                },
                "path": {
                    "type": "string",
                    "description": "File path for file operations"
                },
                "session_id": {
                    "type": "string",
                    "description": "Optional session ID for multi-file editing"
                },
                "view_range": {
                    "type": "array",
                    "items": { "type": "integer" },
                    "minItems": 2,
                    "maxItems": 2,
                    "description": "Line range [start, end] for view command"
                },
                "file_text": {
                    "type": "string",
                    "description": "Content for create command"
                },
                "old_str": {
                    "type": "string",
                    "description": "String to replace in str_replace command"
                },
                "new_str": {
                    "type": "string",
                    "description": "Replacement string in str_replace command"
                },
                "insert_line": {
                    "type": "integer",
                    "description": "Line number for insert command"
                },
                "new_str": {
                    "type": "string",
                    "description": "Text to insert"
                },
                "search_term": {
                    "type": "string",
                    "description": "Search term for search command"
                },
                "line_number": {
                    "type": "integer",
                    "description": "Line number for goto command"
                },
                "direction": {
                    "type": "string",
                    "enum": ["up", "down"],
                    "description": "Scroll direction"
                },
                "amount": {
                    "type": "integer",
                    "description": "Number of lines to scroll"
                },
                "regex_pattern": {
                    "type": "string",
                    "description": "Regular expression pattern for regex operations"
                },
                "replacement": {
                    "type": "string",
                    "description": "Replacement text for regex operations"
                },
                "flags": {
                    "type": "string",
                    "description": "Regex flags (i=ignore case, g=global, m=multiline)"
                },
                "save_changes": {
                    "type": "boolean",
                    "description": "Whether to save changes when ending session"
                }
            },
            "required": ["command"]
        })
    }
    
    async fn execute(&self, input: serde_json::Value, context: ToolContext) -> ClaudeResult<String> {
        let command = input["command"].as_str()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Missing command parameter".to_string(),
                context: None,
            })?;
        
        match command {
            "view" => self.handle_view(input, context).await,
            "create" => self.handle_create(input, context).await,
            "str_replace" => self.handle_str_replace(input, context).await,
            "insert" => self.handle_insert(input, context).await,
            "undo" => self.handle_undo(input, context).await,
            "redo" => self.handle_redo(input, context).await,
            "search" => self.handle_search(input, context).await,
            "goto" => self.handle_goto(input, context).await,
            "scroll" => self.handle_scroll(input, context).await,
            "start_session" => self.handle_start_session(input, context).await,
            "end_session" => self.handle_end_session(input, context).await,
            "list_files" => self.handle_list_files(input, context).await,
            "regex_replace" => self.handle_regex_replace(input, context).await,
            "multi_replace" => self.handle_multi_replace(input, context).await,
            "format" => self.handle_format(input, context).await,
            _ => Err(ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: format!("Unknown command: {}", command),
                context: None,
            }),
        }
    }
    
    fn set_whitelist(&mut self, whitelist: Arc<RwLock<WhitelistConfig>>) {
        self.whitelist = Some(whitelist);
    }
}
```

#### 1.2 Editing Session Management
```rust
// Editing session management in src-tauri/src/claude/tools/text_editor.rs
#[derive(Debug, Clone)]
pub struct EditingSession {
    pub id: String,
    pub files: HashMap<PathBuf, FileEditState>,
    pub config: TextEditorConfig,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub last_accessed: chrono::DateTime<chrono::Utc>,
    pub current_file: Option<PathBuf>,
    pub view_position: ViewPosition,
}

#[derive(Debug, Clone)]
pub struct FileEditState {
    pub path: PathBuf,
    pub original_content: String,
    pub current_content: String,
    pub content_lines: Vec<String>,
    pub undo_stack: Vec<EditOperation>,
    pub redo_stack: Vec<EditOperation>,
    pub is_modified: bool,
    pub last_saved: Option<chrono::DateTime<chrono::Utc>>,
    pub encoding: FileEncoding,
    pub line_ending: LineEnding,
}

#[derive(Debug, Clone)]
pub struct ViewPosition {
    pub line: usize,
    pub column: usize,
    pub window_start: usize,
    pub window_size: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EditOperation {
    Insert {
        line: usize,
        column: usize,
        text: String,
        timestamp: chrono::DateTime<chrono::Utc>,
    },
    Delete {
        line: usize,
        column: usize,
        text: String,
        timestamp: chrono::DateTime<chrono::Utc>,
    },
    Replace {
        start_line: usize,
        start_column: usize,
        end_line: usize,
        end_column: usize,
        old_text: String,
        new_text: String,
        timestamp: chrono::DateTime<chrono::Utc>,
    },
    Batch {
        operations: Vec<EditOperation>,
        description: String,
        timestamp: chrono::DateTime<chrono::Utc>,
    },
}

#[derive(Debug, Clone)]
pub enum FileEncoding {
    Utf8,
    Utf8Bom,
    Latin1,
    Ascii,
}

#[derive(Debug, Clone)]
pub enum LineEnding {
    Unix,     // \n
    Windows,  // \r\n
    Classic,  // \r
    Mixed,    // Mixed line endings detected
}

impl EditingSession {
    pub fn new(id: String, config: TextEditorConfig) -> Self {
        Self {
            id,
            files: HashMap::new(),
            config,
            created_at: chrono::Utc::now(),
            last_accessed: chrono::Utc::now(),
            current_file: None,
            view_position: ViewPosition {
                line: 1,
                column: 1,
                window_start: 1,
                window_size: 50,
            },
        }
    }
    
    pub async fn load_file(&mut self, path: PathBuf) -> ClaudeResult<&FileEditState> {
        if self.files.len() >= self.config.max_session_files {
            return Err(ClaudeError::ToolError {
                tool_name: "text_editor_20250429".to_string(),
                message: format!("Session file limit reached: {}", self.config.max_session_files),
                context: None,
            });
        }
        
        let content = if path.exists() {
            fs::read_to_string(&path).await.map_err(|e| ClaudeError::ToolError {
                tool_name: "text_editor_20250429".to_string(),
                message: format!("Failed to read file {}: {}", path.display(), e),
                context: None,
            })?
        } else {
            String::new()
        };
        
        let (encoding, line_ending) = Self::detect_encoding_and_line_ending(&content);
        let content_lines = Self::split_lines(&content, &line_ending);
        
        let file_state = FileEditState {
            path: path.clone(),
            original_content: content.clone(),
            current_content: content,
            content_lines,
            undo_stack: Vec::new(),
            redo_stack: Vec::new(),
            is_modified: false,
            last_saved: None,
            encoding,
            line_ending,
        };
        
        self.files.insert(path.clone(), file_state);
        self.current_file = Some(path.clone());
        self.last_accessed = chrono::Utc::now();
        
        Ok(self.files.get(&path).unwrap())
    }
    
    pub async fn apply_edit(&mut self, path: &Path, operation: EditOperation) -> ClaudeResult<String> {
        let file_state = self.files.get_mut(path)
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: "text_editor_20250429".to_string(),
                message: format!("File {} not loaded in session", path.display()),
                context: None,
            })?;
        
        // Clear redo stack when new operation is applied
        file_state.redo_stack.clear();
        
        // Apply the operation
        let result = match &operation {
            EditOperation::Insert { line, column, text, .. } => {
                self.apply_insert(file_state, *line, *column, text)?
            },
            EditOperation::Delete { line, column, text, .. } => {
                self.apply_delete(file_state, *line, *column, text.len())?
            },
            EditOperation::Replace { start_line, start_column, end_line, end_column, new_text, .. } => {
                self.apply_replace(file_state, *start_line, *start_column, *end_line, *end_column, new_text)?
            },
            EditOperation::Batch { operations, description, .. } => {
                let mut results = Vec::new();
                for op in operations {
                    results.push(self.apply_single_operation(file_state, op)?);
                }
                format!("Batch operation '{}' completed: {} operations", description, results.len())
            },
        };
        
        // Add to undo stack
        file_state.undo_stack.push(operation);
        if file_state.undo_stack.len() > self.config.max_undo_history {
            file_state.undo_stack.remove(0);
        }
        
        file_state.is_modified = true;
        self.last_accessed = chrono::Utc::now();
        
        Ok(result)
    }
    
    pub async fn undo(&mut self, path: &Path) -> ClaudeResult<String> {
        let file_state = self.files.get_mut(path)
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: "text_editor_20250429".to_string(),
                message: format!("File {} not loaded in session", path.display()),
                context: None,
            })?;
        
        let operation = file_state.undo_stack.pop()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: "text_editor_20250429".to_string(),
                message: "No operations to undo".to_string(),
                context: None,
            })?;
        
        // Apply reverse operation
        let result = self.apply_reverse_operation(file_state, &operation)?;
        
        // Move to redo stack
        file_state.redo_stack.push(operation);
        
        file_state.is_modified = file_state.current_content != file_state.original_content;
        self.last_accessed = chrono::Utc::now();
        
        Ok(result)
    }
    
    pub async fn redo(&mut self, path: &Path) -> ClaudeResult<String> {
        let file_state = self.files.get_mut(path)
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: "text_editor_20250429".to_string(),
                message: format!("File {} not loaded in session", path.display()),
                context: None,
            })?;
        
        let operation = file_state.redo_stack.pop()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: "text_editor_20250429".to_string(),
                message: "No operations to redo".to_string(),
                context: None,
            })?;
        
        // Apply operation again
        let result = self.apply_single_operation(file_state, &operation)?;
        
        // Move back to undo stack
        file_state.undo_stack.push(operation);
        
        file_state.is_modified = true;
        self.last_accessed = chrono::Utc::now();
        
        Ok(result)
    }
    
    pub async fn save_file(&mut self, path: &Path) -> ClaudeResult<String> {
        let file_state = self.files.get_mut(path)
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: "text_editor_20250429".to_string(),
                message: format!("File {} not loaded in session", path.display()),
                context: None,
            })?;
        
        if !file_state.is_modified {
            return Ok(format!("File {} is already up to date", path.display()));
        }
        
        // Create backup if enabled
        if self.config.backup_enabled {
            self.create_backup(path).await?;
        }
        
        // Apply line ending conversion
        let content = self.apply_line_ending_conversion(&file_state.current_content, &file_state.line_ending);
        
        fs::write(path, content).await.map_err(|e| ClaudeError::ToolError {
            tool_name: "text_editor_20250429".to_string(),
            message: format!("Failed to save file {}: {}", path.display(), e),
            context: None,
        })?;
        
        file_state.original_content = file_state.current_content.clone();
        file_state.is_modified = false;
        file_state.last_saved = Some(chrono::Utc::now());
        
        Ok(format!("File {} saved successfully", path.display()))
    }
    
    pub async fn save_all_changes(&self) -> ClaudeResult<String> {
        let mut saved_files = Vec::new();
        let mut errors = Vec::new();
        
        for (path, file_state) in &self.files {
            if file_state.is_modified {
                match self.save_single_file(path, file_state).await {
                    Ok(_) => saved_files.push(path.display().to_string()),
                    Err(e) => errors.push(format!("{}: {}", path.display(), e)),
                }
            }
        }
        
        if !errors.is_empty() {
            return Err(ClaudeError::ToolError {
                tool_name: "text_editor_20250429".to_string(),
                message: format!("Failed to save some files: {}", errors.join(", ")),
                context: None,
            });
        }
        
        Ok(format!("Saved {} files: {}", saved_files.len(), saved_files.join(", ")))
    }
    
    pub async fn discard_all_changes(&mut self) -> ClaudeResult<String> {
        let mut discarded_files = Vec::new();
        
        for (path, file_state) in &mut self.files {
            if file_state.is_modified {
                file_state.current_content = file_state.original_content.clone();
                file_state.content_lines = Self::split_lines(&file_state.current_content, &file_state.line_ending);
                file_state.undo_stack.clear();
                file_state.redo_stack.clear();
                file_state.is_modified = false;
                discarded_files.push(path.display().to_string());
            }
        }
        
        Ok(format!("Discarded changes for {} files: {}", discarded_files.len(), discarded_files.join(", ")))
    }
    
    fn detect_encoding_and_line_ending(content: &str) -> (FileEncoding, LineEnding) {
        // Detect encoding (simplified)
        let encoding = if content.starts_with('\u{FEFF}') {
            FileEncoding::Utf8Bom
        } else if content.is_ascii() {
            FileEncoding::Ascii
        } else {
            FileEncoding::Utf8
        };
        
        // Detect line ending
        let has_crlf = content.contains("\r\n");
        let has_lf = content.contains('\n');
        let has_cr = content.contains('\r');
        
        let line_ending = match (has_crlf, has_lf, has_cr) {
            (true, _, _) => LineEnding::Windows,
            (false, true, false) => LineEnding::Unix,
            (false, false, true) => LineEnding::Classic,
            (false, true, true) => LineEnding::Mixed,
            _ => LineEnding::Unix, // Default
        };
        
        (encoding, line_ending)
    }
    
    fn split_lines(content: &str, line_ending: &LineEnding) -> Vec<String> {
        match line_ending {
            LineEnding::Windows => content.split("\r\n").map(|s| s.to_string()).collect(),
            LineEnding::Unix => content.split('\n').map(|s| s.to_string()).collect(),
            LineEnding::Classic => content.split('\r').map(|s| s.to_string()).collect(),
            LineEnding::Mixed => content.lines().map(|s| s.to_string()).collect(),
        }
    }
}
```

### 2. Advanced Text Editing Operations

#### 2.1 Command Handlers Implementation
```rust
// Command handler implementations in src-tauri/src/claude/tools/text_editor.rs
impl TextEditorTool {
    async fn handle_view(&self, input: serde_json::Value, context: ToolContext) -> ClaudeResult<String> {
        let path = self.extract_path(&input)?;
        self.validate_file_access(&path, &context).await?;
        
        let session_id = input["session_id"].as_str();
        let view_range = input["view_range"].as_array();
        
        let mut sessions = self.sessions.lock().await;
        let session = if let Some(sid) = session_id {
            sessions.get_mut(sid)
                .ok_or_else(|| ClaudeError::ToolError {
                    tool_name: self.name.clone(),
                    message: format!("Session {} not found", sid),
                    context: None,
                })?
        } else {
            // Create temporary session for one-off view
            let temp_id = Uuid::new_v4().to_string();
            sessions.insert(temp_id.clone(), EditingSession::new(temp_id.clone(), self.config.clone()));
            sessions.get_mut(&temp_id).unwrap()
        };
        
        // Load file if not already loaded
        if !session.files.contains_key(&path) {
            session.load_file(path.clone()).await?;
        }
        
        let file_state = session.files.get(&path).unwrap();
        
        let (start_line, end_line) = if let Some(range) = view_range {
            let start = range[0].as_u64().unwrap_or(1) as usize;
            let end = range[1].as_u64().unwrap_or(file_state.content_lines.len()) as usize;
            (start.max(1), end.min(file_state.content_lines.len()))
        } else {
            (1, file_state.content_lines.len().min(50)) // Default to first 50 lines
        };
        
        let mut result = String::new();
        result.push_str(&format!("File: {} (lines {}-{})\n", path.display(), start_line, end_line));
        result.push_str(&format!("Total lines: {}\n", file_state.content_lines.len()));
        result.push_str(&format!("Encoding: {:?}, Line ending: {:?}\n", file_state.encoding, file_state.line_ending));
        if file_state.is_modified {
            result.push_str("Status: MODIFIED\n");
        }
        result.push_str("---\n");
        
        for (idx, line) in file_state.content_lines.iter().enumerate() {
            let line_num = idx + 1;
            if line_num >= start_line && line_num <= end_line {
                result.push_str(&format!("{:4} | {}\n", line_num, line));
            }
        }
        
        if end_line < file_state.content_lines.len() {
            result.push_str(&format!("... {} more lines\n", file_state.content_lines.len() - end_line));
        }
        
        Ok(result)
    }
    
    async fn handle_create(&self, input: serde_json::Value, context: ToolContext) -> ClaudeResult<String> {
        let path = self.extract_path(&input)?;
        let file_text = input["file_text"].as_str()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Missing file_text parameter".to_string(),
                context: None,
            })?;
        
        self.validate_file_access(&path, &context).await?;
        
        if path.exists() {
            return Err(ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: format!("File {} already exists", path.display()),
                context: None,
            });
        }
        
        // Create parent directories if they don't exist
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).await.map_err(|e| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: format!("Failed to create directories: {}", e),
                context: None,
            })?;
        }
        
        fs::write(&path, file_text).await.map_err(|e| ClaudeError::ToolError {
            tool_name: self.name.clone(),
            message: format!("Failed to create file: {}", e),
            context: None,
        })?;
        
        let session_id = input["session_id"].as_str();
        if let Some(sid) = session_id {
            let mut sessions = self.sessions.lock().await;
            if let Some(session) = sessions.get_mut(sid) {
                session.load_file(path.clone()).await?;
            }
        }
        
        Ok(format!("File {} created successfully with {} bytes", path.display(), file_text.len()))
    }
    
    async fn handle_str_replace(&self, input: serde_json::Value, context: ToolContext) -> ClaudeResult<String> {
        let path = self.extract_path(&input)?;
        let old_str = input["old_str"].as_str()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Missing old_str parameter".to_string(),
                context: None,
            })?;
        let new_str = input["new_str"].as_str()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Missing new_str parameter".to_string(),
                context: None,
            })?;
        
        self.validate_file_access(&path, &context).await?;
        
        let session_id = input["session_id"].as_str()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Session ID required for editing operations".to_string(),
                context: None,
            })?;
        
        let mut sessions = self.sessions.lock().await;
        let session = sessions.get_mut(session_id)
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: format!("Session {} not found", session_id),
                context: None,
            })?;
        
        // Load file if not already loaded
        if !session.files.contains_key(&path) {
            session.load_file(path.clone()).await?;
        }
        
        let file_state = session.files.get(&path).unwrap();
        
        // Find all occurrences of old_str
        let occurrences = self.find_string_occurrences(&file_state.current_content, old_str);
        
        if occurrences.is_empty() {
            return Err(ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: format!("String '{}' not found in file", old_str),
                context: None,
            });
        }
        
        if occurrences.len() > 1 {
            return Err(ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: format!("String '{}' found {} times. Please be more specific or use multi_replace command", old_str, occurrences.len()),
                context: None,
            });
        }
        
        let (start_line, start_col, end_line, end_col) = occurrences[0];
        
        let operation = EditOperation::Replace {
            start_line,
            start_column: start_col,
            end_line,
            end_column: end_col,
            old_text: old_str.to_string(),
            new_text: new_str.to_string(),
            timestamp: chrono::Utc::now(),
        };
        
        session.apply_edit(&path, operation).await
    }
    
    async fn handle_search(&self, input: serde_json::Value, context: ToolContext) -> ClaudeResult<String> {
        let path = self.extract_path(&input)?;
        let search_term = input["search_term"].as_str()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Missing search_term parameter".to_string(),
                context: None,
            })?;
        
        self.validate_file_access(&path, &context).await?;
        
        let session_id = input["session_id"].as_str();
        let mut sessions = self.sessions.lock().await;
        
        let session = if let Some(sid) = session_id {
            sessions.get_mut(sid)
                .ok_or_else(|| ClaudeError::ToolError {
                    tool_name: self.name.clone(),
                    message: format!("Session {} not found", sid),
                    context: None,
                })?
        } else {
            // Create temporary session
            let temp_id = Uuid::new_v4().to_string();
            sessions.insert(temp_id.clone(), EditingSession::new(temp_id.clone(), self.config.clone()));
            sessions.get_mut(&temp_id).unwrap()
        };
        
        // Load file if not already loaded
        if !session.files.contains_key(&path) {
            session.load_file(path.clone()).await?;
        }
        
        let file_state = session.files.get(&path).unwrap();
        let mut results = Vec::new();
        
        for (line_idx, line) in file_state.content_lines.iter().enumerate() {
            if let Some(col_idx) = line.find(search_term) {
                results.push(format!("Line {}: {} | {}", 
                    line_idx + 1, 
                    col_idx + 1, 
                    line.trim()
                ));
            }
        }
        
        if results.is_empty() {
            Ok(format!("Search term '{}' not found in {}", search_term, path.display()))
        } else {
            Ok(format!("Found {} occurrences of '{}' in {}:\n{}", 
                results.len(), 
                search_term, 
                path.display(),
                results.join("\n")
            ))
        }
    }
    
    async fn handle_regex_replace(&self, input: serde_json::Value, context: ToolContext) -> ClaudeResult<String> {
        let path = self.extract_path(&input)?;
        let regex_pattern = input["regex_pattern"].as_str()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Missing regex_pattern parameter".to_string(),
                context: None,
            })?;
        let replacement = input["replacement"].as_str()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Missing replacement parameter".to_string(),
                context: None,
            })?;
        let flags = input["flags"].as_str().unwrap_or("");
        
        self.validate_file_access(&path, &context).await?;
        
        let session_id = input["session_id"].as_str()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Session ID required for editing operations".to_string(),
                context: None,
            })?;
        
        // Build regex with flags
        let mut regex_builder = regex::RegexBuilder::new(regex_pattern);
        
        if flags.contains('i') {
            regex_builder.case_insensitive(true);
        }
        if flags.contains('m') {
            regex_builder.multi_line(true);
        }
        
        let regex = regex_builder.build().map_err(|e| ClaudeError::ToolError {
            tool_name: self.name.clone(),
            message: format!("Invalid regex pattern: {}", e),
            context: None,
        })?;
        
        let mut sessions = self.sessions.lock().await;
        let session = sessions.get_mut(session_id)
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: format!("Session {} not found", session_id),
                context: None,
            })?;
        
        // Load file if not already loaded
        if !session.files.contains_key(&path) {
            session.load_file(path.clone()).await?;
        }
        
        let file_state = session.files.get(&path).unwrap();
        let original_content = &file_state.current_content;
        
        let (new_content, replacement_count) = if flags.contains('g') {
            // Global replace
            let new_content = regex.replace_all(original_content, replacement).to_string();
            let count = regex.find_iter(original_content).count();
            (new_content, count)
        } else {
            // Single replace
            if let Some(mat) = regex.find(original_content) {
                let new_content = regex.replace(original_content, replacement).to_string();
                (new_content, 1)
            } else {
                (original_content.clone(), 0)
            }
        };
        
        if replacement_count == 0 {
            return Ok(format!("Regex pattern '{}' not found in {}", regex_pattern, path.display()));
        }
        
        // Create batch operation for the entire replacement
        let operation = EditOperation::Replace {
            start_line: 1,
            start_column: 1,
            end_line: file_state.content_lines.len(),
            end_column: file_state.content_lines.last().map(|l| l.len() + 1).unwrap_or(1),
            old_text: original_content.clone(),
            new_text: new_content,
            timestamp: chrono::Utc::now(),
        };
        
        session.apply_edit(&path, operation).await?;
        
        Ok(format!("Regex replacement completed: {} matches replaced in {}", replacement_count, path.display()))
    }
    
    fn extract_path(&self, input: &serde_json::Value) -> ClaudeResult<PathBuf> {
        let path_str = input["path"].as_str()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Missing path parameter".to_string(),
                context: None,
            })?;
        
        Ok(PathBuf::from(path_str))
    }
    
    async fn validate_file_access(&self, path: &Path, context: &ToolContext) -> ClaudeResult<()> {
        if let Some(whitelist) = &self.whitelist {
            let whitelist_guard = whitelist.read().await;
            if !whitelist_guard.is_path_allowed(path) {
                return Err(ClaudeError::ToolError {
                    tool_name: self.name.clone(),
                    message: format!("Access denied to path: {}", path.display()),
                    context: None,
                });
            }
        }
        
        // Check file size limits
        if path.exists() {
            let metadata = path.metadata().map_err(|e| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: format!("Cannot read file metadata: {}", e),
                context: None,
            })?;
            
            if metadata.len() as usize > self.config.max_file_size {
                return Err(ClaudeError::ToolError {
                    tool_name: self.name.clone(),
                    message: format!("File size {} exceeds limit {}", metadata.len(), self.config.max_file_size),
                    context: None,
                });
            }
        }
        
        Ok(())
    }
    
    fn find_string_occurrences(&self, content: &str, search_str: &str) -> Vec<(usize, usize, usize, usize)> {
        let mut occurrences = Vec::new();
        let lines: Vec<&str> = content.lines().collect();
        
        for (line_idx, line) in lines.iter().enumerate() {
            let mut start_pos = 0;
            while let Some(col_idx) = line[start_pos..].find(search_str) {
                let actual_col = start_pos + col_idx;
                let end_col = actual_col + search_str.len();
                
                // Handle multi-line strings
                let search_lines: Vec<&str> = search_str.lines().collect();
                let end_line = if search_lines.len() > 1 {
                    line_idx + search_lines.len() - 1
                } else {
                    line_idx
                };
                
                occurrences.push((line_idx + 1, actual_col + 1, end_line + 1, end_col + 1));
                start_pos = actual_col + 1;
            }
        }
        
        occurrences
    }
}
```

### 3. Integration with Computer Use Tool

#### 3.1 Tool Registration and Integration
```rust
// Integration in src-tauri/src/claude/tools/mod.rs
use crate::claude::tools::{
    computer_use::ComputerUseTool,
    text_editor::TextEditorTool,
    read_file::ReadFileTool,
    write_file::WriteFileTool,
    list_directory::ListDirectoryTool,
};

pub struct ToolManager {
    tools: HashMap<String, Box<dyn AgentTool + Send + Sync>>,
    whitelist: Arc<RwLock<WhitelistConfig>>,
}

impl ToolManager {
    pub fn new(whitelist: Arc<RwLock<WhitelistConfig>>) -> Self {
        let mut tools: HashMap<String, Box<dyn AgentTool + Send + Sync>> = HashMap::new();
        
        // Register core tools
        let mut read_tool = ReadFileTool::new();
        read_tool.set_whitelist(whitelist.clone());
        tools.insert(read_tool.name().to_string(), Box::new(read_tool));
        
        let mut write_tool = WriteFileTool::new();
        write_tool.set_whitelist(whitelist.clone());
        tools.insert(write_tool.name().to_string(), Box::new(write_tool));
        
        let mut list_tool = ListDirectoryTool::new();
        list_tool.set_whitelist(whitelist.clone());
        tools.insert(list_tool.name().to_string(), Box::new(list_tool));
        
        // Register Computer Use Tool
        let mut computer_use_tool = ComputerUseTool::new();
        computer_use_tool.set_whitelist(whitelist.clone());
        tools.insert(computer_use_tool.name().to_string(), Box::new(computer_use_tool));
        
        // Register Text Editor Tool
        let mut text_editor_tool = TextEditorTool::new();
        text_editor_tool.set_whitelist(whitelist.clone());
        tools.insert(text_editor_tool.name().to_string(), Box::new(text_editor_tool));
        
        Self {
            tools,
            whitelist: whitelist.clone(),
        }
    }
    
    pub async fn execute_tool(&self, tool_name: &str, input: serde_json::Value, context: ToolContext) -> ClaudeResult<String> {
        let tool = self.tools.get(tool_name)
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: tool_name.to_string(),
                message: "Tool not found".to_string(),
                context: None,
            })?;
        
        tool.execute(input, context).await
    }
    
    pub fn get_tool_schemas(&self) -> Vec<serde_json::Value> {
        self.tools.values()
            .map(|tool| serde_json::json!({
                "name": tool.name(),
                "description": tool.description(),
                "input_schema": tool.parameters()
            }))
            .collect()
    }
    
    pub async fn create_text_editor_session(&self) -> ClaudeResult<String> {
        if let Some(tool) = self.tools.get("text_editor_20250429") {
            if let Ok(text_editor) = tool.as_any().downcast_ref::<TextEditorTool>() {
                return text_editor.start_session(None).await;
            }
        }
        
        Err(ClaudeError::ToolError {
            tool_name: "text_editor_20250429".to_string(),
            message: "Text editor tool not available".to_string(),
            context: None,
        })
    }
}
```

#### 3.2 Workflow Integration
```rust
// Enhanced workflow support in src-tauri/src/claude/tools/text_editor.rs
impl TextEditorTool {
    pub async fn handle_computer_use_integration(&self, input: serde_json::Value, context: ToolContext) -> ClaudeResult<String> {
        // Handle integration with computer use tool for complex workflows
        let workflow_type = input["workflow_type"].as_str().unwrap_or("default");
        
        match workflow_type {
            "code_refactor" => self.handle_code_refactor_workflow(input, context).await,
            "multi_file_edit" => self.handle_multi_file_edit_workflow(input, context).await,
            "search_replace_project" => self.handle_project_search_replace_workflow(input, context).await,
            _ => Err(ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: format!("Unknown workflow type: {}", workflow_type),
                context: None,
            }),
        }
    }
    
    async fn handle_code_refactor_workflow(&self, input: serde_json::Value, context: ToolContext) -> ClaudeResult<String> {
        let session_id = self.start_session(None).await?;
        let files = input["files"].as_array()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Files array required for refactor workflow".to_string(),
                context: None,
            })?;
        
        let mut results = Vec::new();
        
        // Load all files into session
        for file_value in files {
            let file_path = file_value.as_str()
                .ok_or_else(|| ClaudeError::ToolError {
                    tool_name: self.name.clone(),
                    message: "Invalid file path in files array".to_string(),
                    context: None,
                })?;
            
            let view_input = serde_json::json!({
                "command": "view",
                "path": file_path,
                "session_id": session_id
            });
            
            results.push(self.handle_view(view_input, context.clone()).await?);
        }
        
        Ok(format!("Refactor session {} started with {} files loaded:\n{}", 
            session_id, 
            files.len(),
            results.join("\n---\n")
        ))
    }
    
    async fn handle_multi_file_edit_workflow(&self, input: serde_json::Value, context: ToolContext) -> ClaudeResult<String> {
        let session_id = input["session_id"].as_str()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Session ID required for multi-file edit workflow".to_string(),
                context: None,
            })?;
        
        let operations = input["operations"].as_array()
            .ok_or_else(|| ClaudeError::ToolError {
                tool_name: self.name.clone(),
                message: "Operations array required".to_string(),
                context: None,
            })?;
        
        let mut results = Vec::new();
        
        // Execute operations in sequence with transaction support
        for operation in operations {
            let result = self.execute(operation.clone(), context.clone()).await;
            match result {
                Ok(res) => results.push(res),
                Err(e) => {
                    // Rollback on error
                    let rollback_input = serde_json::json!({
                        "command": "end_session",
                        "session_id": session_id,
                        "save_changes": false
                    });
                    let _ = self.handle_end_session(rollback_input, context).await;
                    return Err(e);
                }
            }
        }
        
        Ok(format!("Multi-file edit completed: {} operations executed successfully", results.len()))
    }
}
```

## Architecture Changes

### 1. Current vs. Target Architecture

**Current Architecture:**
```
Basic File Tools
    ↓
ReadFileTool / WriteFileTool / ListDirectoryTool
    ↓
Simple string operations
    ↓
No session management
```

**Target Architecture:**
```
Advanced Text Editor Tool
    ↓
EditingSession with multi-file support
    ↓
Advanced editing operations (undo/redo, search/replace, regex)
    ↓
Transaction support with rollback
    ↓
Integration with Computer Use Tool
    ↓
Workflow automation
```

### 2. File Structure Changes

**New Files:**
- `src-tauri/src/claude/tools/text_editor.rs` - Text editor tool implementation
- `src-tauri/src/claude/tools/text_editor/` - Directory for text editor modules
  - `session.rs` - Session management
  - `operations.rs` - Edit operations
  - `encoding.rs` - File encoding detection and handling
  - `workflows.rs` - Workflow integration

**Modified Files:**
- `src-tauri/src/claude/tools/mod.rs` - Tool registration and management
- `src-tauri/src/claude/client.rs` - Tool execution integration
- `src-tauri/src/claude/error.rs` - Enhanced error types for text editing

### 3. Dependencies Integration

**Crate Dependencies:**
```toml
# Add to Cargo.toml
[dependencies]
regex = "1.10"
encoding_rs = "0.8"
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
```

## Implementation Plan

### Phase 1: Core Text Editor Infrastructure (Week 1-2)
**Target: ~500 LOC**

1. **Basic Tool Structure** (3 days)
   - Create `TextEditorTool` struct and `AgentTool` implementation
   - Basic command routing and parameter validation
   - Integration with existing whitelist system

2. **File Session Management** (3 days)
   - Implement `EditingSession` and `FileEditState`
   - File loading, encoding detection, line ending handling
   - Basic session lifecycle management

3. **Core View and Create Commands** (2 days)
   - Implement `view` command with line range support
   - Implement `create` command with directory creation
   - Basic error handling and validation

### Phase 2: Advanced Editing Operations (Week 2-3)
**Target: ~400 LOC**

1. **String Replace Operations** (3 days)
   - Implement `str_replace` with occurrence validation
   - Multi-occurrence detection and error handling
   - Integration with edit operation system

2. **Undo/Redo System** (3 days)
   - Design and implement `EditOperation` enum
   - Undo/redo stack management with history limits
   - Operation reversal logic

3. **Search and Navigation** (2 days)
   - Implement `search` command with occurrence reporting
   - `goto` and `scroll` commands for navigation
   - View position management

### Phase 3: Advanced Features (Week 3-4)
**Target: ~400 LOC**

1. **Regex Operations** (3 days)
   - Implement `regex_replace` with flag support
   - Pattern validation and error handling
   - Performance optimization for large files

2. **Multi-file Session Support** (3 days)
   - Session-based file management
   - Transaction support with save/discard
   - Session cleanup and resource management

3. **File Encoding and Line Endings** (2 days)
   - Advanced encoding detection (UTF-8, UTF-8 BOM, Latin1)
   - Line ending conversion and preservation
   - Backup file creation

### Phase 4: Integration and Workflows (Week 4-5)
**Target: ~300 LOC**

1. **Computer Use Tool Integration** (3 days)
   - Workflow automation support
   - Multi-file editing workflows
   - Error handling and rollback mechanisms

2. **Tool Manager Integration** (2 days)
   - Register text editor in tool management system
   - Schema generation and validation
   - Context integration

3. **Performance Optimization** (2 days)
   - Large file handling optimization
   - Memory usage optimization
   - Concurrent operation support

### Phase 5: Testing and Documentation (Week 5-6)
**Target: ~400 LOC + Documentation**

1. **Comprehensive Testing** (3 days)
   - Unit tests for all operations
   - Integration tests with existing tools
   - Performance and stress testing

2. **Error Handling and Edge Cases** (2 days)
   - Comprehensive error scenario testing
   - Edge case handling (empty files, binary files, etc.)
   - Recovery mechanism testing

3. **Documentation and Examples** (2 days)
   - API documentation
   - Usage examples and workflows
   - Integration guides

## Testing Strategy

### 1. Unit Tests (300 LOC)

#### Text Editor Core Tests
```rust
#[cfg(test)]
mod text_editor_tests {
    use super::*;
    use tempfile::TempDir;
    
    #[tokio::test]
    async fn test_session_creation_and_management() {
        let editor = TextEditorTool::new();
        let session_id = editor.start_session(None).await.unwrap();
        
        assert!(!session_id.is_empty());
        
        let sessions = editor.sessions.lock().await;
        assert!(sessions.contains_key(&session_id));
    }
    
    #[tokio::test]
    async fn test_file_loading_and_encoding_detection() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.txt");
        
        // Test UTF-8 file
        fs::write(&file_path, "Hello, 世界!").await.unwrap();
        
        let editor = TextEditorTool::new();
        let session_id = editor.start_session(None).await.unwrap();
        
        let view_input = json!({
            "command": "view",
            "path": file_path.to_str().unwrap(),
            "session_id": session_id
        });
        
        let result = editor.execute(view_input, ToolContext::default()).await.unwrap();
        assert!(result.contains("Hello, 世界!"));
        assert!(result.contains("Encoding: Utf8"));
    }
    
    #[tokio::test]
    async fn test_string_replace_operations() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.txt");
        fs::write(&file_path, "Hello world\nGoodbye world").await.unwrap();
        
        let editor = TextEditorTool::new();
        let session_id = editor.start_session(None).await.unwrap();
        
        // Load file
        let view_input = json!({
            "command": "view",
            "path": file_path.to_str().unwrap(),
            "session_id": session_id
        });
        editor.execute(view_input, ToolContext::default()).await.unwrap();
        
        // Replace string
        let replace_input = json!({
            "command": "str_replace",
            "path": file_path.to_str().unwrap(),
            "session_id": session_id,
            "old_str": "world",
            "new_str": "universe"
        });
        
        let result = editor.execute(replace_input, ToolContext::default()).await;
        assert!(result.is_err()); // Should fail due to multiple occurrences
    }
    
    #[tokio::test]
    async fn test_undo_redo_operations() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.txt");
        fs::write(&file_path, "Original content").await.unwrap();
        
        let editor = TextEditorTool::new();
        let session_id = editor.start_session(None).await.unwrap();
        
        // Load and edit file
        let view_input = json!({
            "command": "view",
            "path": file_path.to_str().unwrap(),
            "session_id": session_id
        });
        editor.execute(view_input, ToolContext::default()).await.unwrap();
        
        let replace_input = json!({
            "command": "str_replace",
            "path": file_path.to_str().unwrap(),
            "session_id": session_id,
            "old_str": "Original content",
            "new_str": "Modified content"
        });
        editor.execute(replace_input, ToolContext::default()).await.unwrap();
        
        // Test undo
        let undo_input = json!({
            "command": "undo",
            "path": file_path.to_str().unwrap(),
            "session_id": session_id
        });
        let undo_result = editor.execute(undo_input, ToolContext::default()).await.unwrap();
        assert!(undo_result.contains("undo"));
        
        // Test redo
        let redo_input = json!({
            "command": "redo",
            "path": file_path.to_str().unwrap(),
            "session_id": session_id
        });
        let redo_result = editor.execute(redo_input, ToolContext::default()).await.unwrap();
        assert!(redo_result.contains("redo"));
    }
}
```

#### Regex and Search Tests
```rust
#[cfg(test)]
mod regex_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_regex_replace_with_flags() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.txt");
        fs::write(&file_path, "Hello WORLD\nHello world\nhello World").await.unwrap();
        
        let editor = TextEditorTool::new();
        let session_id = editor.start_session(None).await.unwrap();
        
        // Load file
        let view_input = json!({
            "command": "view",
            "path": file_path.to_str().unwrap(),
            "session_id": session_id
        });
        editor.execute(view_input, ToolContext::default()).await.unwrap();
        
        // Case-insensitive global replace
        let regex_input = json!({
            "command": "regex_replace",
            "path": file_path.to_str().unwrap(),
            "session_id": session_id,
            "regex_pattern": r"hello",
            "replacement": "Hi",
            "flags": "gi"
        });
        
        let result = editor.execute(regex_input, ToolContext::default()).await.unwrap();
        assert!(result.contains("3 matches replaced"));
    }
    
    #[tokio::test]
    async fn test_search_functionality() {
        let temp_dir = TempDir::new().unwrap();
        let file_path = temp_dir.path().join("test.txt");
        fs::write(&file_path, "Line 1 with search term\nLine 2 without\nLine 3 with search term").await.unwrap();
        
        let editor = TextEditorTool::new();
        
        let search_input = json!({
            "command": "search",
            "path": file_path.to_str().unwrap(),
            "search_term": "search term"
        });
        
        let result = editor.execute(search_input, ToolContext::default()).await.unwrap();
        assert!(result.contains("2 occurrences"));
        assert!(result.contains("Line 1"));
        assert!(result.contains("Line 3"));
    }
}
```

### 2. Integration Tests (200 LOC)

#### Tool Manager Integration
```rust
#[tokio::test]
async fn test_tool_manager_integration() {
    let whitelist = Arc::new(RwLock::new(WhitelistConfig::default()));
    let tool_manager = ToolManager::new(whitelist);
    
    // Test tool registration
    let schemas = tool_manager.get_tool_schemas();
    let text_editor_schema = schemas.iter()
        .find(|schema| schema["name"] == "text_editor_20250429")
        .expect("Text editor tool should be registered");
    
    assert_eq!(text_editor_schema["name"], "text_editor_20250429");
    assert!(!text_editor_schema["description"].as_str().unwrap().is_empty());
}

#[tokio::test]
async fn test_workflow_integration() {
    let temp_dir = TempDir::new().unwrap();
    let file1 = temp_dir.path().join("file1.txt");
    let file2 = temp_dir.path().join("file2.txt");
    
    fs::write(&file1, "Content of file 1").await.unwrap();
    fs::write(&file2, "Content of file 2").await.unwrap();
    
    let whitelist = Arc::new(RwLock::new(WhitelistConfig::default()));
    let tool_manager = ToolManager::new(whitelist);
    
    // Start multi-file session
    let session_id = tool_manager.create_text_editor_session().await.unwrap();
    
    // Execute multi-file workflow
    let workflow_input = json!({
        "command": "start_session",
        "session_id": session_id,
        "files": [
            file1.to_str().unwrap(),
            file2.to_str().unwrap()
        ]
    });
    
    let result = tool_manager.execute_tool("text_editor_20250429", workflow_input, ToolContext::default()).await.unwrap();
    assert!(result.contains("2 files loaded"));
}
```

### 3. Performance Tests (100 LOC)

#### Large File Handling
```rust
#[tokio::test]
async fn test_large_file_performance() {
    let temp_dir = TempDir::new().unwrap();
    let large_file = temp_dir.path().join("large.txt");
    
    // Create a large file (1MB)
    let content = "A".repeat(1024 * 1024);
    fs::write(&large_file, &content).await.unwrap();
    
    let editor = TextEditorTool::new();
    let session_id = editor.start_session(None).await.unwrap();
    
    let start = std::time::Instant::now();
    
    let view_input = json!({
        "command": "view",
        "path": large_file.to_str().unwrap(),
        "session_id": session_id,
        "view_range": [1, 100]
    });
    
    let result = editor.execute(view_input, ToolContext::default()).await.unwrap();
    let duration = start.elapsed();
    
    assert!(duration.as_millis() < 1000, "Large file view should complete in under 1 second");
    assert!(result.contains("Total lines:"));
}

#[tokio::test]
async fn test_memory_usage_multiple_sessions() {
    let editor = TextEditorTool::new();
    let mut session_ids = Vec::new();
    
    // Create multiple sessions
    for _ in 0..10 {
        let session_id = editor.start_session(None).await.unwrap();
        session_ids.push(session_id);
    }
    
    // Verify session count
    let sessions = editor.sessions.lock().await;
    assert_eq!(sessions.len(), 10);
    
    // Clean up sessions
    drop(sessions);
    for session_id in session_ids {
        let end_input = json!({
            "command": "end_session",
            "session_id": session_id,
            "save_changes": false
        });
        editor.execute(end_input, ToolContext::default()).await.unwrap();
    }
}
```

## Dependencies & Integration

### 1. Required Dependencies
This issue depends on:
- **Issue 3.1**: Computer Use Tool Implementation (provides workflow integration foundation)
- **Issue 2.1**: Parallel Tool Execution System (provides tool management framework)
- **Issue 1.3**: Tool Result Handling System (provides error handling and feedback)

### 2. Integration Points

#### 2.1 Computer Use Tool Integration
- Workflow automation for complex editing tasks
- Multi-step operations with rollback support
- Integration with UI automation for IDE-like experiences

#### 2.2 Whitelist System Integration
- Path validation for all file operations
- Security enforcement for editing operations
- Audit logging for file modifications

#### 2.3 Tool Management Integration
- Registration in centralized tool registry
- Schema generation for API documentation
- Context passing for security and audit

### 3. Provides Foundation For
- **Issue 3.3**: Code Execution Tool Integration (enhanced file editing for code)
- **Issue 3.5**: Advanced Context Management (file-based context tracking)
- **Issue 4.2**: Cost and Usage Analytics (editing operation tracking)

## Security Considerations

### 1. File Access Security
- Integration with existing whitelist system for path validation
- Size limits to prevent memory exhaustion attacks
- Encoding validation to prevent malformed file attacks
- Directory traversal protection

### 2. Edit Operation Security
- Session isolation to prevent cross-session interference
- Transaction support to ensure atomic operations
- Backup creation for critical file modifications
- Audit logging for all editing operations

### 3. Regex Security
- Pattern validation to prevent ReDoS attacks
- Timeout limits for complex regex operations
- Memory limits for regex processing
- Safe defaults for regex flags

### 4. Session Management Security
- Session timeout and cleanup
- Resource limits per session (files, memory, operations)
- Authentication context preservation
- Secure session ID generation

## Acceptance Criteria

### 1. Core Functionality
- [ ] TextEditorTool implements all Anthropic `text_editor_20250429` commands
- [ ] Multi-file editing sessions work correctly with transaction support
- [ ] Undo/redo operations work for all edit types with configurable history
- [ ] Search and regex operations work with proper performance
- [ ] File encoding detection and line ending preservation work correctly

### 2. Integration
- [ ] Integration with Computer Use Tool for workflow automation
- [ ] Integration with existing whitelist security system
- [ ] Tool registration in centralized tool management system
- [ ] Context passing works correctly for all operations

### 3. Performance
- [ ] Large files (up to 10MB) can be edited efficiently
- [ ] Multiple concurrent sessions don't cause memory issues
- [ ] Regex operations complete within reasonable time limits
- [ ] Session cleanup works correctly without memory leaks

### 4. Security
- [ ] All file operations respect whitelist configuration
- [ ] Session isolation prevents cross-contamination
- [ ] Regex operations are protected against ReDoS attacks
- [ ] Audit logging captures all significant operations

### 5. Error Handling
- [ ] All error conditions are handled gracefully
- [ ] Transaction rollback works correctly on failures
- [ ] Clear error messages are provided for invalid operations
- [ ] Recovery mechanisms work for common failure scenarios

### 6. Testing
- [ ] Unit tests cover all command implementations
- [ ] Integration tests verify tool manager integration
- [ ] Performance tests validate large file handling
- [ ] Security tests verify whitelist enforcement

## References

### 1. Anthropic Documentation
- [Text Editor Tool Specification](https://docs.anthropic.com/en/docs/tool-use/text-editor)
- [Tool Use Best Practices](https://docs.anthropic.com/en/docs/tool-use/best-practices)
- [Computer Use Integration Guide](https://docs.anthropic.com/en/docs/tool-use/computer-use)

### 2. GitHub Issues
- [Issue 3.1: Computer Use Tool Implementation](https://github.com/user/repo/issues/3.1)
- [Issue 2.1: Parallel Tool Execution System](https://github.com/user/repo/issues/2.1)
- [Issue 1.3: Tool Result Handling System](https://github.com/user/repo/issues/1.3)
- [Implementation Sequencing Guide](../implementation-sequencing.md)

### 3. Technical Resources
- [Regex Rust Documentation](https://docs.rs/regex/)
- [Encoding RS Documentation](https://docs.rs/encoding_rs/)
- [Tokio Async File Operations](https://docs.rs/tokio/latest/tokio/fs/)
- [Tauri v2 Commands](https://tauri.app/v2/guides/features/commands/)

### 4. Internal Documentation
- [Tool System Architecture](../architecture/tools.md)
- [Security Implementation Guide](../security/file-access.md)
- [Performance Guidelines](../development/performance.md)
- [Whitelist System Documentation](../security/whitelist.md)

## Estimated Lines of Code

**Implementation: ~1,500 LOC**
- Text editor tool core: ~500 LOC
- Session management: ~300 LOC
- Advanced operations (regex, undo/redo): ~400 LOC
- Computer use integration: ~200 LOC
- Tool manager integration: ~100 LOC

**Testing: ~600 LOC**
- Unit tests: ~300 LOC
- Integration tests: ~200 LOC
- Performance tests: ~100 LOC

**Total: ~2,100 LOC**

This comprehensive implementation provides sophisticated text editing capabilities that integrate seamlessly with the existing tool ecosystem while maintaining security and performance standards.